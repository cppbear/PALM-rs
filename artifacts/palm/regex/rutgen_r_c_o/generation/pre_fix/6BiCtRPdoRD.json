{
  "name": "regex_syntax::hir::literal::hir::literal::Literals::suffixes",
  "name_with_impl": "regex_syntax::hir::literal::{impl#0}::suffixes",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal/mod.rs:79:5:83:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: lits\n"
      ],
      "input_infer": "expr: valid Hir objects with varying complexity; expr: empty Hir; expr: Hir with characters exceeding limit_size (250); expr: Hir with character classes exceeding limit_class (10); expr: Hir with mixed character classes and literals; expr: Hir with Unicode characters and arbitrary bytes.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                "    suffixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_size(), 250);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_class(), 10);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.is_empty());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.all_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.any_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.literals().is_empty());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.min_len().is_none());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_suffix(), &[]);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_prefix(), &[]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_size(), 250);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_class(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.literals().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.min_len().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_suffix(), &[]);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Empty, info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_prefix(), &[]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_size` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:23\n     |\n1563 |     assert_eq!(result.limit_size(), 250);\n     |                       ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_class` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:23\n     |\n1563 |     assert_eq!(result.limit_class(), 10);\n     |                       ^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:20\n     |\n1563 |     assert!(result.is_empty());\n     |                    ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `contains_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:20\n     |\n1563 |     assert!(result.contains_empty());\n     |                    ^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `all_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:20\n     |\n1563 |     assert!(result.all_complete());\n     |                    ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `any_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:21\n     |\n1563 |     assert!(!result.any_complete());\n     |                     ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `literals` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:20\n     |\n1563 |     assert!(result.literals().is_empty());\n     |                    ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `min_len` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:20\n     |\n1563 |     assert!(result.min_len().is_none());\n     |                    ^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `longest_common_suffix` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:23\n     |\n1563 |     assert_eq!(result.longest_common_suffix(), &[]);\n     |                       ^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1559:50\n     |\n1559 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1560:5\n     |\n1560 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1560 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:50\n     |\n1561 |     let expr = Hir { kind: HirKind::Empty, info: Default::default() };\n     |                                                  ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1562:18\n     |\n1562 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1562 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `longest_common_prefix` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:23\n     |\n1563 |     assert_eq!(result.longest_common_prefix(), &[]);\n     |                       ^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let expr = Hir {",
                "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                "        info: Default::default(),",
                "    };",
                "    suffixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.is_empty(), false);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.limit_size(), 250);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.limit_class(), 10);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert!(suffixes_result.any_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert!(suffixes_result.longest_common_suffix().len() > 0);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.min_len(), Some(1));"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.literals().len(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.is_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.limit_size(), 250);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.limit_class(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert!(suffixes_result.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert!(suffixes_result.longest_common_suffix().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.min_len(), Some(1));",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };",
                  "    let suffixes_result = suffixes(&expr);",
                  "    assert_eq!(suffixes_result.literals().len(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:32\n     |\n1566 |     assert_eq!(suffixes_result.is_empty(), false);\n     |                                ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_size` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:32\n     |\n1566 |     assert_eq!(suffixes_result.limit_size(), 250);\n     |                                ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_class` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:32\n     |\n1566 |     assert_eq!(suffixes_result.limit_class(), 10);\n     |                                ^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `any_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     assert!(suffixes_result.any_complete());\n     |                             ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `longest_common_suffix` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     assert!(suffixes_result.longest_common_suffix().len() > 0);\n     |                             ^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `min_len` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:32\n     |\n1566 |     assert_eq!(suffixes_result.min_len(), Some(1));\n     |                                ^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:68\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]),\n     |                                                                    ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:81\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:101\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('a'), Literal::Byte(0x62)]), info: Default::default() };\n     |                                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n1565 |     let suffixes_result = suffixes(&expr);\n     |                           ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let suffixes_result = suffixes(&expr, /* &mut Literals */);\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `literals` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:32\n     |\n1566 |     assert_eq!(suffixes_result.literals().len(), 2);\n     |                                ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let expr = Hir {",
                "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                "        info: Default::default(),",
                "    };",
                "    suffixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.literals().len(), 0);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_size(), 250);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_class(), 10);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.is_empty());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.any_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.all_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.literals().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_size(), 250);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_class(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(!result.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `literals` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:23\n     |\n1566 |     assert_eq!(result.literals().len(), 0);\n     |                       ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_size` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:23\n     |\n1566 |     assert_eq!(result.limit_size(), 250);\n     |                       ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_class` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:23\n     |\n1566 |     assert_eq!(result.limit_class(), 10);\n     |                       ^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:20\n     |\n1566 |     assert!(result.is_empty());\n     |                    ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `any_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:21\n     |\n1566 |     assert!(!result.any_complete());\n     |                     ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `all_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:21\n     |\n1566 |     assert!(!result.all_complete());\n     |                     ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:45\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]),\n     |                                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:5\n     |\n1563 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1563 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:85\n     |\n1564 |     let expr = Hir { kind: HirKind::Concat(vec![Literal::Unicode('x'); 300]), info: Default::default() };\n     |                                                                                     ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:18\n     |\n1565 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1565 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `contains_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:21\n     |\n1566 |     assert!(!result.contains_empty());\n     |                     ^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let expr = Hir {",
                "        kind: HirKind::Union(vec![",
                "            Literal::Unicode('y'),",
                "            Literal::Unicode('z'),",
                "            Literal::Unicode('w'),",
                "            Literal::Unicode('v'),",
                "            Literal::Unicode('u'),",
                "            Literal::Unicode('t'),",
                "            Literal::Unicode('s'),",
                "            Literal::Unicode('r'),",
                "            Literal::Unicode('q'),",
                "            Literal::Unicode('p'),",
                "            Literal::Unicode('o'),",
                "            Literal::Unicode('n'),",
                "        ]),",
                "        info: Default::default(),",
                "    };",
                "    suffixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.is_empty(), false);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.literals().len() > 0);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_size(), 250);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_class(), 10);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.any_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.all_complete());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.min_len(), Some(1));"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty() == false);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_suffix(), b\"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.is_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_size(), 250);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.limit_class(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.min_len(), Some(1));",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode('y'),",
                  "            Literal::Unicode('z'),",
                  "            Literal::Unicode('w'),",
                  "            Literal::Unicode('v'),",
                  "            Literal::Unicode('u'),",
                  "            Literal::Unicode('t'),",
                  "            Literal::Unicode('s'),",
                  "            Literal::Unicode('r'),",
                  "            Literal::Unicode('q'),",
                  "            Literal::Unicode('p'),",
                  "            Literal::Unicode('o'),",
                  "            Literal::Unicode('n'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n')]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_suffix(), b\"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:23\n     |\n1579 |     assert_eq!(result.is_empty(), false);\n     |                       ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `literals` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:20\n     |\n1579 |     assert!(result.literals().len() > 0);\n     |                    ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_size` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:23\n     |\n1579 |     assert_eq!(result.limit_size(), 250);\n     |                       ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limit_class` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:23\n     |\n1579 |     assert_eq!(result.limit_class(), 10);\n     |                       ^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `any_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:20\n     |\n1579 |     assert!(result.any_complete());\n     |                    ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `all_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:20\n     |\n1579 |     assert!(result.all_complete());\n     |                    ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `min_len` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:23\n     |\n1579 |     assert_eq!(result.min_len(), Some(1));\n     |                       ^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `contains_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:20\n     |\n1579 |     assert!(result.contains_empty() == false);\n     |                    ^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('y'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1562 |             Literal::Unicode('z'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('w'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |             Literal::Unicode('v'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1565 |             Literal::Unicode('u'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1566 |             Literal::Unicode('t'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |             Literal::Unicode('s'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1568 |             Literal::Unicode('r'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |             Literal::Unicode('q'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |             Literal::Unicode('p'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1571 |             Literal::Unicode('o'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |             Literal::Unicode('n'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:5\n     |\n1576 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:37\n     |\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:103\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:126\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v')...\n     |                                                                                                                              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:149\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u...\n     |                                                                                                                                                     ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:172\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t...\n     |                                                                                                                                                                            ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:195\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s...\n     |                                                                                                                                                                                                   ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:218\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r...\n     |                                                                                                                                                                                                                          ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:241\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q...\n     |                                                                                                                                                                                                                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:264\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p...\n     |                                                                                                                                                                                                                                                                        ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:287\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o...\n     |                                                                                                                                                                                                                                                                                               ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:310\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1577 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode('y'), Literal::Unicode('z'), Literal::Unicode('w'), Literal::Unicode('v'), Literal::Unicode('u'), Literal::Unicode('t'), Literal::Unicode('s'), Literal::Unicode('r'), Literal::Unicode('q'), Literal::Unicode('p'), Literal::Unicode('o'), Literal::Unicode('n...\n     |                                                                                                                                                                                                                                                                                                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1577:332\n     |\n1577 | ...Literal::Unicode('n')]), info: Default::default() };\n     |                                   ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:18\n     |\n1578 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1578 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `longest_common_suffix` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:23\n     |\n1579 |     assert_eq!(result.longest_common_suffix(), b\"\");\n     |                       ^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let expr = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Literal::Unicode('a'),",
                "            Literal::Byte(0x62),",
                "            Literal::Unicode('c'),",
                "        ]),",
                "        info: Default::default(),",
                "    };",
                "    suffixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.is_empty(), false);"
                ],
                [
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.literals().len(), 3);"
                ],
                [
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty() == false);"
                ],
                [
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.any_complete() == true);"
                ],
                [
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_suffix(), b\"c\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Literal::Unicode('a'),",
                  "            Literal::Byte(0x62),",
                  "            Literal::Unicode('c'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.is_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Literal::Unicode('a'),",
                  "            Literal::Byte(0x62),",
                  "            Literal::Unicode('c'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.literals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Literal::Unicode('a'),",
                  "            Literal::Byte(0x62),",
                  "            Literal::Unicode('c'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Literal::Unicode('a'),",
                  "            Literal::Byte(0x62),",
                  "            Literal::Unicode('c'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.any_complete() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Literal::Unicode('a'),",
                  "            Literal::Byte(0x62),",
                  "            Literal::Unicode('c'),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Literal::Unicode('a'),",
                  "    Literal::Byte(0x62),",
                  "    Literal::Unicode('c'),",
                  "    ]),",
                  "    info: Default::default(),",
                  "    };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.longest_common_suffix(), b\"c\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('a'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x62),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('c'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:5\n     |\n1567 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1567 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     Literal::Unicode('a'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1571 |     Literal::Byte(0x62),\n     |              ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |     Literal::Unicode('c'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:11\n     |\n1574 |     info: Default::default(),\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:18\n     |\n1576 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     assert_eq!(result.is_empty(), false);\n     |                       ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('a'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x62),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('c'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:5\n     |\n1567 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1567 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     Literal::Unicode('a'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1571 |     Literal::Byte(0x62),\n     |              ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |     Literal::Unicode('c'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:11\n     |\n1574 |     info: Default::default(),\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:18\n     |\n1576 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `literals` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     assert_eq!(result.literals().len(), 3);\n     |                       ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('a'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x62),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('c'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:5\n     |\n1567 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1567 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     Literal::Unicode('a'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1571 |     Literal::Byte(0x62),\n     |              ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |     Literal::Unicode('c'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:11\n     |\n1574 |     info: Default::default(),\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:18\n     |\n1576 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `contains_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:20\n     |\n1577 |     assert!(result.contains_empty() == false);\n     |                    ^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('a'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x62),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('c'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:5\n     |\n1567 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1567 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     Literal::Unicode('a'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1571 |     Literal::Byte(0x62),\n     |              ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |     Literal::Unicode('c'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:11\n     |\n1574 |     info: Default::default(),\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:18\n     |\n1576 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `any_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:20\n     |\n1577 |     assert!(result.any_complete() == true);\n     |                    ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode('a'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x62),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |             Literal::Unicode('c'),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:5\n     |\n1567 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1567 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     Literal::Unicode('a'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1571 |     Literal::Byte(0x62),\n     |              ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:14\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1572 |     Literal::Unicode('c'),\n     |              ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1574:11\n     |\n1574 |     info: Default::default(),\n     |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1576:18\n     |\n1576 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1576 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `longest_common_suffix` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     assert_eq!(result.longest_common_suffix(), b\"c\");\n     |                       ^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let expr = Hir {",
                "        kind: HirKind::Union(vec![",
                "            Literal::Unicode(''),",
                "            Literal::Byte(0x61),",
                "        ]),",
                "        info: Default::default(),",
                "    };",
                "    suffixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.is_empty(), false);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.literals().len() > 0);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty() == false);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.any_complete() == true);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.all_complete() == true);"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.min_len().is_some());"
                ],
                [
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.longest_common_suffix().len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert_eq!(result.is_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.contains_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.any_complete() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.all_complete() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.min_len().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let expr = Hir {",
                  "        kind: HirKind::Union(vec![",
                  "            Literal::Unicode(''),",
                  "            Literal::Byte(0x61),",
                  "        ]),",
                  "        info: Default::default(),",
                  "    };",
                  "    suffixes(&expr);",
                  "    let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };",
                  "    let result = suffixes(&expr);",
                  "    assert!(result.longest_common_suffix().len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:23\n     |\n1569 |     assert_eq!(result.is_empty(), false);\n     |                       ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `literals` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:20\n     |\n1569 |     assert!(result.literals().len() > 0);\n     |                    ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `contains_empty` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:20\n     |\n1569 |     assert!(result.contains_empty() == false);\n     |                    ^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `any_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:20\n     |\n1569 |     assert!(result.any_complete() == true);\n     |                    ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `all_complete` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:20\n     |\n1569 |     assert!(result.all_complete() == true);\n     |                    ^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `min_len` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:20\n     |\n1569 |     assert!(result.min_len().is_some());\n     |                    ^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::Union(vec![\n     |                        ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1561:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1561 |             Literal::Unicode(''),\n     |                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:22\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1562 |             Literal::Byte(0x61),\n     |                      ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:15\n     |\n1564 |         info: Default::default(),\n     |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:5\n     |\n1566 |     suffixes(&expr);\n     |     ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1566 |     suffixes(&expr, /* &mut Literals */);\n     |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Union` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:37\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                     ^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `Union` not found for this enum\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:57\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:100\n     |\n1567 |     let expr = Hir { kind: HirKind::Union(vec![Literal::Unicode(''), Literal::Byte(0x61)]), info: Default::default() };\n     |                                                                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n     |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n    -->  regex-syntax/src/hir/mod.rs:1296:1\n     |\n1296 + #[derive(Default)]\n1297 | struct HirInfo {\n     |\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1568:18\n     |\n1568 |     let result = suffixes(&expr);\n     |                  ^^^^^^^^------- argument #2 of type `&mut Literals` is missing\n     |\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:682:4\n     |\n682  | fn suffixes(expr: &Hir, lits: &mut Literals) {\n     |    ^^^^^^^^ ----------  -------------------\nhelp: provide the argument\n     |\n1568 |     let result = suffixes(&expr, /* &mut Literals */);\n     |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `longest_common_suffix` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:20\n     |\n1569 |     assert!(result.longest_common_suffix().len() > 0);\n     |                    ^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}