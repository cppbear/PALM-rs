[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let ast = Ast::Empty(Span::new(0, 0));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
            "    let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
            "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
            "    let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
          "    let ast = Ast::Flags(flags);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    assert!(writer.wtr == \"(?{})\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    assert!(writer.wtr == \"(?{})\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
          "    let ast = Ast::Literal(literal);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"a\");"
          ],
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"(?\");"
          ],
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\d\");"
          ],
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\pb\");"
          ],
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"(?\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\pb\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let ast = Ast::Dot(Span::new(0, 1));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_flags).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_literal).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_assertion).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_class_perl).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_class_unicode).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_class_bracketed).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_repetition).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast_group), Ok(()));"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_alternation).is_ok());"
          ],
          [
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_concat).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_flags).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_literal).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_assertion).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_class_perl).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_class_unicode).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_class_bracketed).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_repetition).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast_group), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_alternation).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    writer.visit_post(&ast);",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert!(writer.visit_post(&ast_concat).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
          "    let ast = Ast::Assertion(assertion);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
            "    let ast = Ast::Concat(Concat { span: Span::new(0, 1), elements: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'd' })] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Empty(Span::new(0, 1));",
            "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
            "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
            "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
            "    let ast = Ast::Concat(Concat { span: Span::new(0, 1), elements: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'd' })] });",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
          "    let ast = Ast::Class(Class::Unicode(class_unicode));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    assert_eq!(writer.wtr, r\"\\p{a}\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"]\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"(?)\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\d\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    assert_eq!(writer.wtr, r\"\\p{a}\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"(?)\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\d\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
          "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    assert_eq!(writer.wtr, \"]\");"
          ],
          [
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"(? )\");"
          ],
          [
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\d\");"
          ],
          [
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"^\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    assert_eq!(writer.wtr, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"(? )\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(writer.wtr, \"^\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
          "    let ast = Ast::Class(Class::Perl(class_perl));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, r\"\\d\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast_flags = Ast::Flags(flags);",
            "    writer.visit_post(&ast_flags).unwrap();",
            "    assert_eq!(writer.wtr, \"(? )\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
            "    let ast_flags = Ast::Flags(flags);",
            "    writer.visit_post(&ast_flags).unwrap();",
            "    assert_eq!(writer.wtr, \"(? )\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
          "    let ast = Ast::Repetition(repetition);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_literal), writer.fmt_literal(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_assertion), writer.fmt_assertion(&Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_class_perl), writer.fmt_class_perl(&ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_class_unicode), writer.fmt_class_unicode(&ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_class_bracketed), writer.fmt_class_bracketed_post(&ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_repetition), writer.fmt_repetition(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_group), writer.fmt_group_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) }));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_repetition), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_literal), writer.fmt_literal(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_assertion), writer.fmt_assertion(&Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_class_perl), writer.fmt_class_perl(&ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_class_unicode), writer.fmt_class_unicode(&ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_class_bracketed), writer.fmt_class_bracketed_post(&ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_repetition), writer.fmt_repetition(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_group), writer.fmt_group_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) }));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast_empty = Ast::Empty(Span::new(0, 0));",
            "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
            "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast_dot = Ast::Dot(Span::new(0, 1));",
            "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
            "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
            "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
            "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
            "    assert_eq!(writer.visit_post(&ast_repetition), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
          "    let ast = Ast::Group(group);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Group(group);",
            "    let result = writer.visit_post(&ast);",
            "    assert!(result.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
            "    let ast = Ast::Group(group);",
            "    let result = writer.visit_post(&ast);",
            "    assert!(result.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let ast = Ast::Alternation(vec![]);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"(?)\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"a\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \".\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"^\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, r\"\\d\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, r\"\\pA\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"]\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"*\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \")\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"(?)\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \".\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"^\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, r\"\\pA\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"*\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \")\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Dot(Span::default());",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Alternation(vec![]);",
            "    writer.visit_post(&ast).unwrap();",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(writer.wtr, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let ast = Ast::Concat(vec![]);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&SetFlags::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&Literal::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&Assertion::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&ClassPerl::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&ClassUnicode::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&ClassBracketed::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&Repetition::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&Group::default()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Alternation(vec![]);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Alternation(vec![]);",
            "    let ast = Ast::Concat(vec![]);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&SetFlags::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&Literal::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&Assertion::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&ClassPerl::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&ClassUnicode::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&ClassBracketed::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&Repetition::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&Group::default()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Alternation(vec![]);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Concat(vec![]);",
            "    writer.visit_post(&ast);",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = Ast::Empty(Span::default());",
            "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
            "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
            "    let ast = Ast::Dot(Span::default());",
            "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
            "    let ast = Ast::Alternation(vec![]);",
            "    let ast = Ast::Concat(vec![]);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]