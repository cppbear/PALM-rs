[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(), // Assuming `Span` has a default implementation",
          "        kind: LiteralKind::Special(SpecialLiteralKind::LineFeed),",
          "        c: '\\n',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    output.push_str(r\"\\n\");",
            "    assert_eq!(output, r\"\\n\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(), // Assuming `Span` has a default implementation",
            "        kind: LiteralKind::Special(SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    output.push_str(r\"\\n\");",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
          "        c: '\\r',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x41\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '你' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{4F60}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '你' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠜎' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{2000E}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x41\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '你' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{4F60}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '你' };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠜎' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{2000E}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
          "        c: '\\x07',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{:02X}\", 'A' as u32);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{:04X}\", '𐍈' as u32);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{:08X}\", '𠀀' as u32);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::X), c: 'B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{{{:X}}}\", 'B' as u32);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::X), c: 'B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort), c: '𐌰' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{{{:X}}}\", '𐌰' as u32);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::X), c: 'B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort), c: '𐌰' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong), c: '𠜎' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{{{:X}}}\", '𠜎' as u32);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{:02X}\", 'A' as u32);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{:04X}\", '𐍈' as u32);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{:08X}\", '𠀀' as u32);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::X), c: 'B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{{{:X}}}\", 'B' as u32);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::X), c: 'B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort), c: '𐌰' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{{{:X}}}\", '𐌰' as u32);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::Bell),",
            "        c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Bell), c: '\\x07' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::FormFeed), c: '\\x0C' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Tab), c: '\\t' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::Space), c: ' ' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: '𐍈' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: '𠀀' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::X), c: 'B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort), c: '𐌰' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong), c: '𠜎' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{{{:X}}}\", '𠜎' as u32);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
          "        c: '\\x0B',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x41\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{0041}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000041}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: '!' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\!\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x41\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{0041}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000041}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab),",
            "        c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::CarriageReturn), c: '\\r' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(SpecialLiteralKind::LineFeed), c: '\\n' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: '!' };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\!\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "        c: 'a',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{0061}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000061}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{61}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{0061}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000061}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{61}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'a',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "        c: 'ß',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{00DF}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{000000DF}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{00DF}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{00DF}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{000000DF}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = Literal {",
            "    span: Span::default(),",
            "    kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: 'ß',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{00DF}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let ast = Literal {",
          "        span: Span::default(),",
          "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "        c: 'A',",
          "    };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x41\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{0041}\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000041}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x41\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\u{0041}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal {",
            "        span: Span::default(),",
            "        kind: LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    output.clear();",
            "    let ast = Literal { span: Span::default(), kind: LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A', };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000041}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]