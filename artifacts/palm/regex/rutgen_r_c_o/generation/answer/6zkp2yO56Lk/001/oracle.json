[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exprs: Vec<Hir> = Vec::new();",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind(), &HirKind::Empty);"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_anchored_start());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_anchored_end());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(result.is_match_empty());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Literal(lit));"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Alternation(exprs));"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind(), &HirKind::Empty);",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    assert!(result.is_match_empty());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Literal(lit));",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Alternation(exprs));",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    alternation(exprs);",
            "    let exprs: Vec<Hir> = Vec::new();",
            "    let result = alternation(exprs);",
            "    let lit = Literal::new('a');",
            "    let exprs: Vec<Hir> = vec![Hir::literal(lit)];",
            "    let result = alternation(exprs.clone());",
            "    let exprs: Vec<Hir> = vec![Hir::empty(), Hir::empty()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Hir::literal(Literal::from_char('a'));",
          "    let exprs = vec![literal];",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind(), &HirKind::Literal(Literal::from_char('a')));"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_start());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_end());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_match_empty());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.info.bools, 0b11111101);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind(), &HirKind::Literal(Literal::from_char('a')));",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_match_empty());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![literal];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.info.bools, 0b11111101);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal_a = Hir::literal(Literal::from_char('a'));",
          "    let literal_b = Hir::literal(Literal::from_char('b'));",
          "    let literal_c = Hir::literal(Literal::from_char('c'));",
          "    let exprs = vec![literal_a, literal_b, literal_c];",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind, HirKind::Alternation(vec![literal_a, literal_b, literal_c]));"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_always_utf8());"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_all_assertions());"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_start());"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_end());"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_start());"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_end());"
          ],
          [
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_match_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind, HirKind::Alternation(vec![literal_a, literal_b, literal_c]));",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a, literal_b, literal_c];",
            "    alternation(exprs);",
            "    let literal_a = Hir::literal(Literal::from_char('a'));",
            "    let literal_b = Hir::literal(Literal::from_char('b'));",
            "    let literal_c = Hir::literal(Literal::from_char('c'));",
            "    let exprs = vec![literal_a.clone(), literal_b.clone(), literal_c.clone()];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_match_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_hir = Hir::empty();",
          "    let literal = Hir::literal(Literal::from_char('a'));",
          "    let exprs = vec![empty_hir, literal];",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind(), &HirKind::Alternation(vec![Hir::empty(), literal]));"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_start());"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_end());"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_match_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind(), &HirKind::Alternation(vec![Hir::empty(), literal]));",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    alternation(exprs);",
            "    let empty_hir = Hir::empty();",
            "    let literal = Hir::literal(Literal::from_char('a'));",
            "    let exprs = vec![empty_hir, literal];",
            "    let result = alternation(exprs);",
            "    assert!(!result.is_match_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group = Hir::group(Group::new(vec![]));",
          "    let exprs = vec![group, group];",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Alternation(exprs));"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Alternation(exprs));",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group, group];",
            "    alternation(exprs);",
            "    let group = Hir::group(Group::new(vec![]));",
            "    let exprs = vec![group.clone(), group.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
          "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
          "    let exprs = vec![class_a, class_b];",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Alternation(exprs));"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());"
          ],
          [
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert_eq!(result.kind(), &HirKind::Alternation(exprs));",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(result.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a, class_b];",
            "    alternation(exprs);",
            "    let class_a = Hir::class(Class::new(vec!['a', 'b']));",
            "    let class_b = Hir::class(Class::new(vec!['c', 'd']));",
            "    let exprs = vec![class_a.clone(), class_b.clone()];",
            "    let result = alternation(exprs.clone());",
            "    assert!(!result.is_match_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Hir::literal(Literal::from_char('x'));",
          "    let group = Hir::group(Group::new(vec![literal.clone()]));",
          "    let class = Hir::class(Class::new(vec!['y', 'z']));",
          "    let exprs = vec![literal, group, class];",
          "    alternation(exprs);",
          "}"
        ],
        "oracles": [
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind, HirKind::Alternation(exprs));"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_always_utf8());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_all_assertions());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_start());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_end());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_start());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_end());"
          ],
          [
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_match_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert_eq!(result.kind, HirKind::Alternation(exprs));",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_always_utf8());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_all_assertions());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(result.info.is_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_start());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_any_anchored_end());",
            "}"
          ],
          [
            "{",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    alternation(exprs);",
            "    let literal = Hir::literal(Literal::from_char('x'));",
            "    let group = Hir::group(Group::new(vec![literal.clone()]));",
            "    let class = Hir::class(Class::new(vec!['y', 'z']));",
            "    let exprs = vec![literal, group, class];",
            "    let result = alternation(exprs);",
            "    assert!(!result.info.is_match_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]