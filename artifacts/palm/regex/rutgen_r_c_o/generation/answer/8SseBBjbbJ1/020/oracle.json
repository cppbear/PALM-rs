[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = r\"\\x{FF}\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: input,",
          "    };",
          "    parser.parse_hex();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(parser.char() == 'x');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(parser.bump_and_bump_space());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(parser.char() == '{');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort), Ok(_)));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong), Ok(_)));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_brace(ast::HexLiteralKind::X), Ok(_)));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_digits(ast::HexLiteralKind::X), Err(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(parser.char() == 'x');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(parser.bump_and_bump_space());",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(parser.char() == '{');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort), Ok(_)));",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong), Ok(_)));",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_brace(ast::HexLiteralKind::X), Ok(_)));",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\x{FF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\x{FF}\" };",
            "    assert!(matches!(parser.parse_hex_digits(ast::HexLiteralKind::X), Err(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = r\"\\u{FFFF}\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: input,",
          "    };",
          "    parser.parse_hex();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.char() == 'u');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.bump_and_bump_space());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.char() == '{');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong).is_ok());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = r\"\\u{FFFF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.char() == 'u');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\u{FFFF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.bump_and_bump_space());",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\u{FFFF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.char() == '{');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\u{FFFF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong).is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\u{FFFF}\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\u{FFFF}\" };",
            "    assert!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = r\"\\xFF\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: input,",
          "    };",
          "    parser.parse_hex();",
          "}"
        ],
        "oracles": [
          [
            "    let input = r\"\\xFF\";",
            "    assert!(parser.char() == 'x' || parser.char() == 'u' || parser.char() == 'U');"
          ],
          [
            "    let input = r\"\\xFF\";",
            "    assert!(self.bump_and_bump_space() == true);"
          ],
          [
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == '{' == false);"
          ],
          [
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == 'x' == true);"
          ],
          [
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == 'u' == false);"
          ],
          [
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == 'U' == false);"
          ],
          [
            "    let input = r\"\\xFF\";",
            "    assert!(self.char().is_ascii_hexdigit() == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(parser.char() == 'x' || parser.char() == 'u' || parser.char() == 'U');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(self.bump_and_bump_space() == true);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == '{' == false);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == 'x' == true);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == 'u' == false);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(self.char() == 'U' == false);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\xFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\xFF\";",
            "    assert!(self.char().is_ascii_hexdigit() == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = r\"\\uFF\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: input,",
          "    };",
          "    parser.parse_hex();",
          "}"
        ],
        "oracles": [
          [
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.char() == 'u' || parser.char() == 'x');"
          ],
          [
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.bump_and_bump_space() == true);"
          ],
          [
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.char() == '{' == false);"
          ],
          [
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.char() == 'u' || parser.char() == 'x');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.bump_and_bump_space() == true);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.char() == '{' == false);",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let input = r\"\\uFF\";",
            "    let parser = ParserI { parser: Parser::new(), pattern: input };",
            "    assert!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = r\"\\UFFFF\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: input,",
          "    };",
          "    parser.parse_hex();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    assert_eq!(parser.char(), 'U');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    assert!(parser.bump_and_bump_space());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    assert_eq!(parser.char(), '{');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    let literal = parser.parse_hex().unwrap();",
            "    assert_eq!(literal.c, '\\u{FFFF}');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    let literal = parser.parse_hex().unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    let literal = parser.parse_hex().unwrap();",
            "    assert!(parser.char() == '}');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = r\"\\UFFFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    assert_eq!(parser.char(), 'U');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\UFFFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    assert!(parser.bump_and_bump_space());",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\UFFFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    assert_eq!(parser.char(), '{');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\UFFFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    let literal = parser.parse_hex().unwrap();",
            "    assert_eq!(literal.c, '\\u{FFFF}');",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\UFFFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    let literal = parser.parse_hex().unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong));",
            "}"
          ],
          [
            "{",
            "    let input = r\"\\UFFFF\";",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: input,",
            "    };",
            "    parser.parse_hex();",
            "    let parser = ParserI { parser: Parser::new(), pattern: r\"\\UFFFF\" };",
            "    let literal = parser.parse_hex().unwrap();",
            "    assert!(parser.char() == '}');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]