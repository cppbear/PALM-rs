[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Debug, Eq, PartialEq, Default)]",
      "struct Bound {",
      "    value: usize,",
      "}",
      "impl Bound {",
      "    fn increment(&self) -> Self {",
      "        Bound { value: self.value + 1 }",
      "    }",
      "    fn decrement(&self) -> Self {",
      "        Bound { value: self.value - 1 }",
      "    }",
      "}",
      "impl PartialOrd for Bound {",
      "    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "        self.value.partial_cmp(&other.value)",
      "    }",
      "}",
      "impl Ord for Bound {",
      "    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
      "        self.value.cmp(&other.value)",
      "    }",
      "}",
      "impl Bound {",
      "    fn new(value: usize) -> Self {",
      "        Bound { value }",
      "    }",
      "}",
      "#[derive(Clone, Debug, Eq, PartialEq, Default)]",
      "struct IntervalImpl {",
      "    lower: Bound,",
      "    upper: Bound,",
      "}",
      "impl Interval for IntervalImpl {",
      "    type Bound = Bound;",
      "",
      "    fn lower(&self) -> Self::Bound {",
      "        self.lower.clone()",
      "    }",
      "",
      "    fn upper(&self) -> Self::Bound {",
      "        self.upper.clone()",
      "    }",
      "",
      "    fn set_lower(&mut self, bound: Self::Bound) {",
      "        self.lower = bound;",
      "    }",
      "",
      "    fn set_upper(&mut self, bound: Self::Bound) {",
      "        self.upper = bound;",
      "    }",
      "",
      "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
      "",
      "    fn is_contiguous(&self, other: &Self) -> bool {",
      "        self.upper >= other.lower",
      "    }",
      "",
      "    fn is_intersection_empty(&self, other: &Self) -> bool {",
      "        self.upper < other.lower || other.upper < self.lower",
      "    }",
      "",
      "    fn is_subset(&self, other: &Self) -> bool {",
      "        self.lower >= other.lower && self.upper <= other.upper",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set_a = IntervalSet::new(vec![",
          "        IntervalImpl::create(Bound::new(1), Bound::new(5)),",
          "        IntervalImpl::create(Bound::new(6), Bound::new(10)),",
          "    ]);",
          "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
          "",
          "    set_a.intersect(&set_b);",
          "}"
        ],
        "oracles": [
          [
            "    let set_a = IntervalSet::new(vec![",
            "    IntervalImpl::create(Bound::new(1), Bound::new(5)),",
            "    IntervalImpl::create(Bound::new(6), Bound::new(10)),",
            "    ]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    set_a.intersect(&set_b);",
            "    assert_eq!(set_a.intervals().len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut set_a = IntervalSet::new(vec![",
            "        IntervalImpl::create(Bound::new(1), Bound::new(5)),",
            "        IntervalImpl::create(Bound::new(6), Bound::new(10)),",
            "    ]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "",
            "    set_a.intersect(&set_b);",
            "    let set_a = IntervalSet::new(vec![",
            "    IntervalImpl::create(Bound::new(1), Bound::new(5)),",
            "    IntervalImpl::create(Bound::new(6), Bound::new(10)),",
            "    ]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    set_a.intersect(&set_b);",
            "    assert_eq!(set_a.intervals().len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set_a = IntervalSet::new(vec![",
          "        IntervalImpl::create(Bound::new(0), Bound::new(3)),",
          "        IntervalImpl::create(Bound::new(5), Bound::new(7)),",
          "    ]);",
          "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
          "",
          "    set_a.intersect(&set_b);",
          "}"
        ],
        "oracles": [
          [
            "    let set_a = IntervalSet::new(vec![",
            "    IntervalImpl::create(Bound::new(0), Bound::new(3)),",
            "    IntervalImpl::create(Bound::new(5), Bound::new(7)),",
            "    ]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    set_a.intersect(&set_b);",
            "    assert!(set_a.intervals().is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut set_a = IntervalSet::new(vec![",
            "        IntervalImpl::create(Bound::new(0), Bound::new(3)),",
            "        IntervalImpl::create(Bound::new(5), Bound::new(7)),",
            "    ]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "",
            "    set_a.intersect(&set_b);",
            "    let set_a = IntervalSet::new(vec![",
            "    IntervalImpl::create(Bound::new(0), Bound::new(3)),",
            "    IntervalImpl::create(Bound::new(5), Bound::new(7)),",
            "    ]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    set_a.intersect(&set_b);",
            "    assert!(set_a.intervals().is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
          "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
          "",
          "    set_a.intersect(&set_b);",
          "}"
        ],
        "oracles": [
          [
            "    let set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    assert!(set_a.ranges.len() == 1);"
          ],
          [
            "    let set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    assert!(set_b.ranges.is_empty());"
          ],
          [
            "    let set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    set_a.intersect(&set_b);",
            "    assert!(set_a.ranges.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "",
            "    set_a.intersect(&set_b);",
            "    let set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    assert!(set_a.ranges.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let mut set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "",
            "    set_a.intersect(&set_b);",
            "    let set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    assert!(set_b.ranges.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "",
            "    set_a.intersect(&set_b);",
            "    let set_a = IntervalSet::new(vec![IntervalImpl::create(Bound::new(1), Bound::new(3))]);",
            "    let set_b = IntervalSet::<IntervalImpl>::new(vec![]);",
            "    set_a.intersect(&set_b);",
            "    assert!(set_a.ranges.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]