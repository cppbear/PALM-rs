[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyVisitor;",
          "    impl Visitor for DummyVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "    }",
          "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
          "    let item = ast::ClassSetItem::Union(frame);",
          "    let induct = ClassInduct::Item(&item);",
          "    let visitor = HeapVisitor::new();",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracles": [
          [
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_none());"
          ],
          [
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_some());"
          ],
          [
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(matches!(result, Some(ClassFrame::Union { head, tail }) if tail.is_empty()));"
          ],
          [
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_some());"
          ],
          [
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let y = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(y) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(matches!(result, Some(ClassFrame::Binary { op }) if op == &y));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_none());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(matches!(result, Some(ClassFrame::Union { head, tail }) if tail.is_empty()));",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
            "    let item = ast::ClassSetItem::Union(frame);",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    let y = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(y) }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(matches!(result, Some(ClassFrame::Binary { op }) if op == &y));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyVisitor;",
          "    impl Visitor for DummyVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "    }",
          "    let item = ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
          "    };",
          "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
          "    let induct = ClassInduct::Item(&class_set_item);",
          "    let visitor = HeapVisitor::new();",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracles": [
          [
            "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_some());"
          ],
          [
            "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    if let Some(Frame::Union { head, tail }) = result {",
            "    assert_eq!(head, &ClassSetItem::Literal(Literal::from('a')));"
          ],
          [
            "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    if let Some(Frame::Union { head, tail }) = result {",
            "    assert!(tail.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item = ClassBracketed {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item = ClassBracketed {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    if let Some(Frame::Union { head, tail }) = result {",
            "    assert_eq!(head, &ClassSetItem::Literal(Literal::from('a')));",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item = ClassBracketed {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    let result = visitor.induct_class(&induct);",
            "    if let Some(Frame::Union { head, tail }) = result {",
            "    assert!(tail.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyVisitor;",
          "    impl Visitor for DummyVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "    }",
          "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
          "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
          "    let op = ClassSetBinaryOp {",
          "        span: Span::default(),",
          "        kind: ClassSetBinaryOpKind::Union,",
          "        lhs,",
          "        rhs,",
          "    };",
          "    let bracketed = ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(op),",
          "    };",
          "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
          "    let induct = ClassInduct::Item(&class_set_item);",
          "    let visitor = HeapVisitor::new();",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracles": [
          [
            "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
            "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
            "    let op = ClassSetBinaryOp {",
            "    span: Span::default(),",
            "    kind: ClassSetBinaryOpKind::Union,",
            "    lhs,",
            "    rhs,",
            "    };",
            "    let bracketed = ClassBracketed {",
            "    span: Span::default(),",
            "    negated: false,",
            "    kind: ClassSet::BinaryOp(op),",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union {"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
            "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
            "    let op = ClassSetBinaryOp {",
            "        span: Span::default(),",
            "        kind: ClassSetBinaryOpKind::Union,",
            "        lhs,",
            "        rhs,",
            "    };",
            "    let bracketed = ClassBracketed {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassSet::BinaryOp(op),",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
            "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
            "    let op = ClassSetBinaryOp {",
            "    span: Span::default(),",
            "    kind: ClassSetBinaryOpKind::Union,",
            "    lhs,",
            "    rhs,",
            "    };",
            "    let bracketed = ClassBracketed {",
            "    span: Span::default(),",
            "    negated: false,",
            "    kind: ClassSet::BinaryOp(op),",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyVisitor;",
          "    impl Visitor for DummyVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "    }",
          "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
          "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
          "    let union = ClassSetUnion {",
          "        span: Span::default(),",
          "        items: vec![item1, item2],",
          "    };",
          "    let class_set_item = ast::ClassSetItem::Union(union);",
          "    let induct = ClassInduct::Item(&class_set_item);",
          "    let visitor = HeapVisitor::new();",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracles": [
          [
            "    visitor.induct_class(&induct);",
            "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union { head: &item1, tail: &[item2] }));"
          ],
          [
            "    visitor.induct_class(&induct);",
            "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: Vec::new() }))).is_none());"
          ],
          [
            "    visitor.induct_class(&induct);",
            "    assert!(visitor.induct_class(&ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) })).is_some());"
          ],
          [
            "    visitor.induct_class(&induct);",
            "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(Box::new(item1)) }))).is_some());"
          ],
          [
            "    visitor.induct_class(&induct);",
            "    assert_eq!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) }) }))), Some(ClassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) } }));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
            "    let union = ClassSetUnion {",
            "        span: Span::default(),",
            "        items: vec![item1, item2],",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    visitor.induct_class(&induct);",
            "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union { head: &item1, tail: &[item2] }));",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
            "    let union = ClassSetUnion {",
            "        span: Span::default(),",
            "        items: vec![item1, item2],",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    visitor.induct_class(&induct);",
            "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: Vec::new() }))).is_none());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
            "    let union = ClassSetUnion {",
            "        span: Span::default(),",
            "        items: vec![item1, item2],",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    visitor.induct_class(&induct);",
            "    assert!(visitor.induct_class(&ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) })).is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
            "    let union = ClassSetUnion {",
            "        span: Span::default(),",
            "        items: vec![item1, item2],",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    visitor.induct_class(&induct);",
            "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(Box::new(item1)) }))).is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyVisitor;",
            "    impl Visitor for DummyVisitor {",
            "        type Output = ();",
            "        type Err = ();",
            "    }",
            "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
            "    let union = ClassSetUnion {",
            "        span: Span::default(),",
            "        items: vec![item1, item2],",
            "    };",
            "    let class_set_item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&class_set_item);",
            "    let visitor = HeapVisitor::new();",
            "    visitor.induct_class(&induct);",
            "    visitor.induct_class(&induct);",
            "    assert_eq!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) }) }))), Some(ClassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) } }));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]