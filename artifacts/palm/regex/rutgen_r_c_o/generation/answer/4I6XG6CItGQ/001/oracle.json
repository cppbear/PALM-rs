[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = vec![",
          "        vec![b'a', b'b', b'c'],",
          "        vec![b'd', b'e', b'f'],",
          "        vec![b'g', b'h', b'i'],",
          "    ];",
          "    ",
          "    let ted = TeddyAVX2 {",
          "        vb: AVX2VectorBuilder::new(),",
          "        pats: patterns.clone(),",
          "        ac: FullAcAutomaton::new(patterns.clone()),",
          "        buckets: vec![vec![0], vec![1], vec![2]],",
          "        masks: Masks::default(),",
          "    };",
          "",
          "    let searcher = LiteralSearcher {",
          "        complete: false,",
          "        lcp: FreqyPacked::new(vec![b'a', b'b']),",
          "        lcs: FreqyPacked::new(vec![b'c', b'd']),",
          "        matcher: Matcher::TeddyAVX2(ted.clone()),",
          "    };",
          "",
          "    let _ = searcher.iter();",
          "}"
        ],
        "oracles": [],
        "codes": [],
        "can_compile": [],
        "repaired": []
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
          "    ",
          "    let ted = TeddyAVX2 {",
          "        vb: AVX2VectorBuilder::new(),",
          "        pats: patterns.clone(),",
          "        ac: FullAcAutomaton::new(patterns.clone()),",
          "        buckets: vec![vec![0; 256]; 8],",
          "        masks: Masks::default(),",
          "    };",
          "",
          "    let searcher = LiteralSearcher {",
          "        complete: true,",
          "        lcp: FreqyPacked::new(vec![b'a']),",
          "        lcs: FreqyPacked::new(vec![b'b']),",
          "        matcher: Matcher::TeddyAVX2(ted.clone()),",
          "    };",
          "",
          "    let _ = searcher.iter();",
          "}"
        ],
        "oracles": [
          [
            "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
            "    let ted = TeddyAVX2 { vb: AVX2VectorBuilder::new(), pats: patterns.clone(), ac: FullAcAutomaton::new(patterns.clone()), buckets: vec![vec![0; 256]; 8], masks: Masks::default(), };",
            "    let searcher = LiteralSearcher { complete: true, lcp: FreqyPacked::new(vec![b'a']), lcs: FreqyPacked::new(vec![b'b']), matcher: Matcher::TeddyAVX2(ted.clone()), };",
            "    let result = searcher.iter();",
            "    assert!(matches!(result, LiteralIter::TeddyAVX2(_)));"
          ],
          [
            "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
            "    let ted = TeddyAVX2 { vb: AVX2VectorBuilder::new(), pats: patterns.clone(), ac: FullAcAutomaton::new(patterns.clone()), buckets: vec![vec![0; 256]; 8], masks: Masks::default(), };",
            "    let searcher = LiteralSearcher { complete: true, lcp: FreqyPacked::new(vec![b'a']), lcs: FreqyPacked::new(vec![b'b']), matcher: Matcher::TeddyAVX2(ted.clone()), };",
            "    let result = searcher.iter();",
            "    assert_eq!(if let LiteralIter::TeddyAVX2(patterns) = result { patterns.len() } else { 0 }, 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
            "    ",
            "    let ted = TeddyAVX2 {",
            "        vb: AVX2VectorBuilder::new(),",
            "        pats: patterns.clone(),",
            "        ac: FullAcAutomaton::new(patterns.clone()),",
            "        buckets: vec![vec![0; 256]; 8],",
            "        masks: Masks::default(),",
            "    };",
            "",
            "    let searcher = LiteralSearcher {",
            "        complete: true,",
            "        lcp: FreqyPacked::new(vec![b'a']),",
            "        lcs: FreqyPacked::new(vec![b'b']),",
            "        matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "",
            "    let _ = searcher.iter();",
            "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
            "    let ted = TeddyAVX2 { vb: AVX2VectorBuilder::new(), pats: patterns.clone(), ac: FullAcAutomaton::new(patterns.clone()), buckets: vec![vec![0; 256]; 8], masks: Masks::default(), };",
            "    let searcher = LiteralSearcher { complete: true, lcp: FreqyPacked::new(vec![b'a']), lcs: FreqyPacked::new(vec![b'b']), matcher: Matcher::TeddyAVX2(ted.clone()), };",
            "    let result = searcher.iter();",
            "    assert!(matches!(result, LiteralIter::TeddyAVX2(_)));",
            "}"
          ],
          [
            "{",
            "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
            "    ",
            "    let ted = TeddyAVX2 {",
            "        vb: AVX2VectorBuilder::new(),",
            "        pats: patterns.clone(),",
            "        ac: FullAcAutomaton::new(patterns.clone()),",
            "        buckets: vec![vec![0; 256]; 8],",
            "        masks: Masks::default(),",
            "    };",
            "",
            "    let searcher = LiteralSearcher {",
            "        complete: true,",
            "        lcp: FreqyPacked::new(vec![b'a']),",
            "        lcs: FreqyPacked::new(vec![b'b']),",
            "        matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "",
            "    let _ = searcher.iter();",
            "    let patterns = (0..256).map(|i| vec![i as u8]).collect::<Vec<_>>();",
            "    let ted = TeddyAVX2 { vb: AVX2VectorBuilder::new(), pats: patterns.clone(), ac: FullAcAutomaton::new(patterns.clone()), buckets: vec![vec![0; 256]; 8], masks: Masks::default(), };",
            "    let searcher = LiteralSearcher { complete: true, lcp: FreqyPacked::new(vec![b'a']), lcs: FreqyPacked::new(vec![b'b']), matcher: Matcher::TeddyAVX2(ted.clone()), };",
            "    let result = searcher.iter();",
            "    assert_eq!(if let LiteralIter::TeddyAVX2(patterns) = result { patterns.len() } else { 0 }, 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
          "    ",
          "    let ted = TeddyAVX2 {",
          "        vb: AVX2VectorBuilder::new(),",
          "        pats: patterns.clone(),",
          "        ac: FullAcAutomaton::new(patterns.clone()),",
          "        buckets: vec![vec![0], vec![1], vec![2]],",
          "        masks: Masks::default(),",
          "    };",
          "",
          "    let searcher = LiteralSearcher {",
          "        complete: false,",
          "        lcp: FreqyPacked::new(vec![b'x']),",
          "        lcs: FreqyPacked::new(vec![b'z']),",
          "        matcher: Matcher::TeddyAVX2(ted.clone()),",
          "    };",
          "",
          "    let _ = searcher.iter();",
          "}"
        ],
        "oracles": [
          [
            "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
            "    let ted = TeddyAVX2 {",
            "    vb: AVX2VectorBuilder::new(),",
            "    pats: patterns.clone(),",
            "    ac: FullAcAutomaton::new(patterns.clone()),",
            "    buckets: vec![vec![0], vec![1], vec![2]],",
            "    masks: Masks::default(),",
            "    };",
            "    let searcher = LiteralSearcher {",
            "    complete: false,",
            "    lcp: FreqyPacked::new(vec![b'x']),",
            "    lcs: FreqyPacked::new(vec![b'z']),",
            "    matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "    let result = searcher.iter();",
            "    assert!(matches!(result, LiteralIter::TeddyAVX2(_)));"
          ],
          [
            "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
            "    let ted = TeddyAVX2 {",
            "    vb: AVX2VectorBuilder::new(),",
            "    pats: patterns.clone(),",
            "    ac: FullAcAutomaton::new(patterns.clone()),",
            "    buckets: vec![vec![0], vec![1], vec![2]],",
            "    masks: Masks::default(),",
            "    };",
            "    let searcher = LiteralSearcher {",
            "    complete: false,",
            "    lcp: FreqyPacked::new(vec![b'x']),",
            "    lcs: FreqyPacked::new(vec![b'z']),",
            "    matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "    let result = searcher.iter();",
            "    assert_eq!(if let LiteralIter::TeddyAVX2(pats) = result { pats } else { &[] }, &patterns);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
            "    ",
            "    let ted = TeddyAVX2 {",
            "        vb: AVX2VectorBuilder::new(),",
            "        pats: patterns.clone(),",
            "        ac: FullAcAutomaton::new(patterns.clone()),",
            "        buckets: vec![vec![0], vec![1], vec![2]],",
            "        masks: Masks::default(),",
            "    };",
            "",
            "    let searcher = LiteralSearcher {",
            "        complete: false,",
            "        lcp: FreqyPacked::new(vec![b'x']),",
            "        lcs: FreqyPacked::new(vec![b'z']),",
            "        matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "",
            "    let _ = searcher.iter();",
            "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
            "    let ted = TeddyAVX2 {",
            "    vb: AVX2VectorBuilder::new(),",
            "    pats: patterns.clone(),",
            "    ac: FullAcAutomaton::new(patterns.clone()),",
            "    buckets: vec![vec![0], vec![1], vec![2]],",
            "    masks: Masks::default(),",
            "    };",
            "    let searcher = LiteralSearcher {",
            "    complete: false,",
            "    lcp: FreqyPacked::new(vec![b'x']),",
            "    lcs: FreqyPacked::new(vec![b'z']),",
            "    matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "    let result = searcher.iter();",
            "    assert!(matches!(result, LiteralIter::TeddyAVX2(_)));",
            "}"
          ],
          [
            "{",
            "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
            "    ",
            "    let ted = TeddyAVX2 {",
            "        vb: AVX2VectorBuilder::new(),",
            "        pats: patterns.clone(),",
            "        ac: FullAcAutomaton::new(patterns.clone()),",
            "        buckets: vec![vec![0], vec![1], vec![2]],",
            "        masks: Masks::default(),",
            "    };",
            "",
            "    let searcher = LiteralSearcher {",
            "        complete: false,",
            "        lcp: FreqyPacked::new(vec![b'x']),",
            "        lcs: FreqyPacked::new(vec![b'z']),",
            "        matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "",
            "    let _ = searcher.iter();",
            "    let patterns = vec![vec![b'x'], vec![b'y'], vec![b'z']];",
            "    let ted = TeddyAVX2 {",
            "    vb: AVX2VectorBuilder::new(),",
            "    pats: patterns.clone(),",
            "    ac: FullAcAutomaton::new(patterns.clone()),",
            "    buckets: vec![vec![0], vec![1], vec![2]],",
            "    masks: Masks::default(),",
            "    };",
            "    let searcher = LiteralSearcher {",
            "    complete: false,",
            "    lcp: FreqyPacked::new(vec![b'x']),",
            "    lcs: FreqyPacked::new(vec![b'z']),",
            "    matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "    let result = searcher.iter();",
            "    assert_eq!(if let LiteralIter::TeddyAVX2(pats) = result { pats } else { &[] }, &patterns);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns: Vec<Vec<u8>> = vec![];",
          "    ",
          "    let ted = TeddyAVX2 {",
          "        vb: AVX2VectorBuilder::new(),",
          "        pats: patterns.clone(),",
          "        ac: FullAcAutomaton::new(patterns.clone()),",
          "        buckets: vec![],",
          "        masks: Masks::default(),",
          "    };",
          "",
          "    let searcher = LiteralSearcher {",
          "        complete: true,",
          "        lcp: FreqyPacked::new(vec![]),",
          "        lcs: FreqyPacked::new(vec![]),",
          "        matcher: Matcher::TeddyAVX2(ted.clone()),",
          "    };",
          "",
          "    let _ = searcher.iter();",
          "}"
        ],
        "oracles": [
          [
            "    let patterns: Vec<Vec<u8>> = vec![];",
            "    let ted = TeddyAVX2 { vb: AVX2VectorBuilder::new(), pats: patterns.clone(), ac: FullAcAutomaton::new(patterns.clone()), buckets: vec![], masks: Masks::default(), };",
            "    let searcher = LiteralSearcher { complete: true, lcp: FreqyPacked::new(vec![]), lcs: FreqyPacked::new(vec![]), matcher: Matcher::TeddyAVX2(ted.clone()), };",
            "    let result = searcher.iter();",
            "    assert!(matches!(result, LiteralIter::TeddyAVX2(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let patterns: Vec<Vec<u8>> = vec![];",
            "    ",
            "    let ted = TeddyAVX2 {",
            "        vb: AVX2VectorBuilder::new(),",
            "        pats: patterns.clone(),",
            "        ac: FullAcAutomaton::new(patterns.clone()),",
            "        buckets: vec![],",
            "        masks: Masks::default(),",
            "    };",
            "",
            "    let searcher = LiteralSearcher {",
            "        complete: true,",
            "        lcp: FreqyPacked::new(vec![]),",
            "        lcs: FreqyPacked::new(vec![]),",
            "        matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "",
            "    let _ = searcher.iter();",
            "    let patterns: Vec<Vec<u8>> = vec![];",
            "    let ted = TeddyAVX2 { vb: AVX2VectorBuilder::new(), pats: patterns.clone(), ac: FullAcAutomaton::new(patterns.clone()), buckets: vec![], masks: Masks::default(), };",
            "    let searcher = LiteralSearcher { complete: true, lcp: FreqyPacked::new(vec![]), lcs: FreqyPacked::new(vec![]), matcher: Matcher::TeddyAVX2(ted.clone()), };",
            "    let result = searcher.iter();",
            "    assert!(matches!(result, LiteralIter::TeddyAVX2(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let patterns = vec![vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o', b'p']];",
          "    ",
          "    let ted = TeddyAVX2 {",
          "        vb: AVX2VectorBuilder::new(),",
          "        pats: patterns.clone(),",
          "        ac: FullAcAutomaton::new(patterns.clone()),",
          "        buckets: vec![vec![0]],",
          "        masks: Masks::default(),",
          "    };",
          "",
          "    let searcher = LiteralSearcher {",
          "        complete: false,",
          "        lcp: FreqyPacked::new(vec![b'p']),",
          "        lcs: FreqyPacked::new(vec![b'a']),",
          "        matcher: Matcher::TeddyAVX2(ted.clone()),",
          "    };",
          "",
          "    let _ = searcher.iter();",
          "}"
        ],
        "oracles": [
          [
            "    let patterns = vec![vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o', b'p']];",
            "    let ted = TeddyAVX2 {",
            "    vb: AVX2VectorBuilder::new(),",
            "    pats: patterns.clone(),",
            "    ac: FullAcAutomaton::new(patterns.clone()),",
            "    buckets: vec![vec![0]],",
            "    masks: Masks::default(),",
            "    };",
            "    let searcher = LiteralSearcher {",
            "    complete: false,",
            "    lcp: FreqyPacked::new(vec![b'p']),",
            "    lcs: FreqyPacked::new(vec![b'a']),",
            "    matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "    assert_eq!(searcher.iter(), LiteralIter::TeddyAVX2(ted.patterns()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let patterns = vec![vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o', b'p']];",
            "    ",
            "    let ted = TeddyAVX2 {",
            "        vb: AVX2VectorBuilder::new(),",
            "        pats: patterns.clone(),",
            "        ac: FullAcAutomaton::new(patterns.clone()),",
            "        buckets: vec![vec![0]],",
            "        masks: Masks::default(),",
            "    };",
            "",
            "    let searcher = LiteralSearcher {",
            "        complete: false,",
            "        lcp: FreqyPacked::new(vec![b'p']),",
            "        lcs: FreqyPacked::new(vec![b'a']),",
            "        matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "",
            "    let _ = searcher.iter();",
            "    let patterns = vec![vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o', b'p']];",
            "    let ted = TeddyAVX2 {",
            "    vb: AVX2VectorBuilder::new(),",
            "    pats: patterns.clone(),",
            "    ac: FullAcAutomaton::new(patterns.clone()),",
            "    buckets: vec![vec![0]],",
            "    masks: Masks::default(),",
            "    };",
            "    let searcher = LiteralSearcher {",
            "    complete: false,",
            "    lcp: FreqyPacked::new(vec![b'p']),",
            "    lcs: FreqyPacked::new(vec![b'a']),",
            "    matcher: Matcher::TeddyAVX2(ted.clone()),",
            "    };",
            "    assert_eq!(searcher.iter(), LiteralIter::TeddyAVX2(ted.patterns()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]