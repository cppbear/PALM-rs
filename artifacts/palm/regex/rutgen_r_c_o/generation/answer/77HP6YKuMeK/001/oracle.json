[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
      "struct TestInterval {",
      "    lower: u8,",
      "    upper: u8,",
      "}",
      "",
      "impl TestInterval {",
      "    fn new(lower: u8, upper: u8) -> Self {",
      "        Self { lower, upper }",
      "    }",
      "}",
      "",
      "impl Interval for TestInterval {",
      "    type Bound = u8;",
      "",
      "    fn lower(&self) -> Self::Bound { self.lower }",
      "    fn upper(&self) -> Self::Bound { self.upper }",
      "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
      "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
      "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
      "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
      "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
      "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
          "    let _ = interval_set.intervals();",
          "}"
        ],
        "oracles": [
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.intervals(), &[]);"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
            "    let interval_set_with_intervals: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 5), TestInterval::new(6, 10)]);",
            "    assert_eq!(interval_set_with_intervals.intervals(), &[TestInterval::new(1, 5), TestInterval::new(6, 10)]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.intervals(), &[]);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
            "    let interval_set_with_intervals: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 5), TestInterval::new(6, 10)]);",
            "    assert_eq!(interval_set_with_intervals.intervals(), &[TestInterval::new(1, 5), TestInterval::new(6, 10)]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
          "    let _ = interval_set.intervals();",
          "}"
        ],
        "oracles": [
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let intervals = interval_set.intervals();",
            "    assert_eq!(intervals.len(), 1);"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let intervals = interval_set.intervals();",
            "    assert_eq!(intervals[0].lower(), 1);"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let intervals = interval_set.intervals();",
            "    assert_eq!(intervals[0].upper(), 2);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let intervals = interval_set.intervals();",
            "    assert_eq!(intervals.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let intervals = interval_set.intervals();",
            "    assert_eq!(intervals[0].lower(), 1);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
            "    let intervals = interval_set.intervals();",
            "    assert_eq!(intervals[0].upper(), 2);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval::new(0, 2),",
          "        TestInterval::new(3, 5),",
          "        TestInterval::new(6, 10),",
          "    ]);",
          "    let _ = interval_set.intervals();",
          "}"
        ],
        "oracles": [
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result.len(), 3);"
          ],
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result[0], TestInterval::new(0, 2));"
          ],
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result[1], TestInterval::new(3, 5));"
          ],
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result[2], TestInterval::new(6, 10));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 2),",
            "        TestInterval::new(3, 5),",
            "        TestInterval::new(6, 10),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 2),",
            "        TestInterval::new(3, 5),",
            "        TestInterval::new(6, 10),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result[0], TestInterval::new(0, 2));",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 2),",
            "        TestInterval::new(3, 5),",
            "        TestInterval::new(6, 10),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result[1], TestInterval::new(3, 5));",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 2),",
            "        TestInterval::new(3, 5),",
            "        TestInterval::new(6, 10),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
            "    let result = interval_set.intervals();",
            "    assert_eq!(result[2], TestInterval::new(6, 10));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval::new(0, 255),",
          "    ]);",
          "    let _ = interval_set.intervals();",
          "}"
        ],
        "oracles": [
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert_eq!(ranges.len(), 1);"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert_eq!(ranges[0].lower(), 0);"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert_eq!(ranges[0].upper(), 255);"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert!(ranges[0].is_contiguous(&TestInterval::new(0, 255)));"
          ],
          [
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert!(!ranges[0].is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 255),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert_eq!(ranges.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 255),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert_eq!(ranges[0].lower(), 0);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 255),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert_eq!(ranges[0].upper(), 255);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 255),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert!(ranges[0].is_contiguous(&TestInterval::new(0, 255)));",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(0, 255),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
            "    let ranges = interval_set.intervals();",
            "    assert!(!ranges[0].is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval::new(10, 20),",
          "        TestInterval::new(20, 30),",
          "    ]);",
          "    let _ = interval_set.intervals();",
          "}"
        ],
        "oracles": [
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
            "    assert_eq!(interval_set.intervals().len(), 2);"
          ],
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
            "    assert_eq!(interval_set.intervals()[0], TestInterval::new(10, 20));"
          ],
          [
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
            "    assert_eq!(interval_set.intervals()[1], TestInterval::new(20, 30));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(10, 20),",
            "        TestInterval::new(20, 30),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
            "    assert_eq!(interval_set.intervals().len(), 2);",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(10, 20),",
            "        TestInterval::new(20, 30),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
            "    assert_eq!(interval_set.intervals()[0], TestInterval::new(10, 20));",
            "}"
          ],
          [
            "{",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
            "        TestInterval::new(10, 20),",
            "        TestInterval::new(20, 30),",
            "    ]);",
            "    let _ = interval_set.intervals();",
            "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
            "    assert_eq!(interval_set.intervals()[1], TestInterval::new(20, 30));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
          "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
          "    let _ = interval_set.intervals();",
          "}"
        ],
        "oracles": [
          [
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert_eq!(interval_set.intervals().len(), intervals.len());"
          ],
          [
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert!(interval_set.intervals().iter().all(|interval| interval.lower() < interval.upper()));"
          ],
          [
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert_eq!(interval_set.intervals(), &intervals);"
          ],
          [
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.lower().cmp(&b.lower())));"
          ],
          [
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.upper().cmp(&b.upper())));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
            "    let _ = interval_set.intervals();",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert_eq!(interval_set.intervals().len(), intervals.len());",
            "}"
          ],
          [
            "{",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
            "    let _ = interval_set.intervals();",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert!(interval_set.intervals().iter().all(|interval| interval.lower() < interval.upper()));",
            "}"
          ],
          [
            "{",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
            "    let _ = interval_set.intervals();",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert_eq!(interval_set.intervals(), &intervals);",
            "}"
          ],
          [
            "{",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
            "    let _ = interval_set.intervals();",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.lower().cmp(&b.lower())));",
            "}"
          ],
          [
            "{",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
            "    let _ = interval_set.intervals();",
            "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
            "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.upper().cmp(&b.upper())));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]