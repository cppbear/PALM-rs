[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInput {",
          "        data: Vec<u8>,",
          "    }",
          "",
          "    impl Input for TestInput {",
          "        fn at(&self, i: usize) -> InputAt {",
          "            InputAt {",
          "                pos: i,",
          "                c: Char(97), // ASCII for 'a'",
          "                byte: Some(self.data[i]),",
          "                len: self.data.len(),",
          "            }",
          "        }",
          "        ",
          "        fn next_char(&self, at: InputAt) -> Char {",
          "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
          "        }",
          "        ",
          "        fn previous_char(&self, at: InputAt) -> Char {",
          "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
          "        }",
          "        ",
          "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
          "            false",
          "        }",
          "",
          "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
          "            None",
          "        }",
          "",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn as_bytes(&self) -> &[u8] {",
          "            &self.data",
          "        }",
          "    }",
          "",
          "    let input = TestInput { data: vec![0, 1, 2] };",
          "    let at = input.at(0);",
          "    let _next = input.next_char(at);",
          "}"
        ],
        "oracles": [
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(98)); // next_char of 'a' should be 'b'"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(99)); // next_char of 'b' should be 'c'"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(0)); // next_char of 'c' should wrap around to '0' (ASCII)"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let previous_char_result = input.previous_char(at);",
            "    assert_eq!(previous_char_result, Char(127)); // previous_char of 'a' should be '' (ASCII)"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let previous_char_result = input.previous_char(at);",
            "    let at = input.at(1);",
            "    let previous_char_result = input.previous_char(at);",
            "    assert_eq!(previous_char_result, Char(98)); // previous_char of 'b' should be 'a'"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let previous_char_result = input.previous_char(at);",
            "    let at = input.at(1);",
            "    let previous_char_result = input.previous_char(at);",
            "    let at = input.at(2);",
            "    let previous_char_result = input.previous_char(at);",
            "    assert_eq!(previous_char_result, Char(99)); // previous_char of 'c' should be 'b'"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(97), // ASCII for 'a'",
            "                byte: Some(self.data[i]),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(98)); // next_char of 'a' should be 'b'",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(97), // ASCII for 'a'",
            "                byte: Some(self.data[i]),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(99)); // next_char of 'b' should be 'c'",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(97), // ASCII for 'a'",
            "                byte: Some(self.data[i]),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(0)); // next_char of 'c' should wrap around to '0' (ASCII)",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(97), // ASCII for 'a'",
            "                byte: Some(self.data[i]),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let previous_char_result = input.previous_char(at);",
            "    assert_eq!(previous_char_result, Char(127)); // previous_char of 'a' should be '' (ASCII)",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(97), // ASCII for 'a'",
            "                byte: Some(self.data[i]),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let previous_char_result = input.previous_char(at);",
            "    let at = input.at(1);",
            "    let previous_char_result = input.previous_char(at);",
            "    assert_eq!(previous_char_result, Char(98)); // previous_char of 'b' should be 'a'",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(97), // ASCII for 'a'",
            "                byte: Some(self.data[i]),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let previous_char_result = input.previous_char(at);",
            "    let at = input.at(1);",
            "    let previous_char_result = input.previous_char(at);",
            "    let at = input.at(2);",
            "    let previous_char_result = input.previous_char(at);",
            "    assert_eq!(previous_char_result, Char(99)); // previous_char of 'c' should be 'b'",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInput {",
          "        data: Vec<u8>,",
          "    }",
          "",
          "    impl Input for TestInput {",
          "        fn at(&self, i: usize) -> InputAt {",
          "            InputAt {",
          "                pos: i,",
          "                c: Char(0),",
          "                byte: Some(0),",
          "                len: self.data.len(),",
          "            }",
          "        }",
          "        ",
          "        fn next_char(&self, at: InputAt) -> Char {",
          "            Char((at.c.0 + 1) % 128)",
          "        }",
          "        ",
          "        fn previous_char(&self, at: InputAt) -> Char {",
          "            Char((at.c.0 + 127) % 128)",
          "        }",
          "        ",
          "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
          "            false",
          "        }",
          "",
          "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
          "            None",
          "        }",
          "",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn as_bytes(&self) -> &[u8] {",
          "            &self.data",
          "        }",
          "    }",
          "",
          "    let input = TestInput { data: vec![0] };",
          "    let at = input.at(0);",
          "    let _next = input.next_char(at);",
          "}"
        ],
        "oracles": [
          [
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result.0, 1);"
          ],
          [
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result.0 % 128, 1);"
          ],
          [
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    assert_eq!(next_char_result_from_next.0, 0);"
          ],
          [
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    let at_empty = input.at(0);",
            "    assert!(input.is_empty_match(at_empty, &InstEmptyLook));"
          ],
          [
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    let at_empty = input.at(0);",
            "    assert_eq!(input.len(), 1);"
          ],
          [
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    let at_empty = input.at(0);",
            "    assert!(input.as_bytes() == &[0]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(0),",
            "                byte: Some(0),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result.0, 1);",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(0),",
            "                byte: Some(0),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result.0 % 128, 1);",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(0),",
            "                byte: Some(0),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    assert_eq!(next_char_result_from_next.0, 0);",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(0),",
            "                byte: Some(0),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    let at_empty = input.at(0);",
            "    assert!(input.is_empty_match(at_empty, &InstEmptyLook));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(0),",
            "                byte: Some(0),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    let at_empty = input.at(0);",
            "    assert_eq!(input.len(), 1);",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(0),",
            "                byte: Some(0),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0] };",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    let at_next = input.at(1);",
            "    let next_char_result_from_next = input.next_char(at_next);",
            "    let at_empty = input.at(0);",
            "    assert!(input.as_bytes() == &[0]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInput {",
          "        data: Vec<u8>,",
          "    }",
          "",
          "    impl Input for TestInput {",
          "        fn at(&self, i: usize) -> InputAt {",
          "            InputAt {",
          "                pos: i,",
          "                c: Char(u32::MAX),",
          "                byte: Some(1),",
          "                len: self.data.len(),",
          "            }",
          "        }",
          "        ",
          "        fn next_char(&self, at: InputAt) -> Char {",
          "            Char((at.c.0 + 1) % 128)",
          "        }",
          "        ",
          "        fn previous_char(&self, at: InputAt) -> Char {",
          "            Char((at.c.0 + 127) % 128)",
          "        }",
          "        ",
          "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
          "            false",
          "        }",
          "",
          "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
          "            None",
          "        }",
          "",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn as_bytes(&self) -> &[u8] {",
          "            &self.data",
          "        }",
          "    }",
          "",
          "    let input = TestInput { data: vec![0, 1, 2] };",
          "    let at = input.at(2); ",
          "    let _next = input.next_char(at);",
          "}"
        ],
        "oracles": [
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(0));"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(2));"
          ],
          [
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(1));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(u32::MAX),",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2); ",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(0));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(u32::MAX),",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2); ",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(2));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(u32::MAX),",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 1) % 128)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char((at.c.0 + 127) % 128)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2); ",
            "    let _next = input.next_char(at);",
            "    let input = TestInput { data: vec![0, 1, 2] };",
            "    let at = input.at(2);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(1);",
            "    let next_char_result = input.next_char(at);",
            "    let at = input.at(0);",
            "    let next_char_result = input.next_char(at);",
            "    assert_eq!(next_char_result, Char(1));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInput {",
          "        data: Vec<u8>,",
          "    }",
          "",
          "    impl Input for TestInput {",
          "        fn at(&self, i: usize) -> InputAt {",
          "            InputAt {",
          "                pos: i,",
          "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
          "                byte: Some(1),",
          "                len: self.data.len(),",
          "            }",
          "        }",
          "        ",
          "        fn next_char(&self, at: InputAt) -> Char {",
          "            Char(at.c.0 + 1)",
          "        }",
          "        ",
          "        fn previous_char(&self, at: InputAt) -> Char {",
          "            Char(at.c.0 - 1)",
          "        }",
          "        ",
          "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
          "            false",
          "        }",
          "",
          "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
          "            None",
          "        }",
          "",
          "        fn len(&self) -> usize {",
          "            self.data.len()",
          "        }",
          "",
          "        fn as_bytes(&self) -> &[u8] {",
          "            &self.data",
          "        }",
          "    }",
          "",
          "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
          "    for i in 0..1000 {",
          "        let at = input.at(i);",
          "        let _next = input.next_char(at);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    assert_eq!(input.next_char(at), Char(101));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    assert_eq!(input.next_char(at), Char(102));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    assert_eq!(input.next_char(at), Char(103));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    assert_eq!(input.next_char(at), Char(104));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    assert_eq!(input.next_char(at), Char(105));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    assert_eq!(input.next_char(at), Char(106));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    assert_eq!(input.next_char(at), Char(107));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    assert_eq!(input.next_char(at), Char(108));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    assert_eq!(input.next_char(at), Char(109));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    assert_eq!(input.next_char(at), Char(110));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    assert_eq!(input.next_char(at), Char(111));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    assert_eq!(input.next_char(at), Char(112));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    assert_eq!(input.next_char(at), Char(113));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    assert_eq!(input.next_char(at), Char(114));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    assert_eq!(input.next_char(at), Char(115));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    assert_eq!(input.next_char(at), Char(116));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    assert_eq!(input.next_char(at), Char(117));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    assert_eq!(input.next_char(at), Char(118));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    assert_eq!(input.next_char(at), Char(119));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    assert_eq!(input.next_char(at), Char(120));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    assert_eq!(input.next_char(at), Char(121));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    assert_eq!(input.next_char(at), Char(122));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    assert_eq!(input.next_char(at), Char(123));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    assert_eq!(input.next_char(at), Char(124));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    assert_eq!(input.next_char(at), Char(125));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    assert_eq!(input.next_char(at), Char(126));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    assert_eq!(input.next_char(at), Char(127));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    assert_eq!(input.next_char(at), Char(128));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    assert_eq!(input.next_char(at), Char(129));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    assert_eq!(input.next_char(at), Char(130));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    assert_eq!(input.next_char(at), Char(131));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    assert_eq!(input.next_char(at), Char(132));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    assert_eq!(input.next_char(at), Char(133));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    assert_eq!(input.next_char(at), Char(134));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    assert_eq!(input.next_char(at), Char(135));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    assert_eq!(input.next_char(at), Char(136));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    assert_eq!(input.next_char(at), Char(137));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    assert_eq!(input.next_char(at), Char(138));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    assert_eq!(input.next_char(at), Char(139));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    assert_eq!(input.next_char(at), Char(140));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    assert_eq!(input.next_char(at), Char(141));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    assert_eq!(input.next_char(at), Char(142));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    assert_eq!(input.next_char(at), Char(143));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    assert_eq!(input.next_char(at), Char(144));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    assert_eq!(input.next_char(at), Char(145));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    assert_eq!(input.next_char(at), Char(146));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    assert_eq!(input.next_char(at), Char(147));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    assert_eq!(input.next_char(at), Char(148));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    assert_eq!(input.next_char(at), Char(149));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    assert_eq!(input.next_char(at), Char(150));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    assert_eq!(input.next_char(at), Char(151));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    assert_eq!(input.next_char(at), Char(152));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    assert_eq!(input.next_char(at), Char(153));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    assert_eq!(input.next_char(at), Char(154));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    assert_eq!(input.next_char(at), Char(155));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    assert_eq!(input.next_char(at), Char(156));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    assert_eq!(input.next_char(at), Char(157));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    assert_eq!(input.next_char(at), Char(158));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    assert_eq!(input.next_char(at), Char(159));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    assert_eq!(input.next_char(at), Char(160));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    assert_eq!(input.next_char(at), Char(161));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    assert_eq!(input.next_char(at), Char(162));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    assert_eq!(input.next_char(at), Char(163));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    assert_eq!(input.next_char(at), Char(164));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    assert_eq!(input.next_char(at), Char(165));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    assert_eq!(input.next_char(at), Char(166));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    assert_eq!(input.next_char(at), Char(167));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    assert_eq!(input.next_char(at), Char(168));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    assert_eq!(input.next_char(at), Char(169));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    assert_eq!(input.next_char(at), Char(170));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    assert_eq!(input.next_char(at), Char(171));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    assert_eq!(input.next_char(at), Char(172));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    assert_eq!(input.next_char(at), Char(173));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    assert_eq!(input.next_char(at), Char(174));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    assert_eq!(input.next_char(at), Char(175));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    assert_eq!(input.next_char(at), Char(176));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    assert_eq!(input.next_char(at), Char(177));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    assert_eq!(input.next_char(at), Char(178));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    assert_eq!(input.next_char(at), Char(179));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    assert_eq!(input.next_char(at), Char(180));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    assert_eq!(input.next_char(at), Char(181));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    assert_eq!(input.next_char(at), Char(182));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    assert_eq!(input.next_char(at), Char(183));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    assert_eq!(input.next_char(at), Char(184));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    assert_eq!(input.next_char(at), Char(185));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    assert_eq!(input.next_char(at), Char(186));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    assert_eq!(input.next_char(at), Char(187));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    assert_eq!(input.next_char(at), Char(188));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    assert_eq!(input.next_char(at), Char(189));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    assert_eq!(input.next_char(at), Char(190));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    assert_eq!(input.next_char(at), Char(191));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    assert_eq!(input.next_char(at), Char(192));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    assert_eq!(input.next_char(at), Char(193));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    assert_eq!(input.next_char(at), Char(194));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    assert_eq!(input.next_char(at), Char(195));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    assert_eq!(input.next_char(at), Char(196));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    assert_eq!(input.next_char(at), Char(197));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    let at = input.at(97);",
            "    assert_eq!(input.next_char(at), Char(198));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    let at = input.at(97);",
            "    let at = input.at(98);",
            "    assert_eq!(input.next_char(at), Char(199));"
          ],
          [
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    let at = input.at(97);",
            "    let at = input.at(98);",
            "    let at = input.at(99);",
            "    assert_eq!(input.next_char(at), Char(200));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    assert_eq!(input.next_char(at), Char(101));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    assert_eq!(input.next_char(at), Char(102));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    assert_eq!(input.next_char(at), Char(103));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    assert_eq!(input.next_char(at), Char(104));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    assert_eq!(input.next_char(at), Char(105));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    assert_eq!(input.next_char(at), Char(106));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    assert_eq!(input.next_char(at), Char(107));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    assert_eq!(input.next_char(at), Char(108));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    assert_eq!(input.next_char(at), Char(109));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    assert_eq!(input.next_char(at), Char(110));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    assert_eq!(input.next_char(at), Char(111));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    assert_eq!(input.next_char(at), Char(112));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    assert_eq!(input.next_char(at), Char(113));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    assert_eq!(input.next_char(at), Char(114));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    assert_eq!(input.next_char(at), Char(115));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    assert_eq!(input.next_char(at), Char(116));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    assert_eq!(input.next_char(at), Char(117));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    assert_eq!(input.next_char(at), Char(118));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    assert_eq!(input.next_char(at), Char(119));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    assert_eq!(input.next_char(at), Char(120));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    assert_eq!(input.next_char(at), Char(121));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    assert_eq!(input.next_char(at), Char(122));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    assert_eq!(input.next_char(at), Char(123));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    assert_eq!(input.next_char(at), Char(124));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    assert_eq!(input.next_char(at), Char(125));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    assert_eq!(input.next_char(at), Char(126));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    assert_eq!(input.next_char(at), Char(127));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    assert_eq!(input.next_char(at), Char(128));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    assert_eq!(input.next_char(at), Char(129));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    assert_eq!(input.next_char(at), Char(130));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    assert_eq!(input.next_char(at), Char(131));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    assert_eq!(input.next_char(at), Char(132));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    assert_eq!(input.next_char(at), Char(133));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    assert_eq!(input.next_char(at), Char(134));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    assert_eq!(input.next_char(at), Char(135));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    assert_eq!(input.next_char(at), Char(136));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    assert_eq!(input.next_char(at), Char(137));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    assert_eq!(input.next_char(at), Char(138));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    assert_eq!(input.next_char(at), Char(139));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    assert_eq!(input.next_char(at), Char(140));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    assert_eq!(input.next_char(at), Char(141));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    assert_eq!(input.next_char(at), Char(142));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    assert_eq!(input.next_char(at), Char(143));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    assert_eq!(input.next_char(at), Char(144));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    assert_eq!(input.next_char(at), Char(145));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    assert_eq!(input.next_char(at), Char(146));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    assert_eq!(input.next_char(at), Char(147));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    assert_eq!(input.next_char(at), Char(148));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    assert_eq!(input.next_char(at), Char(149));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    assert_eq!(input.next_char(at), Char(150));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    assert_eq!(input.next_char(at), Char(151));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    assert_eq!(input.next_char(at), Char(152));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    assert_eq!(input.next_char(at), Char(153));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    assert_eq!(input.next_char(at), Char(154));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    assert_eq!(input.next_char(at), Char(155));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    assert_eq!(input.next_char(at), Char(156));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    assert_eq!(input.next_char(at), Char(157));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    assert_eq!(input.next_char(at), Char(158));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    assert_eq!(input.next_char(at), Char(159));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    assert_eq!(input.next_char(at), Char(160));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    assert_eq!(input.next_char(at), Char(161));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    assert_eq!(input.next_char(at), Char(162));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    assert_eq!(input.next_char(at), Char(163));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    assert_eq!(input.next_char(at), Char(164));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    assert_eq!(input.next_char(at), Char(165));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    assert_eq!(input.next_char(at), Char(166));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    assert_eq!(input.next_char(at), Char(167));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    assert_eq!(input.next_char(at), Char(168));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    assert_eq!(input.next_char(at), Char(169));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    assert_eq!(input.next_char(at), Char(170));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    assert_eq!(input.next_char(at), Char(171));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    assert_eq!(input.next_char(at), Char(172));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    assert_eq!(input.next_char(at), Char(173));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    assert_eq!(input.next_char(at), Char(174));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    assert_eq!(input.next_char(at), Char(175));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    assert_eq!(input.next_char(at), Char(176));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    assert_eq!(input.next_char(at), Char(177));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    assert_eq!(input.next_char(at), Char(178));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    assert_eq!(input.next_char(at), Char(179));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    assert_eq!(input.next_char(at), Char(180));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    assert_eq!(input.next_char(at), Char(181));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    assert_eq!(input.next_char(at), Char(182));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    assert_eq!(input.next_char(at), Char(183));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    assert_eq!(input.next_char(at), Char(184));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    assert_eq!(input.next_char(at), Char(185));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    assert_eq!(input.next_char(at), Char(186));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    assert_eq!(input.next_char(at), Char(187));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    assert_eq!(input.next_char(at), Char(188));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    assert_eq!(input.next_char(at), Char(189));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    assert_eq!(input.next_char(at), Char(190));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    assert_eq!(input.next_char(at), Char(191));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    assert_eq!(input.next_char(at), Char(192));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    assert_eq!(input.next_char(at), Char(193));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    assert_eq!(input.next_char(at), Char(194));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    assert_eq!(input.next_char(at), Char(195));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    assert_eq!(input.next_char(at), Char(196));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    assert_eq!(input.next_char(at), Char(197));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    let at = input.at(97);",
            "    assert_eq!(input.next_char(at), Char(198));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    let at = input.at(97);",
            "    let at = input.at(98);",
            "    assert_eq!(input.next_char(at), Char(199));",
            "}"
          ],
          [
            "{",
            "    struct TestInput {",
            "        data: Vec<u8>,",
            "    }",
            "",
            "    impl Input for TestInput {",
            "        fn at(&self, i: usize) -> InputAt {",
            "            InputAt {",
            "                pos: i,",
            "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
            "                byte: Some(1),",
            "                len: self.data.len(),",
            "            }",
            "        }",
            "        ",
            "        fn next_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 + 1)",
            "        }",
            "        ",
            "        fn previous_char(&self, at: InputAt) -> Char {",
            "            Char(at.c.0 - 1)",
            "        }",
            "        ",
            "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
            "            false",
            "        }",
            "",
            "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
            "            None",
            "        }",
            "",
            "        fn len(&self) -> usize {",
            "            self.data.len()",
            "        }",
            "",
            "        fn as_bytes(&self) -> &[u8] {",
            "            &self.data",
            "        }",
            "    }",
            "",
            "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
            "    for i in 0..1000 {",
            "        let at = input.at(i);",
            "        let _next = input.next_char(at);",
            "    }",
            "    let input = TestInput { data: vec![0; 1000] };",
            "    let at = input.at(0);",
            "    let at = input.at(1);",
            "    let at = input.at(2);",
            "    let at = input.at(3);",
            "    let at = input.at(4);",
            "    let at = input.at(5);",
            "    let at = input.at(6);",
            "    let at = input.at(7);",
            "    let at = input.at(8);",
            "    let at = input.at(9);",
            "    let at = input.at(10);",
            "    let at = input.at(11);",
            "    let at = input.at(12);",
            "    let at = input.at(13);",
            "    let at = input.at(14);",
            "    let at = input.at(15);",
            "    let at = input.at(16);",
            "    let at = input.at(17);",
            "    let at = input.at(18);",
            "    let at = input.at(19);",
            "    let at = input.at(20);",
            "    let at = input.at(21);",
            "    let at = input.at(22);",
            "    let at = input.at(23);",
            "    let at = input.at(24);",
            "    let at = input.at(25);",
            "    let at = input.at(26);",
            "    let at = input.at(27);",
            "    let at = input.at(28);",
            "    let at = input.at(29);",
            "    let at = input.at(30);",
            "    let at = input.at(31);",
            "    let at = input.at(32);",
            "    let at = input.at(33);",
            "    let at = input.at(34);",
            "    let at = input.at(35);",
            "    let at = input.at(36);",
            "    let at = input.at(37);",
            "    let at = input.at(38);",
            "    let at = input.at(39);",
            "    let at = input.at(40);",
            "    let at = input.at(41);",
            "    let at = input.at(42);",
            "    let at = input.at(43);",
            "    let at = input.at(44);",
            "    let at = input.at(45);",
            "    let at = input.at(46);",
            "    let at = input.at(47);",
            "    let at = input.at(48);",
            "    let at = input.at(49);",
            "    let at = input.at(50);",
            "    let at = input.at(51);",
            "    let at = input.at(52);",
            "    let at = input.at(53);",
            "    let at = input.at(54);",
            "    let at = input.at(55);",
            "    let at = input.at(56);",
            "    let at = input.at(57);",
            "    let at = input.at(58);",
            "    let at = input.at(59);",
            "    let at = input.at(60);",
            "    let at = input.at(61);",
            "    let at = input.at(62);",
            "    let at = input.at(63);",
            "    let at = input.at(64);",
            "    let at = input.at(65);",
            "    let at = input.at(66);",
            "    let at = input.at(67);",
            "    let at = input.at(68);",
            "    let at = input.at(69);",
            "    let at = input.at(70);",
            "    let at = input.at(71);",
            "    let at = input.at(72);",
            "    let at = input.at(73);",
            "    let at = input.at(74);",
            "    let at = input.at(75);",
            "    let at = input.at(76);",
            "    let at = input.at(77);",
            "    let at = input.at(78);",
            "    let at = input.at(79);",
            "    let at = input.at(80);",
            "    let at = input.at(81);",
            "    let at = input.at(82);",
            "    let at = input.at(83);",
            "    let at = input.at(84);",
            "    let at = input.at(85);",
            "    let at = input.at(86);",
            "    let at = input.at(87);",
            "    let at = input.at(88);",
            "    let at = input.at(89);",
            "    let at = input.at(90);",
            "    let at = input.at(91);",
            "    let at = input.at(92);",
            "    let at = input.at(93);",
            "    let at = input.at(94);",
            "    let at = input.at(95);",
            "    let at = input.at(96);",
            "    let at = input.at(97);",
            "    let at = input.at(98);",
            "    let at = input.at(99);",
            "    assert_eq!(input.next_char(at), Char(200));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]