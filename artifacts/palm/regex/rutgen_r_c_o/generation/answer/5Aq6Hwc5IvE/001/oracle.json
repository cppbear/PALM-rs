[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![ClassState::Open { ",
          "            union: ClassSetUnion { ",
          "                span: Span::new(0, 1), ",
          "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
          "            }, ",
          "            set: ClassBracketed { ",
          "                span: Span::new(0, 1), ",
          "                negated: false, ",
          "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
          "            } ",
          "        }]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
          "    parser.pop_class(nested_union);",
          "}"
        ],
        "oracles": [
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    assert_eq!(parser.stack_class.borrow().len(), 1);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    assert!(matches!(parser.stack_class.borrow().last(), Some(ClassState::Open { .. })));"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    let item = result.unwrap();",
            "    assert!(matches!(item, Either::Left(_)));"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    let item = result.unwrap();",
            "    let last_stack_state = parser.stack_class.borrow();",
            "    assert_eq!(last_stack_state.len(), 0);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    let item = result.unwrap();",
            "    let last_stack_state = parser.stack_class.borrow();",
            "    assert_eq!(parser.pos.get(), Position { offset: 1, line: 1, column: 2 });"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    assert_eq!(parser.stack_class.borrow().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    assert!(matches!(parser.stack_class.borrow().last(), Some(ClassState::Open { .. })));",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    let item = result.unwrap();",
            "    assert!(matches!(item, Either::Left(_)));",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    let item = result.unwrap();",
            "    let last_stack_state = parser.stack_class.borrow();",
            "    assert_eq!(last_stack_state.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![ClassSetItem::Literal(Literal::new('a'))] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    let result = parser.pop_class(nested_union);",
            "    let item = result.unwrap();",
            "    let last_stack_state = parser.stack_class.borrow();",
            "    assert_eq!(parser.pos.get(), Position { offset: 1, line: 1, column: 2 });",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![ClassState::Open { ",
          "            union: ClassSetUnion { ",
          "                span: Span::new(0, 1), ",
          "                items: vec![] ",
          "            }, ",
          "            set: ClassBracketed { ",
          "                span: Span::new(0, 1), ",
          "                negated: false, ",
          "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) ",
          "            } ",
          "        }]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
          "    parser.pop_class(nested_union);",
          "}"
        ],
        "oracles": [
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert!(parser.pop_class(nested_union).is_ok());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.stack_class.borrow().len(), 1);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.pos().offset, 1);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.pos().line, 1);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.pos().column, 2);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert!(parser.pop_class(nested_union).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.stack_class.borrow().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.pos().offset, 1);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.pos().line, 1);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![ClassState::Open { ",
            "            union: ClassSetUnion { ",
            "                span: Span::new(0, 1), ",
            "                items: vec![] ",
            "            }, ",
            "            set: ClassBracketed { ",
            "                span: Span::new(0, 1), ",
            "                negated: false, ",
            "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) ",
            "            } ",
            "        }]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(1, 2), items: vec![] }, set: ClassBracketed { span: Span::new(1, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 0), items: vec![] };",
            "    assert_eq!(parser.pos().column, 2);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
          "    parser.pop_class(nested_union);",
          "}"
        ],
        "oracles": [
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::UnclosedClass);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::UnclosedClass);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    assert_eq!(class.kind, ClassSet::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) }))));"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    }",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('d'))] };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: nested_union.clone(), set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    }",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('d'))] };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: nested_union.clone(), set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Left(union) = result.unwrap() {",
            "    assert_eq!(union.items.len(), 1);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    }",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('d'))] };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: nested_union.clone(), set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Left(union) = result.unwrap() {",
            "    assert_eq!(union.items[0], ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) })));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::UnclosedClass);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::UnclosedClass);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    assert_eq!(class.kind, ClassSet::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) }))));",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    }",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('d'))] };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: nested_union.clone(), set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    }",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('d'))] };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: nested_union.clone(), set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Left(union) = result.unwrap() {",
            "    assert_eq!(union.items.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ast::ClassSetBinaryOpKind::SomeOp, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) });",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('b'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ClassState::Open { union: ClassSetUnion { span: Span::new(0, 1), items: vec![] }, set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) } }]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('c'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Right(class) = result.unwrap() {",
            "    }",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('d'))] };",
            "    parser.stack_class.borrow_mut().push(ClassState::Open { union: nested_union.clone(), set: ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) } });",
            "    let result = parser.pop_class(nested_union);",
            "    if let Either::Left(union) = result.unwrap() {",
            "    assert_eq!(union.items[0], ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))) })));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![",
          "            ClassState::Op { ",
          "                kind: ClassSetBinaryOpKind::Union, ",
          "                lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) ",
          "            },",
          "            ClassState::Open { ",
          "                union: ClassSetUnion { ",
          "                    span: Span::new(0, 3), ",
          "                    items: vec![ClassSetItem::Literal(Literal::new('y'))] ",
          "                },",
          "                set: ClassBracketed { ",
          "                    span: Span::new(0, 2), ",
          "                    negated: false, ",
          "                    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) ",
          "                }",
          "            }",
          "        ]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
          "    parser.pop_class(nested_union);",
          "}"
        ],
        "oracles": [
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    assert_eq!(parser.stack_class.borrow().len(), 2);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    let either = result.unwrap();",
            "    match either {",
            "    Either::Left(union) => {",
            "    assert_eq!(union.items.len(), 2);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    let either = result.unwrap();",
            "    match either {",
            "    Either::Left(union) => {",
            "    },",
            "    Either::Right(_) => {",
            "    panic!(\"Expected Left variant\");",
            "    },",
            "    }",
            "    assert_eq!(parser.pos().offset, 4);"
          ],
          [
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    let either = result.unwrap();",
            "    match either {",
            "    Either::Left(union) => {",
            "    },",
            "    Either::Right(_) => {",
            "    panic!(\"Expected Left variant\");",
            "    },",
            "    }",
            "    assert_eq!(parser.stack_class.borrow().len(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![",
            "            ClassState::Op { ",
            "                kind: ClassSetBinaryOpKind::Union, ",
            "                lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) ",
            "            },",
            "            ClassState::Open { ",
            "                union: ClassSetUnion { ",
            "                    span: Span::new(0, 3), ",
            "                    items: vec![ClassSetItem::Literal(Literal::new('y'))] ",
            "                },",
            "                set: ClassBracketed { ",
            "                    span: Span::new(0, 2), ",
            "                    negated: false, ",
            "                    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) ",
            "                }",
            "            }",
            "        ]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    assert_eq!(parser.stack_class.borrow().len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![",
            "            ClassState::Op { ",
            "                kind: ClassSetBinaryOpKind::Union, ",
            "                lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) ",
            "            },",
            "            ClassState::Open { ",
            "                union: ClassSetUnion { ",
            "                    span: Span::new(0, 3), ",
            "                    items: vec![ClassSetItem::Literal(Literal::new('y'))] ",
            "                },",
            "                set: ClassBracketed { ",
            "                    span: Span::new(0, 2), ",
            "                    negated: false, ",
            "                    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) ",
            "                }",
            "            }",
            "        ]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![",
            "            ClassState::Op { ",
            "                kind: ClassSetBinaryOpKind::Union, ",
            "                lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) ",
            "            },",
            "            ClassState::Open { ",
            "                union: ClassSetUnion { ",
            "                    span: Span::new(0, 3), ",
            "                    items: vec![ClassSetItem::Literal(Literal::new('y'))] ",
            "                },",
            "                set: ClassBracketed { ",
            "                    span: Span::new(0, 2), ",
            "                    negated: false, ",
            "                    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) ",
            "                }",
            "            }",
            "        ]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    let either = result.unwrap();",
            "    match either {",
            "    Either::Left(union) => {",
            "    assert_eq!(union.items.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![",
            "            ClassState::Op { ",
            "                kind: ClassSetBinaryOpKind::Union, ",
            "                lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) ",
            "            },",
            "            ClassState::Open { ",
            "                union: ClassSetUnion { ",
            "                    span: Span::new(0, 3), ",
            "                    items: vec![ClassSetItem::Literal(Literal::new('y'))] ",
            "                },",
            "                set: ClassBracketed { ",
            "                    span: Span::new(0, 2), ",
            "                    negated: false, ",
            "                    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) ",
            "                }",
            "            }",
            "        ]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    let either = result.unwrap();",
            "    match either {",
            "    Either::Left(union) => {",
            "    },",
            "    Either::Right(_) => {",
            "    panic!(\"Expected Left variant\");",
            "    },",
            "    }",
            "    assert_eq!(parser.pos().offset, 4);",
            "}"
          ],
          [
            "{",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![",
            "            ClassState::Op { ",
            "                kind: ClassSetBinaryOpKind::Union, ",
            "                lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) ",
            "            },",
            "            ClassState::Open { ",
            "                union: ClassSetUnion { ",
            "                    span: Span::new(0, 3), ",
            "                    items: vec![ClassSetItem::Literal(Literal::new('y'))] ",
            "                },",
            "                set: ClassBracketed { ",
            "                    span: Span::new(0, 2), ",
            "                    negated: false, ",
            "                    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) ",
            "                }",
            "            }",
            "        ]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    parser.pop_class(nested_union);",
            "    let mut parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![ ClassState::Op { kind: ClassSetBinaryOpKind::Union, lhs: ClassSet::Item(ClassSetItem::Literal(Literal::new('x'))) }, ClassState::Open { union: ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('y'))] }, set: ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('z'))) } } ]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
            "    let nested_union = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Literal(Literal::new('w'))] };",
            "    let result = parser.pop_class(nested_union);",
            "    let either = result.unwrap();",
            "    match either {",
            "    Either::Left(union) => {",
            "    },",
            "    Either::Right(_) => {",
            "    panic!(\"Expected Left variant\");",
            "    },",
            "    }",
            "    assert_eq!(parser.stack_class.borrow().len(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]