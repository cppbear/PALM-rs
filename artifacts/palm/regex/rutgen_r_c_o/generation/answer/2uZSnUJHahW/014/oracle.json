[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"{1}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let span = Span::new(position, position);",
          "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
          "    ",
          "    parser.pos.set(position);",
          "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
          "    ",
          "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::X));"
          ],
          [
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, '1');"
          ],
          [
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert!(literal.span.start == position);"
          ],
          [
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert!(literal.span.end == parser.pos());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::X));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, '1');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert!(literal.span.start == position);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let pattern = \"{1}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let literal = result.unwrap();",
            "    assert!(literal.span.end == parser.pos());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"{A}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let span = Span::new(position, position);",
          "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
          "    ",
          "    parser.pos.set(position);",
          "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
          "    ",
          "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span, Span::new(span.start, parser.pos.get()));"
          ],
          [
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort));"
          ],
          [
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, 'A');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span, Span::new(span.start, parser.pos.get()));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let pattern = \"{A}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"A\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, 'A');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"{1F}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let span = Span::new(position, position);",
          "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
          "    ",
          "    parser.pos.set(position);",
          "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
          "    ",
          "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span.start, start);"
          ],
          [
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span.end, parser.pos.get());"
          ],
          [
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong));"
          ],
          [
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, 'ǿ');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span.start, start);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span.end, parser.pos.get());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{1F}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"1F\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, 'ǿ');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"{7B}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let span = Span::new(position, position);",
          "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
          "    ",
          "    parser.pos.set(position);",
          "    parser.parser().scratch.borrow_mut().push_str(\"7B\");",
          "    ",
          "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
          "}"
        ],
        "oracles": [
          [
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let expected_char = char::from_u32(0x7B).unwrap(); // '{'",
            "    let expected_literal = ast::Literal {",
            "    span: Span::new(span.start, span.end),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: expected_char,",
            "    };",
            "    assert!(result.is_ok());"
          ],
          [
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let expected_char = char::from_u32(0x7B).unwrap(); // '{'",
            "    let expected_literal = ast::Literal {",
            "    span: Span::new(span.start, span.end),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: expected_char,",
            "    };",
            "    assert_eq!(result.unwrap(), expected_literal);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"{7B}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"7B\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let expected_char = char::from_u32(0x7B).unwrap(); // '{'",
            "    let expected_literal = ast::Literal {",
            "    span: Span::new(span.start, span.end),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: expected_char,",
            "    };",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{7B}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"7B\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let expected_char = char::from_u32(0x7B).unwrap(); // '{'",
            "    let expected_literal = ast::Literal {",
            "    span: Span::new(span.start, span.end),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: expected_char,",
            "    };",
            "    assert_eq!(result.unwrap(), expected_literal);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"{FFFF}\";",
          "    let position = Position { offset: 0, line: 1, column: 1 };",
          "    let span = Span::new(position, position);",
          "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
          "    ",
          "    parser.pos.set(position);",
          "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
          "    ",
          "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span.start, position);"
          ],
          [
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong));"
          ],
          [
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, char::from_u32(0xFFFF).unwrap());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.span.start, position);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.kind, ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    ",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    ",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let pattern = \"{FFFF}\";",
            "    let position = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(position, position);",
            "    let parser = ParserI { parser: Parser { ast: ast::parse::Parser::new(), hir: hir::translate::Translator::new() }, pattern: pattern };",
            "    parser.pos.set(position);",
            "    parser.parser().scratch.borrow_mut().push_str(\"FFFF\");",
            "    let result = parser.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);",
            "    let literal = result.unwrap();",
            "    assert_eq!(literal.c, char::from_u32(0xFFFF).unwrap());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]