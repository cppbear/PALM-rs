[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer {",
          "        printer: &mut Printer { _priv: () },",
          "        wtr: &mut output,",
          "    };",
          "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassUnicodeKind::OneLetter('a'),",
          "    });",
          "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "    span: Span::default(),",
            "    negated: false,",
            "    kind: ClassUnicodeKind::OneLetter('a'),",
            "    });",
            "    assert_eq!(output, r\"\\p{a}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::OneLetter('a'),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
            "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "    span: Span::default(),",
            "    negated: false,",
            "    kind: ClassUnicodeKind::OneLetter('a'),",
            "    });",
            "    assert_eq!(output, r\"\\p{a}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer {",
          "        printer: &mut Printer { _priv: () },",
          "        wtr: &mut output,",
          "    };",
          "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
          "        span: Span::default(),",
          "        negated: true,",
          "        kind: ClassUnicodeKind::OneLetter('A'),",
          "    });",
          "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "    printer: &mut Printer { _priv: () },",
            "    wtr: &mut output,",
            "    };",
            "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "    span: Span::default(),",
            "    negated: true,",
            "    kind: ClassUnicodeKind::OneLetter('A'),",
            "    });",
            "    assert_eq!(output, r\"\\PA\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: true,",
            "        kind: ClassUnicodeKind::OneLetter('A'),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "    printer: &mut Printer { _priv: () },",
            "    wtr: &mut output,",
            "    };",
            "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "    span: Span::default(),",
            "    negated: true,",
            "    kind: ClassUnicodeKind::OneLetter('A'),",
            "    });",
            "    assert_eq!(output, r\"\\PA\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer {",
          "        printer: &mut Printer { _priv: () },",
          "        wtr: &mut output,",
          "    };",
          "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassUnicodeKind::Named(\"Scx\"),",
          "    });",
          "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert_eq!(output, expected_output);"
          ],
          [
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert!(output.contains(r\"\\p{\" ));"
          ],
          [
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert!(output.contains(\"Scx\"));"
          ],
          [
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert!(!output.contains(r\"\\P{\" ));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::Named(\"Scx\"),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert_eq!(output, expected_output);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::Named(\"Scx\"),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert!(output.contains(r\"\\p{\" ));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::Named(\"Scx\"),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert!(output.contains(\"Scx\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::Named(\"Scx\"),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
            "    let expected_output = r\"\\p{Scx}\";",
            "    assert!(!output.contains(r\"\\P{\" ));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer {",
          "        printer: &mut Printer { _priv: () },",
          "        wtr: &mut output,",
          "    };",
          "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
          "        span: Span::default(),",
          "        negated: true,",
          "        kind: ClassUnicodeKind::NamedValue {",
          "            op: ClassUnicodeOpKind::Equal,",
          "            name: \"Scx\".to_string(),",
          "            value: \"Katakana\".to_string(),",
          "        },",
          "    });",
          "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    output.clear();",
            "    assert_eq!(output, r\"\\P{Scx=Katakana}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: true,",
            "        kind: ClassUnicodeKind::NamedValue {",
            "            op: ClassUnicodeOpKind::Equal,",
            "            name: \"Scx\".to_string(),",
            "            value: \"Katakana\".to_string(),",
            "        },",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
            "    output.clear();",
            "    assert_eq!(output, r\"\\P{Scx=Katakana}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer {",
          "        printer: &mut Printer { _priv: () },",
          "        wtr: &mut output,",
          "    };",
          "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassUnicodeKind::NamedValue {",
          "            op: ClassUnicodeOpKind::NotEqual,",
          "            name: \"Scx\".to_string(),",
          "            value: \"Hiragana\".to_string(),",
          "        },",
          "    });",
          "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "    printer: &mut Printer { _priv: () },",
            "    wtr: &mut output,",
            "    };",
            "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "    span: Span::default(),",
            "    negated: false,",
            "    kind: ClassUnicodeKind::NamedValue {",
            "    op: ClassUnicodeOpKind::NotEqual,",
            "    name: \"Scx\".to_string(),",
            "    value: \"Hiragana\".to_string(),",
            "    },",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
            "    assert_eq!(output, r\"\\p{Scx!=Hiragana}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::NamedValue {",
            "            op: ClassUnicodeOpKind::NotEqual,",
            "            name: \"Scx\".to_string(),",
            "            value: \"Hiragana\".to_string(),",
            "        },",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "    printer: &mut Printer { _priv: () },",
            "    wtr: &mut output,",
            "    };",
            "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "    span: Span::default(),",
            "    negated: false,",
            "    kind: ClassUnicodeKind::NamedValue {",
            "    op: ClassUnicodeOpKind::NotEqual,",
            "    name: \"Scx\".to_string(),",
            "    value: \"Hiragana\".to_string(),",
            "    },",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
            "    assert_eq!(output, r\"\\p{Scx!=Hiragana}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer {",
          "        printer: &mut Printer { _priv: () },",
          "        wtr: &mut output,",
          "    };",
          "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassUnicodeKind::Range(ast::ClassSetRange {",
          "            span: Span::default(),",
          "            start: ast::Literal {",
          "                span: Span::default(),",
          "                kind: ast::LiteralKind::Verbatim,",
          "                c: '\\u{00A0}',",
          "            },",
          "            end: ast::Literal {",
          "                span: Span::default(),",
          "                kind: ast::LiteralKind::Verbatim,",
          "                c: '\\u{FFFF}',",
          "            },",
          "        }),",
          "    });",
          "    writer.visit_class_set_item_post(&unicode_range).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let output = String::new();",
            "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::Range(ast::ClassSetRange { span: Span::default(), start: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{00A0}', }, end: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{FFFF}', }, }), });",
            "    assert_eq!(output, r\"\\u00A0-\\uFFFF\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer {",
            "        printer: &mut Printer { _priv: () },",
            "        wtr: &mut output,",
            "    };",
            "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
            "        span: Span::default(),",
            "        negated: false,",
            "        kind: ClassUnicodeKind::Range(ast::ClassSetRange {",
            "            span: Span::default(),",
            "            start: ast::Literal {",
            "                span: Span::default(),",
            "                kind: ast::LiteralKind::Verbatim,",
            "                c: '\\u{00A0}',",
            "            },",
            "            end: ast::Literal {",
            "                span: Span::default(),",
            "                kind: ast::LiteralKind::Verbatim,",
            "                c: '\\u{FFFF}',",
            "            },",
            "        }),",
            "    });",
            "    writer.visit_class_set_item_post(&unicode_range).unwrap();",
            "    let output = String::new();",
            "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::Range(ast::ClassSetRange { span: Span::default(), start: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{00A0}', }, end: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{FFFF}', }, }), });",
            "    assert_eq!(output, r\"\\u00A0-\\uFFFF\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]