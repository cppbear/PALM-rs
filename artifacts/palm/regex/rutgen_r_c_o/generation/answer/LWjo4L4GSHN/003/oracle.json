[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "fn test_hir_repetition_exactly() {",
      "    let trans = Translator {",
      "        stack: RefCell::new(vec![]),",
      "        flags: Cell::new(Flags {",
      "            case_insensitive: None,",
      "            multi_line: None,",
      "            dot_matches_new_line: None,",
      "            swap_greed: Some(true),",
      "            unicode: None,",
      "        }),",
      "        allow_invalid_utf8: false,",
      "    };",
      "    let pattern = \"a*\";",
      "    let translator_i = TranslatorI::new(&trans, pattern);",
      "",
      "    let rep = ast::Repetition {",
      "        op: ast::RepetitionOp {",
      "            kind: ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(3)),",
      "        },",
      "        // additional necessary fields...",
      "    };",
      "    ",
      "    let expr = Hir::dot(false);",
      "    translator_i.hir_repetition(&rep, expr);",
      "}",
      "",
      "fn test_hir_repetition_bounded() {",
      "    let trans = Translator {",
      "        stack: RefCell::new(vec![]),",
      "        flags: Cell::new(Flags {",
      "            case_insensitive: None,",
      "            multi_line: None,",
      "            dot_matches_new_line: None,",
      "            swap_greed: Some(true),",
      "            unicode: None,",
      "        }),",
      "        allow_invalid_utf8: false,",
      "    };",
      "    let pattern = \"ab?\";",
      "    let translator_i = TranslatorI::new(&trans, pattern);",
      "",
      "    let rep = ast::Repetition {",
      "        op: ast::RepetitionOp {",
      "            kind: ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(1, 5)),",
      "        },",
      "        // additional necessary fields...",
      "    };",
      "    ",
      "    let expr = Hir::dot(false);",
      "    translator_i.hir_repetition(&rep, expr);",
      "}",
      "",
      "fn test_hir_repetition_at_least() {",
      "    let trans = Translator {",
      "        stack: RefCell::new(vec![]),",
      "        flags: Cell::new(Flags {",
      "            case_insensitive: None,",
      "            multi_line: None,",
      "            dot_matches_new_line: None,",
      "            swap_greed: Some(true),",
      "            unicode: None,",
      "        }),",
      "        allow_invalid_utf8: false,",
      "    };",
      "    let pattern = \"c+\";",
      "    let translator_i = TranslatorI::new(&trans, pattern);",
      "",
      "    let rep = ast::Repetition {",
      "        op: ast::RepetitionOp {",
      "            kind: ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(2)),",
      "        },",
      "        // additional necessary fields...",
      "    };",
      "    ",
      "    let expr = Hir::dot(false);",
      "    translator_i.hir_repetition(&rep, expr);",
      "}",
      "",
      "fn test_hir_repetition_zero_or_more() {",
      "    let trans = Translator {",
      "        stack: RefCell::new(vec![]),",
      "        flags: Cell::new(Flags {",
      "            case_insensitive: None,",
      "            multi_line: None,",
      "            dot_matches_new_line: None,",
      "            swap_greed: Some(true),",
      "            unicode: None,",
      "        }),",
      "        allow_invalid_utf8: false,",
      "    };",
      "    let pattern = \"d*\";",
      "    let translator_i = TranslatorI::new(&trans, pattern);",
      "",
      "    let rep = ast::Repetition {",
      "        op: ast::RepetitionOp {",
      "            kind: ast::RepetitionKind::ZeroOrMore,",
      "        },",
      "        // additional necessary fields...",
      "    };",
      "    ",
      "    let expr = Hir::dot(false);",
      "    translator_i.hir_repetition(&rep, expr);",
      "}"
    ],
    "chain_tests": []
  }
]