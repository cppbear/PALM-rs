[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let range = ast::ClassSetItem::Range(0..255);",
          "    let class_induct = ClassInduct::Item(&range);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let range = ast::ClassSetItem::Range(0..255);",
            "    let class_induct = ClassInduct::Item(&range);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
          ],
          [
            "    let range = ast::ClassSetItem::Range(0..255);",
            "    let class_induct = ClassInduct::Item(&range);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(formatter.buffer(), \"Item(Range)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let range = ast::ClassSetItem::Range(0..255);",
            "    let class_induct = ClassInduct::Item(&range);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let range = ast::ClassSetItem::Range(0..255);",
            "    let class_induct = ClassInduct::Item(&range);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let range = ast::ClassSetItem::Range(0..255);",
            "    let class_induct = ClassInduct::Item(&range);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let range = ast::ClassSetItem::Range(0..255);",
            "    let class_induct = ClassInduct::Item(&range);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(formatter.buffer(), \"Item(Range)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
          "    let class_induct = ClassInduct::Item(&empty);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
            "    let class_induct = ClassInduct::Item(&empty);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
            "    let class_induct = ClassInduct::Item(&empty);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.buffer(), \"Item(Empty)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
            "    let class_induct = ClassInduct::Item(&empty);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
            "    let class_induct = ClassInduct::Item(&empty);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
            "    let class_induct = ClassInduct::Item(&empty);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
            "    let class_induct = ClassInduct::Item(&empty);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.buffer(), \"Item(Empty)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
          "    let class_induct = ClassInduct::Item(&literal);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
            "    let class_induct = ClassInduct::Item(&literal);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.buffer(), \"Item(Literal)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
            "    let class_induct = ClassInduct::Item(&literal);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
            "    let class_induct = ClassInduct::Item(&literal);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.buffer(), \"Item(Literal)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
          "    let class_induct = ClassInduct::Item(&ascii);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
            "    let class_induct = ClassInduct::Item(&ascii);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
          ],
          [
            "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
            "    let class_induct = ClassInduct::Item(&ascii);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
            "    let class_induct = ClassInduct::Item(&ascii);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
            "    let class_induct = ClassInduct::Item(&ascii);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
            "    let class_induct = ClassInduct::Item(&ascii);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
            "    let class_induct = ClassInduct::Item(&ascii);",
            "    let mut formatter = fmt::Formatter::new();",
            "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
          "    let class_induct = ClassInduct::Item(&unicode);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
            "    let class_induct = ClassInduct::Item(&unicode);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Unicode)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
            "    let class_induct = ClassInduct::Item(&unicode);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
            "    let class_induct = ClassInduct::Item(&unicode);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Unicode)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
          "    let class_induct = ClassInduct::Item(&perl);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
            "    let class_induct = ClassInduct::Item(&perl);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
            "    let class_induct = ClassInduct::Item(&perl);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert!(formatter.to_string().contains(\"Item(Perl)\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
            "    let class_induct = ClassInduct::Item(&perl);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
            "    let class_induct = ClassInduct::Item(&perl);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
            "    let class_induct = ClassInduct::Item(&perl);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
            "    let class_induct = ClassInduct::Item(&perl);",
            "    let mut formatter = fmt::Formatter::new();",
            "    let result = fmt(&class_induct, &mut formatter);",
            "    assert!(formatter.to_string().contains(\"Item(Perl)\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
          "    let class_induct = ClassInduct::Item(&bracketed);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let class_induct = ClassInduct::Item(&bracketed);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Bracketed)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let class_induct = ClassInduct::Item(&bracketed);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let class_induct = ClassInduct::Item(&bracketed);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Bracketed)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
          "    let class_induct = ClassInduct::Item(&union);",
          "    let mut formatter = fmt::Formatter::new();",
          "    fmt(&class_induct, &mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let class_induct = ClassInduct::Item(&union);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let class_induct = ClassInduct::Item(&union);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let class_induct = ClassInduct::Item(&union);",
            "    let mut formatter = fmt::Formatter::new();",
            "    fmt(&class_induct, &mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]