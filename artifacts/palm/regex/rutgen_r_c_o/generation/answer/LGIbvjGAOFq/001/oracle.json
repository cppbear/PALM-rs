[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Alnum;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result.set, IntervalSet::new(vec![(ClassBytesRange::new('0' as u8, '9' as u8)), (ClassBytesRange::new('A' as u8, 'Z' as u8)), (ClassBytesRange::new('a' as u8, 'z' as u8))]));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Alnum;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Alnum;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result.set, IntervalSet::new(vec![(ClassBytesRange::new('0' as u8, '9' as u8)), (ClassBytesRange::new('A' as u8, 'Z' as u8)), (ClassBytesRange::new('a' as u8, 'z' as u8))]));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Alpha;",
            "    let expected_ranges = vec![hir::ClassBytesRange::new('A' as u8, 'Z' as u8), hir::ClassBytesRange::new('a' as u8, 'z' as u8)];",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Alpha;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Alpha;",
            "    let expected_ranges = vec![hir::ClassBytesRange::new('A' as u8, 'Z' as u8), hir::ClassBytesRange::new('a' as u8, 'z' as u8)];",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Ascii;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(0, 127)]));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Ascii;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Ascii;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(0, 127)]));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Blank;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b' ', b'\\t')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Blank;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Blank;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b' ', b'\\t')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Cntrl;",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(0, 31), hir::ClassBytesRange::new(127, 127)];",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Cntrl;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Cntrl;",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(0, 31), hir::ClassBytesRange::new(127, 127)];",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Digit;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Digit;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Digit;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Graph;",
            "    let expected_ranges = vec![hir::ClassBytesRange::new('!' as u8, '~' as u8)];",
            "    let class_bytes = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(class_bytes.set.ranges, expected_ranges);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Graph;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Graph;",
            "    let expected_ranges = vec![hir::ClassBytesRange::new('!' as u8, '~' as u8)];",
            "    let class_bytes = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(class_bytes.set.ranges, expected_ranges);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Lower;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'a', b'z')]));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Lower;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Lower;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(b'a', b'z')]));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Print;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(32, 126)]));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Print;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Print;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    assert_eq!(result, hir::ClassBytes::new(vec![hir::ClassBytesRange::new(32, 126)]));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Punct;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![(33u8, 47u8), (58u8, 64u8), (91u8, 96u8), (123u8, 126u8)];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Punct;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Punct;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![(33u8, 47u8), (58u8, 64u8), (91u8, 96u8), (123u8, 126u8)];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Space;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b'\\n', b'\\n'), hir::ClassBytesRange::new(b'\\x0B', b'\\x0B'), hir::ClassBytesRange::new(b'\\x0C', b'\\x0C'), hir::ClassBytesRange::new(b'\\r', b'\\r'), hir::ClassBytesRange::new(b' ', b' ')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Space;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Space;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b'\\t', b'\\t'), hir::ClassBytesRange::new(b'\\n', b'\\n'), hir::ClassBytesRange::new(b'\\x0B', b'\\x0B'), hir::ClassBytesRange::new(b'\\x0C', b'\\x0C'), hir::ClassBytesRange::new(b'\\r', b'\\r'), hir::ClassBytesRange::new(b' ', b' ')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let ranges = ascii_class(&ast::ClassAsciiKind::Upper).iter().cloned().map(|(s, e)| {",
            "    hir::ClassBytesRange::new(s as u8, e as u8)",
            "    }).collect();",
            "    let expected = hir::ClassBytes::new(ranges);",
            "    assert_eq!(hir_ascii_class_bytes(&ast::ClassAsciiKind::Upper), expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Upper;",
            "    hir_ascii_class_bytes(&kind);",
            "    let ranges = ascii_class(&ast::ClassAsciiKind::Upper).iter().cloned().map(|(s, e)| {",
            "    hir::ClassBytesRange::new(s as u8, e as u8)",
            "    }).collect();",
            "    let expected = hir::ClassBytes::new(ranges);",
            "    assert_eq!(hir_ascii_class_bytes(&ast::ClassAsciiKind::Upper), expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let ranges = hir_ascii_class_bytes(&ast::ClassAsciiKind::Word).set;",
            "    assert_eq!(ranges, IntervalSet::from(vec![ClassBytesRange::new(48, 57), ClassBytesRange::new(65, 90), ClassBytesRange::new(95, 95), ClassBytesRange::new(97, 122)]));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Word;",
            "    hir_ascii_class_bytes(&kind);",
            "    let ranges = hir_ascii_class_bytes(&ast::ClassAsciiKind::Word).set;",
            "    assert_eq!(ranges, IntervalSet::from(vec![ClassBytesRange::new(48, 57), ClassBytesRange::new(65, 90), ClassBytesRange::new(95, 95), ClassBytesRange::new(97, 122)]));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    hir_ascii_class_bytes(&kind);",
          "}"
        ],
        "oracles": [
          [
            "    let kind = ast::ClassAsciiKind::Xdigit;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'F'), hir::ClassBytesRange::new(b'a', b'f')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let kind = ast::ClassAsciiKind::Xdigit;",
            "    hir_ascii_class_bytes(&kind);",
            "    let kind = ast::ClassAsciiKind::Xdigit;",
            "    let result = hir_ascii_class_bytes(&kind);",
            "    let expected_ranges = vec![hir::ClassBytesRange::new(b'0', b'9'), hir::ClassBytesRange::new(b'A', b'F'), hir::ClassBytesRange::new(b'a', b'f')];",
            "    assert_eq!(result.set, hir::ClassBytes::new(expected_ranges).set);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]