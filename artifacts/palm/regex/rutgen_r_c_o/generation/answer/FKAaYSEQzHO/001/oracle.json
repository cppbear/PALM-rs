[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![],",
          "            nfa: Program {",
          "                captures: vec![],",
          "                // Initialize other fields as necessary",
          "            },",
          "            dfa: Program {",
          "                captures: vec![],",
          "            },",
          "            dfa_reverse: Program {",
          "                captures: vec![],",
          "            },",
          "            suffixes: LiteralSearcher::new(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.capture_names();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures.len(), 3);"
          ],
          [
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[0], Some(\"name1\".to_string()));"
          ],
          [
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[1], None);"
          ],
          [
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[2], Some(\"name2\".to_string()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![],",
            "            nfa: Program {",
            "                captures: vec![],",
            "                // Initialize other fields as necessary",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![],",
            "            nfa: Program {",
            "                captures: vec![],",
            "                // Initialize other fields as necessary",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[0], Some(\"name1\".to_string()));",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![],",
            "            nfa: Program {",
            "                captures: vec![],",
            "                // Initialize other fields as necessary",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[1], None);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![],",
            "            nfa: Program {",
            "                captures: vec![],",
            "                // Initialize other fields as necessary",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec {",
            "    ro: Arc::new(ExecReadOnly {",
            "    res: vec![],",
            "    nfa: Program {",
            "    captures: vec![Some(\"name1\".to_string()), None, Some(\"name2\".to_string())],",
            "    },",
            "    dfa: Program {",
            "    captures: vec![],",
            "    },",
            "    dfa_reverse: Program {",
            "    captures: vec![],",
            "    },",
            "    suffixes: LiteralSearcher::new(),",
            "    match_type: MatchType::default(),",
            "    }),",
            "    cache: CachedThreadLocal::new(),",
            "    };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[2], Some(\"name2\".to_string()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"test\".to_string()],",
          "            nfa: Program {",
          "                captures: vec![None],",
          "            },",
          "            dfa: Program {",
          "                captures: vec![None],",
          "            },",
          "            dfa_reverse: Program {",
          "                captures: vec![None],",
          "            },",
          "            suffixes: LiteralSearcher::new(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.capture_names();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![None], }, dfa: Program { captures: vec![None], }, dfa_reverse: Program { captures: vec![None], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.capture_names(), &[None]);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![None], }, dfa: Program { captures: vec![None], }, dfa_reverse: Program { captures: vec![None], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.capture_names().len(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures: vec![None],",
            "            },",
            "            dfa: Program {",
            "                captures: vec![None],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![None],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![None], }, dfa: Program { captures: vec![None], }, dfa_reverse: Program { captures: vec![None], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.capture_names(), &[None]);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures: vec![None],",
            "            },",
            "            dfa: Program {",
            "                captures: vec![None],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![None],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![None], }, dfa: Program { captures: vec![None], }, dfa_reverse: Program { captures: vec![None], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.capture_names().len(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"test\".to_string()],",
          "            nfa: Program {",
          "                captures: vec![Some(\"capture1\".to_string())],",
          "            },",
          "            dfa: Program {",
          "                captures: vec![Some(\"capture1\".to_string())],",
          "            },",
          "            dfa_reverse: Program {",
          "                captures: vec![Some(\"capture1\".to_string())],",
          "            },",
          "            suffixes: LiteralSearcher::new(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.capture_names();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa_reverse: Program { captures: vec![Some(\"capture1\".to_string())], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures.len(), 1);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa_reverse: Program { captures: vec![Some(\"capture1\".to_string())], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[0], Some(\"capture1\".to_string()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures: vec![Some(\"capture1\".to_string())],",
            "            },",
            "            dfa: Program {",
            "                captures: vec![Some(\"capture1\".to_string())],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![Some(\"capture1\".to_string())],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa_reverse: Program { captures: vec![Some(\"capture1\".to_string())], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures: vec![Some(\"capture1\".to_string())],",
            "            },",
            "            dfa: Program {",
            "                captures: vec![Some(\"capture1\".to_string())],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![Some(\"capture1\".to_string())],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa: Program { captures: vec![Some(\"capture1\".to_string())], }, dfa_reverse: Program { captures: vec![Some(\"capture1\".to_string())], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let captures = exec.capture_names();",
            "    assert_eq!(captures[0], Some(\"capture1\".to_string()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"test\".to_string()],",
          "            nfa: Program {",
          "                captures: vec![",
          "                    Some(\"capture1\".to_string()),",
          "                    None,",
          "                    Some(\"capture2\".to_string()),",
          "                ],",
          "            },",
          "            dfa: Program {",
          "                captures: vec![",
          "                    Some(\"capture1\".to_string()),",
          "                    None,",
          "                    Some(\"capture2\".to_string()),",
          "                ],",
          "            },",
          "            dfa_reverse: Program {",
          "                captures: vec![",
          "                    Some(\"capture1\".to_string()),",
          "                    None,",
          "                    Some(\"capture2\".to_string()),",
          "                ],",
          "            },",
          "            suffixes: LiteralSearcher::new(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.capture_names();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string()),], }, dfa: Program { captures: vec![Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string()),], }, dfa_reverse: Program { captures: vec![Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string()),], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.capture_names(), &[Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string())]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures: vec![",
            "                    Some(\"capture1\".to_string()),",
            "                    None,",
            "                    Some(\"capture2\".to_string()),",
            "                ],",
            "            },",
            "            dfa: Program {",
            "                captures: vec![",
            "                    Some(\"capture1\".to_string()),",
            "                    None,",
            "                    Some(\"capture2\".to_string()),",
            "                ],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![",
            "                    Some(\"capture1\".to_string()),",
            "                    None,",
            "                    Some(\"capture2\".to_string()),",
            "                ],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures: vec![Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string()),], }, dfa: Program { captures: vec![Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string()),], }, dfa_reverse: Program { captures: vec![Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string()),], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.capture_names(), &[Some(\"capture1\".to_string()), None, Some(\"capture2\".to_string())]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let captures: Vec<Option<String>> = (0..1000).map(|i| {",
          "        if i % 2 == 0 {",
          "            Some(format!(\"capture{}\", i))",
          "        } else {",
          "            None",
          "        }",
          "    }).collect();",
          "    ",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"test\".to_string()],",
          "            nfa: Program {",
          "                captures,",
          "            },",
          "            dfa: Program {",
          "                captures: vec![],",
          "            },",
          "            dfa_reverse: Program {",
          "                captures: vec![],",
          "            },",
          "            suffixes: LiteralSearcher::new(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.capture_names();",
          "}"
        ],
        "oracles": [
          [
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result.len(), 1000);"
          ],
          [
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[0], Some(\"capture0\".to_string()));"
          ],
          [
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[1], None);"
          ],
          [
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[2], Some(\"capture2\".to_string()));"
          ],
          [
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[999], None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| {",
            "        if i % 2 == 0 {",
            "            Some(format!(\"capture{}\", i))",
            "        } else {",
            "            None",
            "        }",
            "    }).collect();",
            "    ",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures,",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result.len(), 1000);",
            "}"
          ],
          [
            "{",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| {",
            "        if i % 2 == 0 {",
            "            Some(format!(\"capture{}\", i))",
            "        } else {",
            "            None",
            "        }",
            "    }).collect();",
            "    ",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures,",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[0], Some(\"capture0\".to_string()));",
            "}"
          ],
          [
            "{",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| {",
            "        if i % 2 == 0 {",
            "            Some(format!(\"capture{}\", i))",
            "        } else {",
            "            None",
            "        }",
            "    }).collect();",
            "    ",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures,",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[1], None);",
            "}"
          ],
          [
            "{",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| {",
            "        if i % 2 == 0 {",
            "            Some(format!(\"capture{}\", i))",
            "        } else {",
            "            None",
            "        }",
            "    }).collect();",
            "    ",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures,",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[2], Some(\"capture2\".to_string()));",
            "}"
          ],
          [
            "{",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| {",
            "        if i % 2 == 0 {",
            "            Some(format!(\"capture{}\", i))",
            "        } else {",
            "            None",
            "        }",
            "    }).collect();",
            "    ",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"test\".to_string()],",
            "            nfa: Program {",
            "                captures,",
            "            },",
            "            dfa: Program {",
            "                captures: vec![],",
            "            },",
            "            dfa_reverse: Program {",
            "                captures: vec![],",
            "            },",
            "            suffixes: LiteralSearcher::new(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.capture_names();",
            "    let captures: Vec<Option<String>> = (0..1000).map(|i| { if i % 2 == 0 { Some(format!(\"capture{}\", i)) } else { None } }).collect();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"test\".to_string()], nfa: Program { captures, }, dfa: Program { captures: vec![], }, dfa_reverse: Program { captures: vec![], }, suffixes: LiteralSearcher::new(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.capture_names();",
            "    assert_eq!(result[999], None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]