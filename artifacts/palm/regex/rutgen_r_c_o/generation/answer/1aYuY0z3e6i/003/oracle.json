[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let utf8_range: Vec<Utf8Range> = vec![];",
          "    let _ = compiler.c_utf8_seq_(&utf8_range);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.insts.len(), 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.suffix_cache.version, 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.byte_classes.0.iter().filter(|&&x| x).count(), 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(matches!(result.unwrap().hole, Hole::None));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(result.unwrap().entry, ::std::usize::MAX);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.insts.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.suffix_cache.version, 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.byte_classes.0.iter().filter(|&&x| x).count(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(matches!(result.unwrap().hole, Hole::None));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range: Vec<Utf8Range> = vec![];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(result.unwrap().entry, ::std::usize::MAX);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
          "    let _ = compiler.c_utf8_seq_(&utf8_range);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(patch.entry < ::std::usize::MAX);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 0 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(patch.entry < ::std::usize::MAX);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
          "    let _ = compiler.c_utf8_seq_(&utf8_range);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    assert!(compiler.c.suffix_cache.get(key, pc).is_some());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    compiler.c.byte_classes.set_range(1, 1);",
            "    assert_eq!(compiler.c.insts.len() > 0, true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    compiler.c.byte_classes.set_range(1, 1);",
            "    assert_ne!(from_inst, ::std::usize::MAX);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    compiler.c.byte_classes.set_range(1, 1);",
            "    assert!(from_inst < ::std::usize::MAX);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    assert!(compiler.c.suffix_cache.get(key, pc).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    compiler.c.byte_classes.set_range(1, 1);",
            "    assert_eq!(compiler.c.insts.len() > 0, true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    compiler.c.byte_classes.set_range(1, 1);",
            "    assert_ne!(from_inst, ::std::usize::MAX);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 1, end: 1 }];",
            "    let mut from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let key = SuffixCacheKey { from_inst: from_inst, start: 1, end: 1 };",
            "    let pc = compiler.c.insts.len();",
            "    compiler.c.byte_classes.set_range(1, 1);",
            "    assert!(from_inst < ::std::usize::MAX);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
          "    let _ = compiler.c_utf8_seq_(&utf8_range);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.c.insts.len(), expected_length);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.c.suffix_cache.version, 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(matches!(result.unwrap().hole, Hole::None));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[0] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[1] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[2] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[3] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.insts.last().is_some());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.insts.len() > 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.insts.len() < std::usize::MAX);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.suffix_cache.table.len() == 1000);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.c.insts.len(), expected_length);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert_eq!(compiler.c.suffix_cache.version, 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(matches!(result.unwrap().hole, Hole::None));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[0] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[1] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[2] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.byte_classes.0[3] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.insts.last().is_some());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.insts.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.insts.len() < std::usize::MAX);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 1 }, Utf8Range { start: 2, end: 3 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(compiler.c.suffix_cache.table.len() == 1000);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
          "    let _ = compiler.c_utf8_seq_(&utf8_range);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::None));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(patch.entry < ::std::usize::MAX);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(compiler.c.insts.len() > 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(compiler.c.suffix_cache.version == 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::None));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(patch.entry < ::std::usize::MAX);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(compiler.c.insts.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 100, end: 200 }, Utf8Range { start: 150, end: 250 }];",
            "    let result = compiler.c_utf8_seq_(&utf8_range);",
            "    let patch = result.unwrap();",
            "    assert!(compiler.c.suffix_cache.version == 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
          "    let _ = compiler.c_utf8_seq_(&utf8_range);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert!(cached_pc);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert_eq!(self.c.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert_eq!(from_inst, ::std::usize::MAX);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert!(from_inst < ::std::usize::MAX);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert!(cached_pc);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert_eq!(self.c.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert_eq!(from_inst, ::std::usize::MAX);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let _ = compiler.c_utf8_seq_(&utf8_range);",
            "    let mut compiler = Compiler::new();",
            "    let utf8_range = vec![Utf8Range { start: 0, end: 255 }];",
            "    let from_inst = ::std::usize::MAX;",
            "    let last_hole = Hole::None;",
            "    let cached_pc = self.c.suffix_cache.get(key, pc).is_some();",
            "    assert!(from_inst < ::std::usize::MAX);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]