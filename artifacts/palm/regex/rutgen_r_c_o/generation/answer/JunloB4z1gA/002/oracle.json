[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let class_set = ClassBracketed {",
          "        span,",
          "        negated: false,",
          "        kind: ClassSet::Normal,",
          "    };",
          "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let class_set = ClassBracketed { span, negated: false, kind: ClassSet::Normal };",
            "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
            "    assert_eq!(item.span(), &class_set.span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let class_set = ClassBracketed {",
            "        span,",
            "        negated: false,",
            "        kind: ClassSet::Normal,",
            "    };",
            "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let class_set = ClassBracketed { span, negated: false, kind: ClassSet::Normal };",
            "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
            "    assert_eq!(item.span(), &class_set.span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let class_set = ClassBracketed {",
          "        span,",
          "        negated: true,",
          "        kind: ClassSet::Normal,",
          "    };",
          "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let class_set = ClassBracketed {",
            "    span,",
            "    negated: true,",
            "    kind: ClassSet::Normal,",
            "    };",
            "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
            "    let result = item.span();",
            "    assert_eq!(result, &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let class_set = ClassBracketed {",
            "        span,",
            "        negated: true,",
            "        kind: ClassSet::Normal,",
            "    };",
            "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let class_set = ClassBracketed {",
            "    span,",
            "    negated: true,",
            "    kind: ClassSet::Normal,",
            "    };",
            "    let item = ClassSetItem::Bracketed(Box::new(class_set));",
            "    let result = item.span();",
            "    assert_eq!(result, &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let item = ClassSetItem::Empty(span);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let item = ClassSetItem::Empty(span);",
            "    assert_eq!(item.span(), &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let item = ClassSetItem::Empty(span);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let item = ClassSetItem::Empty(span);",
            "    assert_eq!(item.span(), &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let literal = Literal {",
          "        span,",
          "        kind: LiteralKind::Unicode,",
          "        c: 'a',",
          "    };",
          "    let item = ClassSetItem::Literal(literal);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(1) };",
            "    let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };",
            "    let item = ClassSetItem::Literal(literal);",
            "    assert_eq!(item.span(), &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(1) };",
            "    let literal = Literal {",
            "        span,",
            "        kind: LiteralKind::Unicode,",
            "        c: 'a',",
            "    };",
            "    let item = ClassSetItem::Literal(literal);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(1) };",
            "    let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };",
            "    let item = ClassSetItem::Literal(literal);",
            "    assert_eq!(item.span(), &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let start_literal = Literal {",
          "        span: Span { start: Position(0), end: Position(1) },",
          "        kind: LiteralKind::Unicode,",
          "        c: 'a',",
          "    };",
          "    let end_literal = Literal {",
          "        span: Span { start: Position(1), end: Position(2) },",
          "        kind: LiteralKind::Unicode,",
          "        c: 'z',",
          "    };",
          "    let range = ClassSetRange {",
          "        span,",
          "        start: start_literal,",
          "        end: end_literal,",
          "    };",
          "    let item = ClassSetItem::Range(range);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Unicode, c: 'a' };",
            "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode, c: 'z' };",
            "    let range = ClassSetRange { span, start: start_literal, end: end_literal };",
            "    let item = ClassSetItem::Range(range);",
            "    assert_eq!(item.span(), &span);"
          ],
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Unicode, c: 'a' };",
            "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode, c: 'z' };",
            "    let range = ClassSetRange { span, start: start_literal, end: end_literal };",
            "    let item = ClassSetItem::Range(range);",
            "    assert_eq!(item.span().start, Position(0));"
          ],
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Unicode, c: 'a' };",
            "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode, c: 'z' };",
            "    let range = ClassSetRange { span, start: start_literal, end: end_literal };",
            "    let item = ClassSetItem::Range(range);",
            "    assert_eq!(item.span().end, Position(10));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal {",
            "        span: Span { start: Position(0), end: Position(1) },",
            "        kind: LiteralKind::Unicode,",
            "        c: 'a',",
            "    };",
            "    let end_literal = Literal {",
            "        span: Span { start: Position(1), end: Position(2) },",
            "        kind: LiteralKind::Unicode,",
            "        c: 'z',",
            "    };",
            "    let range = ClassSetRange {",
            "        span,",
            "        start: start_literal,",
            "        end: end_literal,",
            "    };",
            "    let item = ClassSetItem::Range(range);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Unicode, c: 'a' };",
            "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode, c: 'z' };",
            "    let range = ClassSetRange { span, start: start_literal, end: end_literal };",
            "    let item = ClassSetItem::Range(range);",
            "    assert_eq!(item.span(), &span);",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal {",
            "        span: Span { start: Position(0), end: Position(1) },",
            "        kind: LiteralKind::Unicode,",
            "        c: 'a',",
            "    };",
            "    let end_literal = Literal {",
            "        span: Span { start: Position(1), end: Position(2) },",
            "        kind: LiteralKind::Unicode,",
            "        c: 'z',",
            "    };",
            "    let range = ClassSetRange {",
            "        span,",
            "        start: start_literal,",
            "        end: end_literal,",
            "    };",
            "    let item = ClassSetItem::Range(range);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Unicode, c: 'a' };",
            "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode, c: 'z' };",
            "    let range = ClassSetRange { span, start: start_literal, end: end_literal };",
            "    let item = ClassSetItem::Range(range);",
            "    assert_eq!(item.span().start, Position(0));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal {",
            "        span: Span { start: Position(0), end: Position(1) },",
            "        kind: LiteralKind::Unicode,",
            "        c: 'a',",
            "    };",
            "    let end_literal = Literal {",
            "        span: Span { start: Position(1), end: Position(2) },",
            "        kind: LiteralKind::Unicode,",
            "        c: 'z',",
            "    };",
            "    let range = ClassSetRange {",
            "        span,",
            "        start: start_literal,",
            "        end: end_literal,",
            "    };",
            "    let item = ClassSetItem::Range(range);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Unicode, c: 'a' };",
            "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Unicode, c: 'z' };",
            "    let range = ClassSetRange { span, start: start_literal, end: end_literal };",
            "    let item = ClassSetItem::Range(range);",
            "    assert_eq!(item.span().end, Position(10));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let ascii_class = ClassAscii {",
          "        span,",
          "        kind: ClassAsciiKind::Alnum,",
          "        negated: false,",
          "    };",
          "    let item = ClassSetItem::Ascii(ascii_class);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let ascii_class = ClassAscii { span, kind: ClassAsciiKind::Alnum, negated: false };",
            "    let item = ClassSetItem::Ascii(ascii_class);",
            "    assert_eq!(item.span(), &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let ascii_class = ClassAscii {",
            "        span,",
            "        kind: ClassAsciiKind::Alnum,",
            "        negated: false,",
            "    };",
            "    let item = ClassSetItem::Ascii(ascii_class);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let ascii_class = ClassAscii { span, kind: ClassAsciiKind::Alnum, negated: false };",
            "    let item = ClassSetItem::Ascii(ascii_class);",
            "    assert_eq!(item.span(), &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let unicode_class = ClassUnicode {",
          "        span,",
          "        negated: false,",
          "        kind: ClassUnicodeKind::Uppercase,",
          "    };",
          "    let item = ClassSetItem::Unicode(unicode_class);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let unicode_class = ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Uppercase };",
            "    let item = ClassSetItem::Unicode(unicode_class);",
            "    assert_eq!(item.span(), &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let unicode_class = ClassUnicode {",
            "        span,",
            "        negated: false,",
            "        kind: ClassUnicodeKind::Uppercase,",
            "    };",
            "    let item = ClassSetItem::Unicode(unicode_class);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let unicode_class = ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Uppercase };",
            "    let item = ClassSetItem::Unicode(unicode_class);",
            "    assert_eq!(item.span(), &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let perl_class = ClassPerl {",
          "        span,",
          "        kind: ClassPerlKind::Digit,",
          "        negated: false,",
          "    };",
          "    let item = ClassSetItem::Perl(perl_class);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let perl_class = ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
            "    let item = ClassSetItem::Perl(perl_class);",
            "    assert_eq!(item.span(), &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let perl_class = ClassPerl {",
            "        span,",
            "        kind: ClassPerlKind::Digit,",
            "        negated: false,",
            "    };",
            "    let item = ClassSetItem::Perl(perl_class);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let perl_class = ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
            "    let item = ClassSetItem::Perl(perl_class);",
            "    assert_eq!(item.span(), &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position(0), end: Position(10) };",
          "    let union = ClassSetUnion {",
          "        span,",
          "        items: vec![],",
          "    };",
          "    let item = ClassSetItem::Union(union);",
          "    let _ = item.span();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let union = ClassSetUnion { span, items: vec![] };",
            "    let item = ClassSetItem::Union(union);",
            "    let result = item.span();",
            "    assert_eq!(result, &span);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let union = ClassSetUnion {",
            "        span,",
            "        items: vec![],",
            "    };",
            "    let item = ClassSetItem::Union(union);",
            "    let _ = item.span();",
            "    let span = Span { start: Position(0), end: Position(10) };",
            "    let union = ClassSetUnion { span, items: vec![] };",
            "    let item = ClassSetItem::Union(union);",
            "    let result = item.span();",
            "    assert_eq!(result, &span);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]