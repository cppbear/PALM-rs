[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
          "    let span = Span::new(start_pos, end_pos);",
          "    ",
          "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
          "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
          "    ",
          "    let prim1 = Primitive::Literal(lit1);",
          "    let prim2 = Primitive::Literal(lit2);",
          "    ",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 50,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    ",
          "    let parser_instance = ParserI { parser: &parser, pattern: \"a-b\" };",
          "    ",
          "    parser_instance.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange { span: Span::new(prim1.span().start, prim2.span().end), start: prim1.into_class_literal(&parser_instance).unwrap(), end: prim2.into_class_literal(&parser_instance).unwrap() };",
            "    assert_eq!(range.is_valid(), true);"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange { span: Span::new(prim1.span().start, prim2.span().end), start: prim1.into_class_literal(&parser_instance).unwrap(), end: prim2.into_class_literal(&parser_instance).unwrap() };",
            "    let class_set_item = parser_instance.parse_set_class_range();",
            "    assert!(class_set_item.is_ok());"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange { span: Span::new(prim1.span().start, prim2.span().end), start: prim1.into_class_literal(&parser_instance).unwrap(), end: prim2.into_class_literal(&parser_instance).unwrap() };",
            "    let class_set_item = parser_instance.parse_set_class_range();",
            "    assert_eq!(class_set_item.unwrap(), ast::ClassSetItem::Range(range));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange { span: Span::new(prim1.span().start, prim2.span().end), start: prim1.into_class_literal(&parser_instance).unwrap(), end: prim2.into_class_literal(&parser_instance).unwrap() };",
            "    assert_eq!(range.is_valid(), true);",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange { span: Span::new(prim1.span().start, prim2.span().end), start: prim1.into_class_literal(&parser_instance).unwrap(), end: prim2.into_class_literal(&parser_instance).unwrap() };",
            "    let class_set_item = parser_instance.parse_set_class_range();",
            "    assert!(class_set_item.is_ok());",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange { span: Span::new(prim1.span().start, prim2.span().end), start: prim1.into_class_literal(&parser_instance).unwrap(), end: prim2.into_class_literal(&parser_instance).unwrap() };",
            "    let class_set_item = parser_instance.parse_set_class_range();",
            "    assert_eq!(class_set_item.unwrap(), ast::ClassSetItem::Range(range));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
          "    let span_prim1 = Span::new(start_pos, end_pos);",
          "    ",
          "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
          "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
          "    ",
          "    let prim1 = Primitive::Literal(lit1);",
          "    let prim2 = Primitive::Literal(lit2);",
          "    ",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(1),",
          "        nest_limit: 75,",
          "        octal: true,",
          "        initial_ignore_whitespace: true,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![ast::Comment::new()]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    ",
          "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
          "    ",
          "    parser_instance.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.parse_set_class_item(), Ok(prim1));"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.bump_space(), ());"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert!(!parser_instance.is_eof());"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.char(), '-');"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_ne!(parser_instance.peek_space(), Some(']'));"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.peek_space(), Some('-'));"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(span_prim1.start, span_prim2.end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert!(range.is_valid());"
          ],
          [
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(span_prim1.start, span_prim2.end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.parse_set_class_range(), Ok(ast::ClassSetItem::Range(range)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.parse_set_class_item(), Ok(prim1));",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.bump_space(), ());",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert!(!parser_instance.is_eof());",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.char(), '-');",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_ne!(parser_instance.peek_space(), Some(']'));",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    assert_eq!(parser_instance.peek_space(), Some('-'));",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(span_prim1.start, span_prim2.end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert!(range.is_valid());",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(1),",
            "        nest_limit: 75,",
            "        octal: true,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![ast::Comment::new()]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"c-d\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let span_prim1 = Span::new(start_pos, end_pos);",
            "    let span_prim2 = Span::new(end_pos, Position { offset: 2, line: 1, column: 3 });",
            "    let lit1 = Literal { span: span_prim1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' };",
            "    let lit2 = Literal { span: span_prim2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2;",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(span_prim1.start, span_prim2.end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.parse_set_class_range(), Ok(ast::ClassSetItem::Range(range)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
          "    let span = Span::new(start_pos, end_pos);",
          "    ",
          "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
          "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
          "    ",
          "    let prim1 = Primitive::Literal(lit1);",
          "    let prim2 = Primitive::Literal(lit2); // This should lead to an invalid range due to ordering.",
          "    ",
          "    let mut parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 100,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    ",
          "    let parser_instance = ParserI { parser: &parser, pattern: \"x-y\" };",
          "    ",
          "    parser_instance.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(range.is_valid(), false);"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.parse_set_class_range().unwrap_err().kind, ast::ErrorKind::ClassRangeInvalid);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2); // This should lead to an invalid range due to ordering.",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 100,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"x-y\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(range.is_valid(), false);",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    ",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
            "    ",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2); // This should lead to an invalid range due to ordering.",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 100,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"x-y\" };",
            "    ",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "    let span = Span::new(start_pos, end_pos);",
            "    let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'x' };",
            "    let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: 'y' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    let prim2 = Primitive::Literal(lit2);",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.parse_set_class_range().unwrap_err().kind, ast::ErrorKind::ClassRangeInvalid);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    ",
          "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
          "",
          "    let prim1 = Primitive::Literal(lit1);",
          "    ",
          "    let mut parser = Parser {",
          "        pos: Cell::new(start_pos),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 50,",
          "        octal: false,",
          "        initial_ignore_whitespace: false,",
          "        ignore_whitespace: Cell::new(false),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::new()),",
          "    };",
          "    ",
          "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
          "    ",
          "    // Triggering eof condition directly",
          "    parser_instance.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert_eq!(prim1.span(), &Span::new(start_pos, start_pos));"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.is_eof() == false);"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.char() == '-');"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.peek_space() == Some('-'));"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.bump_and_bump_space() == true);"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(prim1.into_class_literal(&parser_instance).is_ok());"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(prim1.into_class_set_item(&parser_instance).is_ok());"
          ],
          [
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.parse_set_class_item().is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert_eq!(prim1.span(), &Span::new(start_pos, start_pos));",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.char() == '-');",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.peek_space() == Some('-'));",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.bump_and_bump_space() == true);",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(prim1.into_class_literal(&parser_instance).is_ok());",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(prim1.into_class_set_item(&parser_instance).is_ok());",
            "}"
          ],
          [
            "{",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    ",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "",
            "    let prim1 = Primitive::Literal(lit1);",
            "    ",
            "    let mut parser = Parser {",
            "        pos: Cell::new(start_pos),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 50,",
            "        octal: false,",
            "        initial_ignore_whitespace: false,",
            "        ignore_whitespace: Cell::new(false),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::new()),",
            "    };",
            "    ",
            "    let parser_instance = ParserI { parser: &parser, pattern: \"p-\" };",
            "    ",
            "    // Triggering eof condition directly",
            "    parser_instance.parse_set_class_range();",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let lit1 = Literal { span: Span::new(start_pos, start_pos), kind: ast::LiteralKind::Verbatim, c: 'p' };",
            "    let prim1 = Primitive::Literal(lit1);",
            "    assert!(parser_instance.parse_set_class_item().is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let test_cases = vec![",
          "        ('e', 'f'),",
          "        ('g', 'h'),",
          "        ('i', 'j'),",
          "    ];",
          "",
          "    for (start_char, end_char) in test_cases {",
          "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
          "        let span = Span::new(start_pos, end_pos);",
          "        ",
          "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
          "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
          "",
          "        let prim1 = Primitive::Literal(lit1);",
          "        let prim2 = Primitive::Literal(lit2);",
          "        ",
          "        let mut parser = Parser {",
          "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 50,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        };",
          "",
          "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
          "",
          "        parser_instance.parse_set_class_range();",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(range.start.c, start_char);"
          ],
          [
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(range.end.c, end_char);"
          ],
          [
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert!(range.is_valid());"
          ],
          [
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.pattern, &format!(\"{}-{}\", start_char, end_char));"
          ],
          [
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert!(!parser_instance.is_eof());"
          ],
          [
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.peek_space(), Some('-'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let test_cases = vec![",
            "        ('e', 'f'),",
            "        ('g', 'h'),",
            "        ('i', 'j'),",
            "    ];",
            "",
            "    for (start_char, end_char) in test_cases {",
            "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "        let span = Span::new(start_pos, end_pos);",
            "        ",
            "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
            "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
            "",
            "        let prim1 = Primitive::Literal(lit1);",
            "        let prim2 = Primitive::Literal(lit2);",
            "        ",
            "        let mut parser = Parser {",
            "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "            capture_index: Cell::new(0),",
            "            nest_limit: 50,",
            "            octal: false,",
            "            initial_ignore_whitespace: false,",
            "            ignore_whitespace: Cell::new(false),",
            "            comments: RefCell::new(vec![]),",
            "            stack_group: RefCell::new(vec![]),",
            "            stack_class: RefCell::new(vec![]),",
            "            capture_names: RefCell::new(vec![]),",
            "            scratch: RefCell::new(String::new()),",
            "        };",
            "",
            "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
            "",
            "        parser_instance.parse_set_class_range();",
            "    }",
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(range.start.c, start_char);",
            "}"
          ],
          [
            "{",
            "    let test_cases = vec![",
            "        ('e', 'f'),",
            "        ('g', 'h'),",
            "        ('i', 'j'),",
            "    ];",
            "",
            "    for (start_char, end_char) in test_cases {",
            "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "        let span = Span::new(start_pos, end_pos);",
            "        ",
            "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
            "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
            "",
            "        let prim1 = Primitive::Literal(lit1);",
            "        let prim2 = Primitive::Literal(lit2);",
            "        ",
            "        let mut parser = Parser {",
            "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "            capture_index: Cell::new(0),",
            "            nest_limit: 50,",
            "            octal: false,",
            "            initial_ignore_whitespace: false,",
            "            ignore_whitespace: Cell::new(false),",
            "            comments: RefCell::new(vec![]),",
            "            stack_group: RefCell::new(vec![]),",
            "            stack_class: RefCell::new(vec![]),",
            "            capture_names: RefCell::new(vec![]),",
            "            scratch: RefCell::new(String::new()),",
            "        };",
            "",
            "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
            "",
            "        parser_instance.parse_set_class_range();",
            "    }",
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(range.end.c, end_char);",
            "}"
          ],
          [
            "{",
            "    let test_cases = vec![",
            "        ('e', 'f'),",
            "        ('g', 'h'),",
            "        ('i', 'j'),",
            "    ];",
            "",
            "    for (start_char, end_char) in test_cases {",
            "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "        let span = Span::new(start_pos, end_pos);",
            "        ",
            "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
            "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
            "",
            "        let prim1 = Primitive::Literal(lit1);",
            "        let prim2 = Primitive::Literal(lit2);",
            "        ",
            "        let mut parser = Parser {",
            "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "            capture_index: Cell::new(0),",
            "            nest_limit: 50,",
            "            octal: false,",
            "            initial_ignore_whitespace: false,",
            "            ignore_whitespace: Cell::new(false),",
            "            comments: RefCell::new(vec![]),",
            "            stack_group: RefCell::new(vec![]),",
            "            stack_class: RefCell::new(vec![]),",
            "            capture_names: RefCell::new(vec![]),",
            "            scratch: RefCell::new(String::new()),",
            "        };",
            "",
            "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
            "",
            "        parser_instance.parse_set_class_range();",
            "    }",
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert!(range.is_valid());",
            "}"
          ],
          [
            "{",
            "    let test_cases = vec![",
            "        ('e', 'f'),",
            "        ('g', 'h'),",
            "        ('i', 'j'),",
            "    ];",
            "",
            "    for (start_char, end_char) in test_cases {",
            "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "        let span = Span::new(start_pos, end_pos);",
            "        ",
            "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
            "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
            "",
            "        let prim1 = Primitive::Literal(lit1);",
            "        let prim2 = Primitive::Literal(lit2);",
            "        ",
            "        let mut parser = Parser {",
            "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "            capture_index: Cell::new(0),",
            "            nest_limit: 50,",
            "            octal: false,",
            "            initial_ignore_whitespace: false,",
            "            ignore_whitespace: Cell::new(false),",
            "            comments: RefCell::new(vec![]),",
            "            stack_group: RefCell::new(vec![]),",
            "            stack_class: RefCell::new(vec![]),",
            "            capture_names: RefCell::new(vec![]),",
            "            scratch: RefCell::new(String::new()),",
            "        };",
            "",
            "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
            "",
            "        parser_instance.parse_set_class_range();",
            "    }",
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.pattern, &format!(\"{}-{}\", start_char, end_char));",
            "}"
          ],
          [
            "{",
            "    let test_cases = vec![",
            "        ('e', 'f'),",
            "        ('g', 'h'),",
            "        ('i', 'j'),",
            "    ];",
            "",
            "    for (start_char, end_char) in test_cases {",
            "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "        let span = Span::new(start_pos, end_pos);",
            "        ",
            "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
            "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
            "",
            "        let prim1 = Primitive::Literal(lit1);",
            "        let prim2 = Primitive::Literal(lit2);",
            "        ",
            "        let mut parser = Parser {",
            "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "            capture_index: Cell::new(0),",
            "            nest_limit: 50,",
            "            octal: false,",
            "            initial_ignore_whitespace: false,",
            "            ignore_whitespace: Cell::new(false),",
            "            comments: RefCell::new(vec![]),",
            "            stack_group: RefCell::new(vec![]),",
            "            stack_class: RefCell::new(vec![]),",
            "            capture_names: RefCell::new(vec![]),",
            "            scratch: RefCell::new(String::new()),",
            "        };",
            "",
            "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
            "",
            "        parser_instance.parse_set_class_range();",
            "    }",
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert!(!parser_instance.is_eof());",
            "}"
          ],
          [
            "{",
            "    let test_cases = vec![",
            "        ('e', 'f'),",
            "        ('g', 'h'),",
            "        ('i', 'j'),",
            "    ];",
            "",
            "    for (start_char, end_char) in test_cases {",
            "        let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "        let end_pos = Position { offset: 1, line: 1, column: 2 };",
            "        let span = Span::new(start_pos, end_pos);",
            "        ",
            "        let lit1 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: start_char };",
            "        let lit2 = Literal { span: span.clone(), kind: ast::LiteralKind::Verbatim, c: end_char };",
            "",
            "        let prim1 = Primitive::Literal(lit1);",
            "        let prim2 = Primitive::Literal(lit2);",
            "        ",
            "        let mut parser = Parser {",
            "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "            capture_index: Cell::new(0),",
            "            nest_limit: 50,",
            "            octal: false,",
            "            initial_ignore_whitespace: false,",
            "            ignore_whitespace: Cell::new(false),",
            "            comments: RefCell::new(vec![]),",
            "            stack_group: RefCell::new(vec![]),",
            "            stack_class: RefCell::new(vec![]),",
            "            capture_names: RefCell::new(vec![]),",
            "            scratch: RefCell::new(String::new()),",
            "        };",
            "",
            "        let parser_instance = ParserI { parser: &parser, pattern: &format!(\"{}-{}\", start_char, end_char) };",
            "",
            "        parser_instance.parse_set_class_range();",
            "    }",
            "    let prim1 = parser_instance.parse_set_class_item().unwrap();",
            "    let range = ast::ClassSetRange {",
            "    span: Span::new(prim1.span().start, prim2.span().end),",
            "    start: prim1.into_class_literal(&parser_instance).unwrap(),",
            "    end: prim2.into_class_literal(&parser_instance).unwrap(),",
            "    };",
            "    assert_eq!(parser_instance.peek_space(), Some('-'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]