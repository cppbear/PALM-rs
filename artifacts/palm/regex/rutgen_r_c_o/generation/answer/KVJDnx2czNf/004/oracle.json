[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: syntax::hir::HirKind,",
          "    }",
          "",
          "    impl DummyHir {",
          "        fn new(kind: syntax::hir::HirKind) -> Self {",
          "            DummyHir { kind }",
          "        }",
          "",
          "        fn kind(&self) -> &syntax::hir::HirKind {",
          "            &self.kind",
          "        }",
          "    }",
          "",
          "    let mut compiler = Compiler::new();",
          "    compiler.num_exprs = 1;",
          "    compiler.compiled.is_dfa = false;",
          "",
          "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
          "    let first_slot = 1;",
          "",
          "    let _result = compiler.c_capture(first_slot, &expr);",
          "}"
        ],
        "oracles": [
          [
            "    let compiler = Compiler::new();",
            "    assert_eq!(compiler.num_exprs, 1);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    assert!(!compiler.compiled.is_dfa);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    assert_eq!(expr.kind().to_string(), \"Literal(Unicode('a'))\");"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch = result.unwrap();",
            "    assert!(patch.hole.is_some());"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let compiler = Compiler::new();",
            "    assert_eq!(compiler.num_exprs, 1);",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let compiler = Compiler::new();",
            "    assert!(!compiler.compiled.is_dfa);",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    assert_eq!(expr.kind().to_string(), \"Literal(Unicode('a'))\");",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch = result.unwrap();",
            "    assert!(patch.hole.is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let compiler = Compiler::new();",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Literal(syntax::hir::Literal::Unicode('a')));",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: syntax::hir::HirKind,",
          "    }",
          "",
          "    impl DummyHir {",
          "        fn new(kind: syntax::hir::HirKind) -> Self {",
          "            DummyHir { kind }",
          "        }",
          "",
          "        fn kind(&self) -> &syntax::hir::HirKind {",
          "            &self.kind",
          "        }",
          "    }",
          "",
          "    let mut compiler = Compiler::new();",
          "    compiler.num_exprs = 1;",
          "    compiler.compiled.is_dfa = false;",
          "",
          "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
          "    let first_slot = 1;",
          "",
          "    let _result = compiler.c_capture(first_slot, &expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch_result = result.unwrap();",
            "    assert!(patch_result.hole.is_some());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch_result = result.unwrap();",
            "    assert_eq!(patch_result.entry, compiler.insts.len() - 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch_result = result.unwrap();",
            "    assert!(patch_result.hole.is_some());",
            "}"
          ],
          [
            "{",
            "    struct DummyHir {",
            "        kind: syntax::hir::HirKind,",
            "    }",
            "",
            "    impl DummyHir {",
            "        fn new(kind: syntax::hir::HirKind) -> Self {",
            "            DummyHir { kind }",
            "        }",
            "",
            "        fn kind(&self) -> &syntax::hir::HirKind {",
            "            &self.kind",
            "        }",
            "    }",
            "",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "",
            "    let _result = compiler.c_capture(first_slot, &expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.num_exprs = 1;",
            "    compiler.compiled.is_dfa = false;",
            "    let expr = DummyHir::new(syntax::hir::HirKind::Empty);",
            "    let first_slot = 1;",
            "    let result = compiler.c_capture(first_slot, &expr);",
            "    let patch_result = result.unwrap();",
            "    assert_eq!(patch_result.entry, compiler.insts.len() - 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]