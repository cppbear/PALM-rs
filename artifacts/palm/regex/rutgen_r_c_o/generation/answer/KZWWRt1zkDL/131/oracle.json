[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\u\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser::new(\"\\\\u\", true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser::new(\"\\\\u\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\u\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\u\", true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\u\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\u\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\d\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Perl(_)));"
          ],
          [
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    let primitive = result.unwrap();",
            "    let perl_class = if let Primitive::Perl(cls) = primitive { cls } else { panic!() };",
            "    assert_eq!(perl_class.kind, ast::ClassPerlKind::Digit);"
          ],
          [
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    let primitive = result.unwrap();",
            "    let perl_class = if let Primitive::Perl(cls) = primitive { cls } else { panic!() };",
            "    assert!(!perl_class.negated);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\d\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\d\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Perl(_)));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\d\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    let primitive = result.unwrap();",
            "    let perl_class = if let Primitive::Perl(cls) = primitive { cls } else { panic!() };",
            "    assert_eq!(perl_class.kind, ast::ClassPerlKind::Digit);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\d\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\d\", true);",
            "    let primitive = result.unwrap();",
            "    let perl_class = if let Primitive::Perl(cls) = primitive { cls } else { panic!() };",
            "    assert!(!perl_class.negated);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\x\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start = parser.pos();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let start = parser.pos();",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Literal(ast::Literal {"
          ],
          [
            "    let start = parser.pos();",
            "    let primitive = result.unwrap();",
            "    span: Span::new(start, parser.pos()),",
            "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: // expected character for \\x",
            "    }));",
            "    let error_result = parser.parse_escape();",
            "    assert!(error_result.is_err());"
          ],
          [
            "    let start = parser.pos();",
            "    let primitive = result.unwrap();",
            "    span: Span::new(start, parser.pos()),",
            "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: // expected character for \\x",
            "    }));",
            "    let error_result = parser.parse_escape();",
            "    assert_eq!(error_result.err().unwrap().kind, ast::ErrorKind::EscapeUnexpectedEof);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\x\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\x\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let start = parser.pos();",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Literal(ast::Literal {",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\x\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let start = parser.pos();",
            "    let primitive = result.unwrap();",
            "    span: Span::new(start, parser.pos()),",
            "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: // expected character for \\x",
            "    }));",
            "    let error_result = parser.parse_escape();",
            "    assert!(error_result.is_err());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\x\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let start = parser.pos();",
            "    let primitive = result.unwrap();",
            "    span: Span::new(start, parser.pos()),",
            "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
            "    c: // expected character for \\x",
            "    }));",
            "    let error_result = parser.parse_escape();",
            "    assert_eq!(error_result.err().unwrap().kind, ast::ErrorKind::EscapeUnexpectedEof);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\w\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\w\";",
            "    let parser = Parser::new(pattern, true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\w\";",
            "    let parser = Parser::new(pattern, true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Perl(ClassPerl { span: _, kind: ClassPerlKind::Word, negated: false }));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\w\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\w\";",
            "    let parser = Parser::new(pattern, true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\w\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\w\";",
            "    let parser = Parser::new(pattern, true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Perl(ClassPerl { span: _, kind: ClassPerlKind::Word, negated: false }));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\W\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\W\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\W\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    assert_eq!(result.unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position::new(0, 1, 1), Position::new(1, 1, 2)), kind: ast::ClassPerlKind::Word, negated: true }));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\W\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\W\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\W\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\W\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    assert_eq!(result.unwrap(), Primitive::Perl(ast::ClassPerl { span: Span::new(Position::new(0, 1, 1), Position::new(1, 1, 2)), kind: ast::ClassPerlKind::Word, negated: true }));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\P\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    assert!(matches!(primitive, Primitive::Unicode(_)));"
          ],
          [
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    }",
            "    assert_eq!(parser.pos().offset, 2);"
          ],
          [
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    }",
            "    assert_eq!(parser.parser().scratch.borrow().len(), 0);"
          ],
          [
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    }",
            "    assert!(parser.comments.borrow().is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    assert!(matches!(primitive, Primitive::Unicode(_)));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    }",
            "    assert_eq!(parser.pos().offset, 2);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    }",
            "    assert_eq!(parser.parser().scratch.borrow().len(), 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let pattern = \"\\\\P\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    if let Ok(primitive) = result {",
            "    }",
            "    assert!(parser.comments.borrow().is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\s\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser::new(\"\\\\s\", true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser::new(\"\\\\s\", true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Perl(ast::ClassPerl { span: ..., kind: ast::ClassPerlKind::Space, negated: false }));"
          ],
          [
            "    let parser = Parser::new(\"\\\\s\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(primitive.span.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\s\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\s\", true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\s\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\s\", true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Perl(ast::ClassPerl { span: ..., kind: ast::ClassPerlKind::Space, negated: false }));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\s\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\s\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(primitive.span.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\S\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Perl(_)));"
          ],
          [
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert_eq!(parser.pos().offset, 2);"
          ],
          [
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert_eq!(parser.capture_index.get(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\S\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\S\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Perl(_)));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\S\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert_eq!(parser.pos().offset, 2);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\S\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\S\", true);",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert_eq!(parser.capture_index.get(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\p\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Unicode(ast::ClassUnicode { negated: false, kind: ast::ClassUnicodeKind::Named(\"\".to_string()), span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }) }));"
          ],
          [
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(parser.pos.get().offset, 2);"
          ],
          [
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(parser.bump());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\p\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\p\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(primitive, Primitive::Unicode(ast::ClassUnicode { negated: false, kind: ast::ClassUnicodeKind::Named(\"\".to_string()), span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }) }));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\p\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    let primitive = result.unwrap();",
            "    assert_eq!(parser.pos.get().offset, 2);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\p\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\p\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(parser.bump());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let parser = Parser::new(pattern, true);",
          "    let result = parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser::new(\"\\\\v\", true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser::new(\"\\\\v\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(ref lit) if lit.kind == ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\v\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\v\", true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\v\";",
            "    let parser = Parser::new(pattern, true);",
            "    let result = parser.parse_escape();",
            "    let parser = Parser::new(\"\\\\v\", true);",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(ref lit) if lit.kind == ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]