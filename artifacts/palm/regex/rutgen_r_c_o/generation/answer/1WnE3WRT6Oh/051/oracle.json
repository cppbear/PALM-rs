[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: true,",
          "        ignore_whitespace: Cell::new(true),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::from(\"    123   \")),",
          "    };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
          "    parser_i.parse_decimal();",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    assert!(scratch.is_empty());"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 4, line: 1, column: 5 });"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_digit(10));"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.char(), '1');"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 5, line: 1, column: 6 });"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_digit(10));"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.char(), '2');"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 6, line: 1, column: 7 });"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_digit(10));"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.char(), '3');"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_whitespace());"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 7, line: 1, column: 8 });"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    assert!(!digits.is_empty());"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    assert_eq!(digits, \"123\");"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::DecimalInvalid);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    assert!(scratch.is_empty());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 4, line: 1, column: 5 });",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_digit(10));",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.char(), '1');",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 5, line: 1, column: 6 });",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_digit(10));",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.char(), '2');",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 6, line: 1, column: 7 });",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_digit(10));",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.char(), '3');",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert!(parser_i.char().is_whitespace());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    assert_eq!(parser_i.pos(), Position { offset: 7, line: 1, column: 8 });",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    assert!(!digits.is_empty());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    assert_eq!(digits, \"123\");",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"    123   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"    123   \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser_i.parser.scratch.borrow_mut();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    parser_i.bump();",
            "    let digits = scratch.as_str();",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::DecimalInvalid);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: true,",
          "        ignore_whitespace: Cell::new(true),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::from(\"123    \")),",
          "    };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
          "    parser_i.parse_decimal();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap(), 123);"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::DecimalEmpty);"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"abc\")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"abc\")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::DecimalInvalid);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"123    \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"123    \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap(), 123);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"123    \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"123    \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::DecimalEmpty);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"123    \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"abc\")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"123    \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"123    \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"123    \")) };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"   \")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    let parser = Parser { scratch: RefCell::new(String::from(\"abc\")), ..parser };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::DecimalInvalid);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: true,",
          "        ignore_whitespace: Cell::new(true),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::from(\"   \")),",
          "    };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
          "    parser_i.parse_decimal();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"   \")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"   \")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::DecimalEmpty);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"   \")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"   \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"   \")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"   \" };",
            "    let result = parser_i.parse_decimal();",
            "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::DecimalEmpty);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: true,",
          "        ignore_whitespace: Cell::new(true),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::from(\"abc\")),",
          "    };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
          "    parser_i.parse_decimal();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    assert!(parser_i.parse_decimal().is_err());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    assert_eq!(parser_i.parse_decimal().unwrap_err().kind, ast::ErrorKind::DecimalInvalid);"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    assert_eq!(parser_i.parse_decimal().unwrap(), 1);"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    assert!(parser_i.parse_decimal().is_err());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    assert_eq!(parser_i.parse_decimal().unwrap_err().kind, ast::ErrorKind::DecimalEmpty);"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"1234\");",
            "    assert_eq!(parser_i.parse_decimal().unwrap(), 1234);"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"1234\");",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"12a34\");",
            "    assert!(parser_i.parse_decimal().is_err());"
          ],
          [
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"1234\");",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"12a34\");",
            "    assert_eq!(parser_i.parse_decimal().unwrap_err().kind, ast::ErrorKind::DecimalInvalid);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    assert!(parser_i.parse_decimal().is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    assert_eq!(parser_i.parse_decimal().unwrap_err().kind, ast::ErrorKind::DecimalInvalid);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    assert_eq!(parser_i.parse_decimal().unwrap(), 1);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    assert!(parser_i.parse_decimal().is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    assert_eq!(parser_i.parse_decimal().unwrap_err().kind, ast::ErrorKind::DecimalEmpty);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"1234\");",
            "    assert_eq!(parser_i.parse_decimal().unwrap(), 1234);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"1234\");",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"12a34\");",
            "    assert!(parser_i.parse_decimal().is_err());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"abc\")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    let parser = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: true, ignore_whitespace: Cell::new(true), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(\"abc\")), };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"abc\" };",
            "    parser_i.parse_decimal();",
            "    parser_i.parser.scratch.borrow_mut().push('1');",
            "    parser_i.parser.scratch.borrow_mut().clear();",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"1234\");",
            "    parser_i.parser.scratch.borrow_mut().extend_from_slice(b\"12a34\");",
            "    assert_eq!(parser_i.parse_decimal().unwrap_err().kind, ast::ErrorKind::DecimalInvalid);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = Parser {",
          "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
          "        capture_index: Cell::new(0),",
          "        nest_limit: 10,",
          "        octal: false,",
          "        initial_ignore_whitespace: true,",
          "        ignore_whitespace: Cell::new(true),",
          "        comments: RefCell::new(vec![]),",
          "        stack_group: RefCell::new(vec![]),",
          "        stack_class: RefCell::new(vec![]),",
          "        capture_names: RefCell::new(vec![]),",
          "        scratch: RefCell::new(String::from(\"  42  \")),",
          "    };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
          "    parser_i.parse_decimal();",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert_eq!(scratch.len(), 0);"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_false());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char().is_whitespace().is_true());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_true());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_false());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char() >= '0');"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char() <= '9');"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_true());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_false());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char().is_whitespace().is_true());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_true());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(digits.is_empty().is_false());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(u32::from_str_radix(digits, 10).ok().is_none());"
          ],
          [
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert_eq!(parse_decimal(), Err(parser.error(span, ast::ErrorKind::DecimalInvalid)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert_eq!(scratch.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_false());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char().is_whitespace().is_true());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_true());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_false());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char() >= '0');",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char() <= '9');",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_true());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_false());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.char().is_whitespace().is_true());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(parser.is_eof().is_true());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(digits.is_empty().is_false());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert!(u32::from_str_radix(digits, 10).ok().is_none());",
            "}"
          ],
          [
            "{",
            "    let parser = Parser {",
            "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
            "        capture_index: Cell::new(0),",
            "        nest_limit: 10,",
            "        octal: false,",
            "        initial_ignore_whitespace: true,",
            "        ignore_whitespace: Cell::new(true),",
            "        comments: RefCell::new(vec![]),",
            "        stack_group: RefCell::new(vec![]),",
            "        stack_class: RefCell::new(vec![]),",
            "        capture_names: RefCell::new(vec![]),",
            "        scratch: RefCell::new(String::from(\"  42  \")),",
            "    };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"  42  \" };",
            "    parser_i.parse_decimal();",
            "    let mut scratch = parser.scratch.borrow_mut();",
            "    assert_eq!(parse_decimal(), Err(parser.error(span, ast::ErrorKind::DecimalInvalid)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]