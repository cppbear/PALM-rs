[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 0),",
          "        items: Vec::new(),",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 0),",
            "    items: Vec::new(),",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result, ClassSet::Item(ClassSetItem::Union(ClassSetUnion {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 0),",
            "        items: Vec::new(),",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 0),",
            "    items: Vec::new(),",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result, ClassSet::Item(ClassSetItem::Union(ClassSetUnion {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 1),",
          "        items: vec![ClassSetItem::Literal(Literal::new('a'))],",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = union(ast);",
            "    assert_eq!(result, ClassSet::Item(ClassSetItem::Union(ast)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 1),",
            "        items: vec![ClassSetItem::Literal(Literal::new('a'))],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion { span: Span::new(0, 1), items: vec![ClassSetItem::Literal(Literal::new('a'))] };",
            "    let result = union(ast);",
            "    assert_eq!(result, ClassSet::Item(ClassSetItem::Union(ast)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 5),",
          "        items: vec![",
          "            ClassSetItem::Literal(Literal::new('b')),",
          "            ClassSetItem::Literal(Literal::new('c')),",
          "            ClassSetItem::Literal(Literal::new('d')),",
          "        ],",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.span, Span::new(0, 5));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items.len(), 3);"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items[0], ClassSetItem::Literal(Literal::new('b')));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items[1], ClassSetItem::Literal(Literal::new('c')));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items[2], ClassSetItem::Literal(Literal::new('d')));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 5),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('b')),",
            "            ClassSetItem::Literal(Literal::new('c')),",
            "            ClassSetItem::Literal(Literal::new('d')),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 5),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('b')),",
            "            ClassSetItem::Literal(Literal::new('c')),",
            "            ClassSetItem::Literal(Literal::new('d')),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.span, Span::new(0, 5));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 5),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('b')),",
            "            ClassSetItem::Literal(Literal::new('c')),",
            "            ClassSetItem::Literal(Literal::new('d')),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 5),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('b')),",
            "            ClassSetItem::Literal(Literal::new('c')),",
            "            ClassSetItem::Literal(Literal::new('d')),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items[0], ClassSetItem::Literal(Literal::new('b')));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 5),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('b')),",
            "            ClassSetItem::Literal(Literal::new('c')),",
            "            ClassSetItem::Literal(Literal::new('d')),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items[1], ClassSetItem::Literal(Literal::new('c')));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 5),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('b')),",
            "            ClassSetItem::Literal(Literal::new('c')),",
            "            ClassSetItem::Literal(Literal::new('d')),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 5),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('b')),",
            "    ClassSetItem::Literal(Literal::new('c')),",
            "    ClassSetItem::Literal(Literal::new('d')),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    let union_ast = if let ClassSet::Item(ClassSetItem::Union(ast)) = result { ast } else { panic!(); };",
            "    assert_eq!(union_ast.items[2], ClassSetItem::Literal(Literal::new('d')));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 3),",
          "        items: vec![ClassSetItem::Range(ClassSetRange::new(1, 5))],",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Range(ClassSetRange::new(1, 5))] };",
            "    let result = union(ast);",
            "    let expected = ClassSet::Item(ClassSetItem::Union(ast));",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 3),",
            "        items: vec![ClassSetItem::Range(ClassSetRange::new(1, 5))],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion { span: Span::new(0, 3), items: vec![ClassSetItem::Range(ClassSetRange::new(1, 5))] };",
            "    let result = union(ast);",
            "    let expected = ClassSet::Item(ClassSetItem::Union(ast));",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 10),",
          "        items: vec![",
          "            ClassSetItem::Range(ClassSetRange::new(1, 5)),",
          "            ClassSetItem::Range(ClassSetRange::new(6, 10)),",
          "        ],",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 10),",
            "    items: vec![",
            "    ClassSetItem::Range(ClassSetRange::new(1, 5)),",
            "    ClassSetItem::Range(ClassSetRange::new(6, 10)),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 10),",
            "    items: vec![",
            "    ClassSetItem::Range(ClassSetRange::new(1, 5)),",
            "    ClassSetItem::Range(ClassSetRange::new(6, 10)),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result.get_union_items(), vec![ClassSetItem::Range(ClassSetRange::new(1, 5)), ClassSetItem::Range(ClassSetRange::new(6, 10))]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 10),",
            "        items: vec![",
            "            ClassSetItem::Range(ClassSetRange::new(1, 5)),",
            "            ClassSetItem::Range(ClassSetRange::new(6, 10)),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 10),",
            "    items: vec![",
            "    ClassSetItem::Range(ClassSetRange::new(1, 5)),",
            "    ClassSetItem::Range(ClassSetRange::new(6, 10)),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 10),",
            "        items: vec![",
            "            ClassSetItem::Range(ClassSetRange::new(1, 5)),",
            "            ClassSetItem::Range(ClassSetRange::new(6, 10)),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 10),",
            "    items: vec![",
            "    ClassSetItem::Range(ClassSetRange::new(1, 5)),",
            "    ClassSetItem::Range(ClassSetRange::new(6, 10)),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result.get_union_items(), vec![ClassSetItem::Range(ClassSetRange::new(1, 5)), ClassSetItem::Range(ClassSetRange::new(6, 10))]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 4),",
          "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"alnum\"))],",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 4),",
            "    items: vec![ClassSetItem::Ascii(ClassAscii::new(\"alnum\"))],",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result, ClassSet::Item(ClassSetItem::Union(ClassSetUnion {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 4),",
            "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"alnum\"))],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 4),",
            "    items: vec![ClassSetItem::Ascii(ClassAscii::new(\"alnum\"))],",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result, ClassSet::Item(ClassSetItem::Union(ClassSetUnion {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 8),",
          "        items: vec![",
          "            ClassSetItem::Literal(Literal::new('e')),",
          "            ClassSetItem::Range(ClassSetRange::new(5, 10)),",
          "            ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
          "        ],",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 8),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('e')),",
            "    ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "    ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 8),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('e')),",
            "    ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "    ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result.span(), &Span::new(0, 8));"
          ],
          [
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 8),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('e')),",
            "    ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "    ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(result.is_empty() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 8),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('e')),",
            "            ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "            ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 8),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('e')),",
            "    ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "    ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 8),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('e')),",
            "            ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "            ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 8),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('e')),",
            "    ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "    ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert_eq!(result.span(), &Span::new(0, 8));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 8),",
            "        items: vec![",
            "            ClassSetItem::Literal(Literal::new('e')),",
            "            ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "            ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "        ],",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion {",
            "    span: Span::new(0, 8),",
            "    items: vec![",
            "    ClassSetItem::Literal(Literal::new('e')),",
            "    ClassSetItem::Range(ClassSetRange::new(5, 10)),",
            "    ClassSetItem::Ascii(ClassAscii::new(\"punct\")),",
            "    ],",
            "    };",
            "    let result = union(ast);",
            "    assert!(result.is_empty() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ClassSetUnion {",
          "        span: Span::new(0, 20),",
          "        items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect(),",
          "    };",
          "    union(ast);",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));"
          ],
          [
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert_eq!(result.span(), &Span::new(0, 20));"
          ],
          [
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert_eq!(result.items.len(), 10);"
          ],
          [
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert!(result.items.iter().all(|item| matches!(item, ClassSetItem::Literal(_))));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 20),",
            "        items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect(),",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert!(matches!(result, ClassSet::Item(ClassSetItem::Union(_))));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 20),",
            "        items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect(),",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert_eq!(result.span(), &Span::new(0, 20));",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 20),",
            "        items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect(),",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert_eq!(result.items.len(), 10);",
            "}"
          ],
          [
            "{",
            "    let ast = ClassSetUnion {",
            "        span: Span::new(0, 20),",
            "        items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect(),",
            "    };",
            "    union(ast);",
            "    let ast = ClassSetUnion { span: Span::new(0, 20), items: (0..10).map(|i| ClassSetItem::Literal(Literal::new((b'a' + i as u8) as char))).collect() };",
            "    let result = union(ast);",
            "    assert!(result.items.iter().all(|item| matches!(item, ClassSetItem::Literal(_))));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]