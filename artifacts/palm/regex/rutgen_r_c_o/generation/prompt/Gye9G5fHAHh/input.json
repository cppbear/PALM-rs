{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/translate.rs\n// crate name is regex_syntax\ntype Result<T> = result::Result<T, Error>;\nuse std::cell::{Cell, RefCell};\nuse std::result;\nuse ast::{self, Ast, Span, Visitor};\nuse hir::{self, Error, ErrorKind, Hir};\nuse unicode::{self, ClassQuery};\n#[derive(Clone, Debug)]\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Copy, Debug, Default)]\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n}\n#[derive(Clone, Debug)]\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    allow_invalid_utf8: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassSetBinaryOp {\n    /// The span of this operation. e.g., the `a-z--[h-p]` in `[a-z--h-p]`.\n    pub span: Span,\n    /// The type of this set operation.\n    pub kind: ClassSetBinaryOpKind,\n    /// The left hand side of the operation.\n    pub lhs: Box<ClassSet>,\n    /// The right hand side of the operation.\n    pub rhs: Box<ClassSet>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    info: HirInfo,\n}\n#[derive(Clone, Debug)]\nenum HirFrame {\n    /// An arbitrary HIR expression. These get pushed whenever we hit a base\n    /// case in the Ast. They get popped after an inductive (i.e., recursive)\n    /// step is complete.\n    Expr(Hir),\n    /// A Unicode character class. This frame is mutated as we descend into\n    /// the Ast of a character class (which is itself its own mini recursive\n    /// structure).\n    ClassUnicode(hir::ClassUnicode),\n    /// A byte-oriented character class. This frame is mutated as we descend\n    /// into the Ast of a character class (which is itself its own mini\n    /// recursive structure).\n    ///\n    /// Byte character classes are created when Unicode mode (`u`) is disabled.\n    /// If `allow_invalid_utf8` is disabled (the default), then a byte\n    /// character is only permitted to match ASCII text.\n    ClassBytes(hir::ClassBytes),\n    /// This is pushed on to the stack upon first seeing any kind of group,\n    /// indicated by parentheses (including non-capturing groups). It is popped\n    /// upon leaving a group.\n    Group {\n        /// The old active flags, if any, when this group was opened.\n        ///\n        /// If this group sets flags, then the new active flags are set to the\n        /// result of merging the old flags with the flags introduced by this\n        /// group.\n        ///\n        /// When this group is popped, the active flags should be restored to\n        /// the flags set here.\n        ///\n        /// The \"active\" flags correspond to whatever flags are set in the\n        /// Translator.\n        old_flags: Option<Flags>,\n    },\n    /// This is pushed whenever a concatenation is observed. After visiting\n    /// every sub-expression in the concatenation, the translator's stack is\n    /// popped until it sees a Concat frame.\n    Concat,\n    /// This is pushed whenever an alternation is observed. After visiting\n    /// every sub-expression in the alternation, the translator's stack is\n    /// popped until it sees an Alternation frame.\n    Alternation,\n}\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\nimpl<'t, 'p> Visitor for TranslatorI<'t, 'p> {\n    type Output = Hir;\n    type Err = Error;\n    fn finish(self) -> Result<Hir> {}\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {}\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {}\n    fn visit_class_set_item_pre(&mut self, ast: &ast::ClassSetItem) -> Result<()> {}\n    fn visit_class_set_item_post(&mut self, ast: &ast::ClassSetItem) -> Result<()> {}\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {}\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {}\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        use ast::ClassSetBinaryOpKind::*;\n        if self.flags().unicode() {\n            let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut cls = self.pop().unwrap().unwrap_class_unicode();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut cls = self.pop().unwrap().unwrap_class_bytes();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n}\nimpl ClassBytes {\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {}\n    pub fn empty() -> ClassBytes {}\n    pub fn push(&mut self, range: ClassBytesRange) {}\n    pub fn iter(&self) -> ClassBytesIter {}\n    pub fn ranges(&self) -> &[ClassBytesRange] {}\n    pub fn case_fold_simple(&mut self) {\n        self.set.case_fold_simple();\n    }\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassBytes) {\n        self.set.union(&other.set);\n    }\n    pub fn intersect(&mut self, other: &ClassBytes) {\n        self.set.intersect(&other.set);\n    }\n    pub fn difference(&mut self, other: &ClassBytes) {\n        self.set.difference(&other.set);\n    }\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {\n        self.set.symmetric_difference(&other.set);\n    }\n    pub fn is_all_ascii(&self) -> bool {}\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {}\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {}\n    pub fn case_fold_simple(&mut self) {\n        self.set.case_fold_simple();\n    }\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n    pub fn intersect(&mut self, other: &ClassUnicode) {\n        self.set.intersect(&other.set);\n    }\n    pub fn difference(&mut self, other: &ClassUnicode) {\n        self.set.difference(&other.set);\n    }\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {\n        self.set.symmetric_difference(&other.set);\n    }\n}\nimpl HirFrame {\n    fn unwrap_expr(self) -> Hir {}\n    fn unwrap_class_unicode(self) -> hir::ClassUnicode {\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => {\n                panic!(\n                    \"tried to unwrap Unicode class \\\n                         from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }\n    fn unwrap_class_bytes(self) -> hir::ClassBytes {\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => {\n                panic!(\n                    \"tried to unwrap byte class \\\n                         from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }\n    fn unwrap_group(self) -> Option<Flags> {}\n}\nimpl<'t, 'p> TranslatorI<'t, 'p> {\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {}\n    fn trans(&self) -> &Translator {}\n    fn push(&self, frame: HirFrame) {\n        self.trans().stack.borrow_mut().push(frame);\n    }\n    fn pop(&self) -> Option<HirFrame> {\n        self.trans().stack.borrow_mut().pop()\n    }\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {}\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {}\n    fn hir_literal(&self, lit: &ast::Literal) -> Result<Hir> {}\n    fn literal_to_char(&self, lit: &ast::Literal) -> Result<hir::Literal> {}\n    fn hir_from_char(&self, span: Span, c: char) -> Result<Hir> {}\n    fn hir_from_char_case_insensitive(&self, span: Span, c: char) -> Result<Hir> {}\n    fn hir_dot(&self, span: Span) -> Result<Hir> {}\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {}\n    fn hir_group(&self, group: &ast::Group, expr: Hir) -> Hir {}\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {}\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {}\n    fn hir_perl_unicode_class(&self, ast_class: &ast::ClassPerl) -> hir::ClassUnicode {}\n    fn hir_perl_byte_class(&self, ast_class: &ast::ClassPerl) -> hir::ClassBytes {}\n    fn unicode_fold_and_negate(&self, negated: bool, class: &mut hir::ClassUnicode) {}\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {}\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {}\n}\nimpl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {}\n    fn merge(&mut self, previous: &Flags) {}\n    fn case_insensitive(&self) -> bool {\n        self.case_insensitive.unwrap_or(false)\n    }\n    fn multi_line(&self) -> bool {}\n    fn dot_matches_new_line(&self) -> bool {}\n    fn swap_greed(&self) -> bool {}\n    fn unicode(&self) -> bool {\n        self.unicode.unwrap_or(true)\n    }\n}\n\nThe function to be tested is presented as follows:\nfn visit_class_set_binary_op_post(\n    &mut self,\n    op: &ast::ClassSetBinaryOp,\n) -> Result<()> {\n    use ast::ClassSetBinaryOpKind::*;\n\n    if self.flags().unicode() {\n        let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n        let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n        let mut cls = self.pop().unwrap().unwrap_class_unicode();\n        if self.flags().case_insensitive() {\n            rhs.case_fold_simple();\n            lhs.case_fold_simple();\n        }\n        match op.kind {\n            Intersection => lhs.intersect(&rhs),\n            Difference => lhs.difference(&rhs),\n            SymmetricDifference => lhs.symmetric_difference(&rhs),\n        }\n        cls.union(&lhs);\n        self.push(HirFrame::ClassUnicode(cls));\n    } else {\n        let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n        let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n        let mut cls = self.pop().unwrap().unwrap_class_bytes();\n        if self.flags().case_insensitive() {\n            rhs.case_fold_simple();\n            lhs.case_fold_simple();\n        }\n        match op.kind {\n            Intersection => lhs.intersect(&rhs),\n            Difference => lhs.difference(&rhs),\n            SymmetricDifference => lhs.symmetric_difference(&rhs),\n        }\n        cls.union(&lhs);\n        self.push(HirFrame::ClassBytes(cls));\n    }\n    Ok(())\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}