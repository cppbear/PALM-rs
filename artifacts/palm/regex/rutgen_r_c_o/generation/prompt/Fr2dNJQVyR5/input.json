{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/mod.rs\n// crate name is regex_syntax\nuse std::cmp::Ordering;\nuse std::error;\nuse std::fmt;\npub use ast::visitor::{Visitor, visit};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Group {\n    /// The span of this group.\n    pub span: Span,\n    /// The kind of this group.\n    pub kind: GroupKind,\n    /// The regular expression in this group.\n    pub ast: Box<Ast>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct CaptureName {\n    /// The span of this capture name.\n    pub span: Span,\n    /// The capture name.\n    pub name: String,\n    /// The capture index.\n    pub index: u32,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Ast {\n    /// An empty regex that matches everything.\n    Empty(Span),\n    /// A set of flags, e.g., `(?is)`.\n    Flags(SetFlags),\n    /// A single character literal, which includes escape sequences.\n    Literal(Literal),\n    /// The \"any character\" class.\n    Dot(Span),\n    /// A single zero-width assertion.\n    Assertion(Assertion),\n    /// A single character class. This includes all forms of character classes\n    /// except for `.`. e.g., `\\d`, `\\pN`, `[a-z]` and `[[:alpha:]]`.\n    Class(Class),\n    /// A repetition operator applied to an arbitrary regular expression.\n    Repetition(Repetition),\n    /// A grouped regular expression.\n    Group(Group),\n    /// An alternation of regular expressions.\n    Alternation(Alternation),\n    /// A concatenation of regular expressions.\n    Concat(Concat),\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum GroupKind {\n    /// `(a)`\n    CaptureIndex(u32),\n    /// `(?P<name>a)`\n    CaptureName(CaptureName),\n    /// `(?:a)` and `(?i:a)`\n    NonCapturing(Flags),\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum GroupKind {\n    /// A normal unnamed capturing group.\n    ///\n    /// The value is the capture index of the group.\n    CaptureIndex(u32),\n    /// A named capturing group.\n    CaptureName {\n        /// The name of the group.\n        name: String,\n        /// The capture index of the group.\n        index: u32,\n    },\n    /// A non-capturing group.\n    NonCapturing,\n}\nimpl Group {\n    pub fn flags(&self) -> Option<&Flags> {}\n    pub fn is_capturing(&self) -> bool {}\n    pub fn capture_index(&self) -> Option<u32> {\n        match self.kind {\n            GroupKind::CaptureIndex(i) => Some(i),\n            GroupKind::CaptureName(ref x) => Some(x.index),\n            GroupKind::NonCapturing(_) => None,\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Returns the capture index of this group, if this is a capturing group.\n///\n/// This returns a capture index precisely when `is_capturing` is `true`.\npub fn capture_index(&self) -> Option<u32> {\n    match self.kind {\n        GroupKind::CaptureIndex(i) => Some(i),\n        GroupKind::CaptureName(ref x) => Some(x.index),\n        GroupKind::NonCapturing(_) => None,\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}