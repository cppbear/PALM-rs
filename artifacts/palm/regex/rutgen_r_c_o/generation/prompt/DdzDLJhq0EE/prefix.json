{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. Omit test oracles and assertions; concentrate on generating test inputs and function calls of the focal function; do not use \"_\" for the return values of the focal function.\n3. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides.\n6. If the method under test uses generics, instantiate them with suitable types based on the context.\n7. Define any necessary helper structures or implementations directly within the test function when required.\n8. Create a minimal yet comprehensive set of test functions, ensuring each test input satisfies all given constraints, with some explicitly covering edge scenarios.\n9. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/literal/mod.rs\n// crate name is regex\nuse std::cmp;\nuse std::mem;\nuse aho_corasick::{Automaton, AcAutomaton, FullAcAutomaton};\nuse memchr::{memchr, memchr2, memchr3};\nuse syntax::hir::literal::{Literal, Literals};\nuse freqs::BYTE_FREQUENCIES;\nuse self::teddy_avx2::Teddy as TeddyAVX2;\nuse self::teddy_ssse3::Teddy as TeddySSSE3;\n#[derive(Clone, Debug)]\npub struct FreqyPacked {\n    /// The pattern.\n    pat: Vec<u8>,\n    /// The number of Unicode characters in the pattern. This is useful for\n    /// determining the effective length of a pattern when deciding which\n    /// optimizations to perform. A trailing incomplete UTF-8 sequence counts\n    /// as one character.\n    char_len: usize,\n    /// The rarest byte in the pattern, according to pre-computed frequency\n    /// analysis.\n    rare1: u8,\n    /// The offset of the rarest byte in `pat`.\n    rare1i: usize,\n    /// The second rarest byte in the pattern, according to pre-computed\n    /// frequency analysis. (This may be equivalent to the rarest byte.)\n    ///\n    /// The second rarest byte is used as a type of guard for quickly detecting\n    /// a mismatch after memchr locates an instance of the rarest byte. This\n    /// is a hedge against pathological cases where the pre-computed frequency\n    /// analysis may be off. (But of course, does not prevent *all*\n    /// pathological cases.)\n    rare2: u8,\n    /// The offset of the second rarest byte in `pat`.\n    rare2i: usize,\n}\nimpl FreqyPacked {\n    fn new(pat: Vec<u8>) -> FreqyPacked {\n        if pat.is_empty() {\n            return FreqyPacked::empty();\n        }\n        let mut rare1 = pat[0];\n        let mut rare2 = pat[0];\n        for b in pat[1..].iter().cloned() {\n            if freq_rank(b) < freq_rank(rare1) {\n                rare1 = b;\n            }\n        }\n        for &b in &pat {\n            if rare1 == rare2 {\n                rare2 = b\n            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {\n                rare2 = b;\n            }\n        }\n        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n        let char_len = char_len_lossy(&pat);\n        FreqyPacked {\n            pat: pat,\n            char_len: char_len,\n            rare1: rare1,\n            rare1i: rare1i,\n            rare2: rare2,\n            rare2i: rare2i,\n        }\n    }\n    fn empty() -> FreqyPacked {\n        FreqyPacked {\n            pat: vec![],\n            char_len: 0,\n            rare1: 0,\n            rare1i: 0,\n            rare2: 0,\n            rare2i: 0,\n        }\n    }\n    #[inline(always)]\n    pub fn find(&self, haystack: &[u8]) -> Option<usize> {}\n    #[inline(always)]\n    pub fn is_suffix(&self, text: &[u8]) -> bool {}\n    pub fn len(&self) -> usize {}\n    pub fn char_len(&self) -> usize {}\n    fn approximate_size(&self) -> usize {}\n}\nfn char_len_lossy(bytes: &[u8]) -> usize {\n    String::from_utf8_lossy(bytes).chars().count()\n}\nfn freq_rank(b: u8) -> usize {\n    BYTE_FREQUENCIES[b as usize] as usize\n}\n\nThe function to be tested is presented as follows:\nfn new(pat: Vec<u8>) -> FreqyPacked {\n    if pat.is_empty() {\n        return FreqyPacked::empty();\n    }\n\n    // Find the rarest two bytes. Try to make them distinct (but it's not\n    // required).\n    let mut rare1 = pat[0];\n    let mut rare2 = pat[0];\n    for b in pat[1..].iter().cloned() {\n        if freq_rank(b) < freq_rank(rare1) {\n            rare1 = b;\n        }\n    }\n    for &b in &pat {\n        if rare1 == rare2 {\n            rare2 = b\n        } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {\n            rare2 = b;\n        }\n    }\n\n    // And find the offsets of their last occurrences.\n    let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n\n    let char_len = char_len_lossy(&pat);\n    FreqyPacked {\n        pat: pat,\n        char_len: char_len,\n        rare1: rare1,\n        rare1i: rare1i,\n        rare2: rare2,\n        rare2i: rare2i,\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}