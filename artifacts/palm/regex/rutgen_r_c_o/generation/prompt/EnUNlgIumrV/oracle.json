{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/exec.rs\n// crate name is regex\npub type ProgramCache = RefCell<ProgramCacheInner>;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::cmp;\nuse std::sync::Arc;\nuse thread_local::CachedThreadLocal;\nuse syntax::ParserBuilder;\nuse syntax::hir::Hir;\nuse syntax::hir::literal::Literals;\nuse backtrack;\nuse compile::Compiler;\nuse dfa;\nuse error::Error;\nuse input::{ByteInput, CharInput};\nuse literal::LiteralSearcher;\nuse pikevm;\nuse prog::Program;\nuse re_builder::RegexOptions;\nuse re_bytes;\nuse re_set;\nuse re_trait::{RegularExpression, Slot, Locations, as_slots};\nuse re_unicode;\nuse utf8::next_utf8;\npub trait RegularExpression: Sized {\n    type Text: ?Sized;\n    fn slots_len(&self) -> usize;\n    fn locations(&self) -> Locations;\n    fn next_after_empty(&self, text: &Self::Text, i: usize) -> usize;\n    fn shortest_match_at(&self, text: &Self::Text, start: usize) -> Option<usize>;\n    fn is_match_at(&self, text: &Self::Text, start: usize) -> bool;\n    fn find_at(&self, text: &Self::Text, start: usize) -> Option<(usize, usize)>;\n    fn read_captures_at(\n        &self,\n        locs: &mut Locations,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n    fn find_iter(self, text: &Self::Text) -> Matches<Self> {\n        Matches {\n            re: self,\n            text: text,\n            last_end: 0,\n            last_match: None,\n        }\n    }\n    fn captures_iter(self, text: &Self::Text) -> CaptureMatches<Self> {\n        CaptureMatches(self.find_iter(text))\n    }\n}\n#[derive(Debug)]\npub struct ExecNoSync<'c> {\n    /// All read only state.\n    ro: &'c Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: &'c ProgramCache,\n}\n#[derive(Debug)]\nstruct ExecReadOnly {\n    /// The original regular expressions given by the caller to compile.\n    res: Vec<String>,\n    /// A compiled program that is used in the NFA simulation and backtracking.\n    /// It can be byte-based or Unicode codepoint based.\n    ///\n    /// N.B. It is not possibly to make this byte-based from the public API.\n    /// It is only used for testing byte based programs in the NFA simulations.\n    nfa: Program,\n    /// A compiled byte based program for DFA execution. This is only used\n    /// if a DFA can be executed. (Currently, only word boundary assertions are\n    /// not supported.) Note that this program contains an embedded `.*?`\n    /// preceding the first capture group, unless the regex is anchored at the\n    /// beginning.\n    dfa: Program,\n    /// The same as above, except the program is reversed (and there is no\n    /// preceding `.*?`). This is used by the DFA to find the starting location\n    /// of matches.\n    dfa_reverse: Program,\n    /// A set of suffix literals extracted from the regex.\n    ///\n    /// Prefix literals are stored on the `Program`, since they are used inside\n    /// the matching engines.\n    suffixes: LiteralSearcher,\n    /// match_type encodes as much upfront knowledge about how we're going to\n    /// execute a search as possible.\n    match_type: MatchType,\n}\n#[derive(Clone, Copy, Debug)]\nenum MatchNfaType {\n    /// Choose between Backtrack and PikeVM.\n    Auto,\n    /// NFA bounded backtracking.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// backtracking.)\n    Backtrack,\n    /// The Pike VM.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// the Pike VM.)\n    PikeVM,\n}\nimpl<'c> ExecNoSync<'c> {\n    #[inline(always)]\n    fn find_literals(\n        &self,\n        ty: MatchLiteralType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    #[inline(always)]\n    fn find_dfa_forward(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {}\n    #[inline(always)]\n    fn find_dfa_anchored_reverse(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {}\n    #[inline(always)]\n    fn shortest_dfa(&self, text: &[u8], start: usize) -> dfa::Result<usize> {}\n    #[inline(always)]\n    fn shortest_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<usize> {}\n    #[inline(always)]\n    fn exec_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        original_start: usize,\n    ) -> Option<dfa::Result<(usize, usize)>> {}\n    #[inline(always)]\n    fn find_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {}\n    fn match_nfa(&self, text: &[u8], start: usize) -> bool {}\n    fn match_nfa_type(&self, ty: MatchNfaType, text: &[u8], start: usize) -> bool {}\n    fn shortest_nfa(&self, text: &[u8], start: usize) -> Option<usize> {}\n    fn shortest_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {}\n    fn find_nfa(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        let mut slots = [None, None];\n        if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n    fn captures_nfa_with_match(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        match_start: usize,\n        match_end: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn exec_nfa(\n        &self,\n        mut ty: MatchNfaType,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n    ) -> bool {\n        use self::MatchNfaType::*;\n        if let Auto = ty {\n            if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n                ty = Backtrack;\n            } else {\n                ty = PikeVM;\n            }\n        }\n        match ty {\n            Auto => unreachable!(),\n            Backtrack => self.exec_backtrack(matches, slots, text, start),\n            PikeVM => self.exec_pikevm(matches, slots, quit_after_match, text, start),\n        }\n    }\n    fn exec_pikevm(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    fn exec_backtrack(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    pub fn many_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    #[inline(always)]\n    fn is_anchor_end_match(&self, text: &[u8]) -> bool {}\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {}\n}\n\nThe function to be tested is presented as follows:\n/// Like find, but executes an NFA engine.\nfn find_nfa(\n    &self,\n    ty: MatchNfaType,\n    text: &[u8],\n    start: usize,\n) -> Option<(usize, usize)> {\n    let mut slots = [None, None];\n    if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {\n        match (slots[0], slots[1]) {\n            (Some(s), Some(e)) => Some((s, e)),\n            _ => None,\n        }\n    } else {\n        None\n    }\n}\n",
  "depend_pt": ""
}