{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/compile.rs\n// crate name is regex\ntype Result = result::Result<Patch, Error>;\nuse std::collections::HashMap;\nuse std::iter;\nuse std::result;\nuse std::sync::Arc;\nuse syntax::is_word_byte;\nuse syntax::hir::{self, Hir};\nuse utf8_ranges::{Utf8Range, Utf8Sequence, Utf8Sequences};\nuse prog::{\n    Program, Inst, InstPtr, EmptyLook, InstSave, InstSplit, InstEmptyLook, InstChar,\n    InstRanges, InstBytes,\n};\nuse Error;\npub struct Compiler {\n    insts: Vec<MaybeInst>,\n    compiled: Program,\n    capture_name_idx: HashMap<String, usize>,\n    num_exprs: usize,\n    size_limit: usize,\n    suffix_cache: SuffixCache,\n    utf8_seqs: Option<Utf8Sequences>,\n    byte_classes: ByteClassSet,\n}\n#[derive(Clone)]\npub struct Program {\n    /// A sequence of instructions that represents an NFA.\n    pub insts: Vec<Inst>,\n    /// Pointers to each Match instruction in the sequence.\n    ///\n    /// This is always length 1 unless this program represents a regex set.\n    pub matches: Vec<InstPtr>,\n    /// The ordered sequence of all capture groups extracted from the AST.\n    /// Unnamed groups are `None`.\n    pub captures: Vec<Option<String>>,\n    /// Pointers to all named capture groups into `captures`.\n    pub capture_name_idx: Arc<HashMap<String, usize>>,\n    /// A pointer to the start instruction. This can vary depending on how\n    /// the program was compiled. For example, programs for use with the DFA\n    /// engine have a `.*?` inserted at the beginning of unanchored regular\n    /// expressions. The actual starting point of the program is after the\n    /// `.*?`.\n    pub start: InstPtr,\n    /// A set of equivalence classes for discriminating bytes in the compiled\n    /// program.\n    pub byte_classes: Vec<u8>,\n    /// When true, this program can only match valid UTF-8.\n    pub only_utf8: bool,\n    /// When true, this program uses byte range instructions instead of Unicode\n    /// range instructions.\n    pub is_bytes: bool,\n    /// When true, the program is compiled for DFA matching. For example, this\n    /// implies `is_bytes` and also inserts a preceding `.*?` for unanchored\n    /// regexes.\n    pub is_dfa: bool,\n    /// When true, the program matches text in reverse (for use only in the\n    /// DFA).\n    pub is_reverse: bool,\n    /// Whether the regex must match from the start of the input.\n    pub is_anchored_start: bool,\n    /// Whether the regex must match at the end of the input.\n    pub is_anchored_end: bool,\n    /// Whether this program contains a Unicode word boundary instruction.\n    pub has_unicode_word_boundary: bool,\n    /// A possibly empty machine for very quickly matching prefix literals.\n    pub prefixes: LiteralSearcher,\n    /// A limit on the size of the cache that the DFA is allowed to use while\n    /// matching.\n    ///\n    /// The cache limit specifies approximately how much space we're willing to\n    /// give to the state cache. Once the state cache exceeds the size, it is\n    /// wiped and all states must be re-computed.\n    ///\n    /// Note that this value does not impact correctness. It can be set to 0\n    /// and the DFA will run just fine. (It will only ever store exactly one\n    /// state in the cache, and will likely run very slowly, but it will work.)\n    ///\n    /// Also note that this limit is *per thread of execution*. That is,\n    /// if the same regex is used to search text across multiple threads\n    /// simultaneously, then the DFA cache is not shared. Instead, copies are\n    /// made.\n    pub dfa_size_limit: usize,\n}\nstruct ByteClassSet([bool; 256]);\n#[derive(Debug)]\nstruct Patch {\n    hole: Hole,\n    entry: InstPtr,\n}\nstruct SuffixCache {\n    table: Vec<SuffixCacheEntry>,\n    version: usize,\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum EmptyLook {\n    /// Start of line or input.\n    StartLine,\n    /// End of line or input.\n    EndLine,\n    /// Start of input.\n    StartText,\n    /// End of input.\n    EndText,\n    /// Word character on one side and non-word character on other.\n    WordBoundary,\n    /// Word character on both sides or non-word character on both sides.\n    NotWordBoundary,\n    /// ASCII word boundary.\n    WordBoundaryAscii,\n    /// Not ASCII word boundary.\n    NotWordBoundaryAscii,\n}\n#[derive(Clone, PartialEq)]\npub enum Error {\n    /// A syntax error.\n    Syntax(String),\n    /// The compiled program exceeded the set size limit.\n    /// The argument is the size limit imposed.\n    CompiledTooBig(usize),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}\n#[derive(Clone, Debug)]\nenum MaybeInst {\n    Compiled(Inst),\n    Uncompiled(InstHole),\n    Split,\n    Split1(InstPtr),\n    Split2(InstPtr),\n}\n#[derive(Debug)]\nenum Hole {\n    None,\n    One(InstPtr),\n    Many(Vec<Hole>),\n}\nimpl Compiler {\n    pub fn new() -> Self {\n        Compiler {\n            insts: vec![],\n            compiled: Program::new(),\n            capture_name_idx: HashMap::new(),\n            num_exprs: 0,\n            size_limit: 10 * (1 << 20),\n            suffix_cache: SuffixCache::new(1000),\n            utf8_seqs: Some(Utf8Sequences::new('\\x00', '\\x00')),\n            byte_classes: ByteClassSet::new(),\n        }\n    }\n    pub fn size_limit(mut self, size_limit: usize) -> Self {\n        self.size_limit = size_limit;\n        self\n    }\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.compiled.is_bytes = yes;\n        self\n    }\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.compiled.only_utf8 = yes;\n        self\n    }\n    pub fn dfa(mut self, yes: bool) -> Self {\n        self.compiled.is_dfa = yes;\n        self\n    }\n    pub fn reverse(mut self, yes: bool) -> Self {\n        self.compiled.is_reverse = yes;\n        self\n    }\n    pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {}\n    fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error> {}\n    fn compile_many(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {}\n    fn compile_finish(mut self) -> result::Result<Program, Error> {}\n    fn c(&mut self, expr: &Hir) -> Result {\n        use prog;\n        use syntax::hir::HirKind::*;\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => {\n                Ok(Patch {\n                    hole: Hole::None,\n                    entry: self.insts.len(),\n                })\n            }\n            Literal(hir::Literal::Unicode(c)) => self.c_literal(&[c]),\n            Literal(hir::Literal::Byte(b)) => {\n                assert!(self.compiled.uses_bytes());\n                self.c_bytes(&[b])\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_all_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            Anchor(hir::Anchor::StartText) => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) => self.c_empty_look(prog::EmptyLook::EndText),\n            WordBoundary(hir::WordBoundary::Unicode) => {\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::Ascii) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n            }\n            WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n            }\n            Group(ref g) => {\n                match g.kind {\n                    hir::GroupKind::NonCapturing => self.c(&g.hir),\n                    hir::GroupKind::CaptureIndex(index) => {\n                        if index as usize >= self.compiled.captures.len() {\n                            self.compiled.captures.push(None);\n                        }\n                        self.c_capture(2 * index as usize, &g.hir)\n                    }\n                    hir::GroupKind::CaptureName { index, ref name } => {\n                        if index as usize >= self.compiled.captures.len() {\n                            let n = name.to_string();\n                            self.compiled.captures.push(Some(n.clone()));\n                            self.capture_name_idx.insert(n, index as usize);\n                        }\n                        self.c_capture(2 * index as usize, &g.hir)\n                    }\n                }\n            }\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n    fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> Result {\n        if self.num_exprs > 1 || self.compiled.is_dfa {\n            self.c(expr)\n        } else {\n            let entry = self.insts.len();\n            let hole = self.push_hole(InstHole::Save { slot: first_slot });\n            let patch = self.c(expr)?;\n            self.fill(hole, patch.entry);\n            self.fill_to_next(patch.hole);\n            let hole = self\n                .push_hole(InstHole::Save {\n                    slot: first_slot + 1,\n                });\n            Ok(Patch { hole: hole, entry: entry })\n        }\n    }\n    fn c_dotstar(&mut self) -> Result {}\n    fn c_literal(&mut self, chars: &[char]) -> Result {\n        debug_assert!(! chars.is_empty());\n        let mut chars: Box<Iterator<Item = &char>> = if self.compiled.is_reverse {\n            Box::new(chars.iter().rev())\n        } else {\n            Box::new(chars.iter())\n        };\n        let first = *chars.next().expect(\"non-empty literal\");\n        let Patch { mut hole, entry } = self.c_char(first)?;\n        for &c in chars {\n            let p = self.c_char(c)?;\n            self.fill(hole, p.entry);\n            hole = p.hole;\n        }\n        Ok(Patch { hole: hole, entry: entry })\n    }\n    fn c_char(&mut self, c: char) -> Result {}\n    fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> Result {\n        assert!(! ranges.is_empty());\n        if self.compiled.uses_bytes() {\n            CompileClass {\n                c: self,\n                ranges: ranges,\n            }\n                .compile()\n        } else {\n            let ranges: Vec<(char, char)> = ranges\n                .iter()\n                .map(|r| (r.start(), r.end()))\n                .collect();\n            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {\n                self.push_hole(InstHole::Char { c: ranges[0].0 })\n            } else {\n                self.push_hole(InstHole::Ranges { ranges: ranges })\n            };\n            Ok(Patch {\n                hole: hole,\n                entry: self.insts.len() - 1,\n            })\n        }\n    }\n    fn c_bytes(&mut self, bytes: &[u8]) -> Result {\n        debug_assert!(! bytes.is_empty());\n        let mut bytes: Box<Iterator<Item = &u8>> = if self.compiled.is_reverse {\n            Box::new(bytes.iter().rev())\n        } else {\n            Box::new(bytes.iter())\n        };\n        let first = *bytes.next().expect(\"non-empty literal\");\n        let Patch { mut hole, entry } = self.c_byte(first)?;\n        for &b in bytes {\n            let p = self.c_byte(b)?;\n            self.fill(hole, p.entry);\n            hole = p.hole;\n        }\n        Ok(Patch { hole: hole, entry: entry })\n    }\n    fn c_byte(&mut self, b: u8) -> Result {}\n    fn c_class_bytes(&mut self, ranges: &[hir::ClassBytesRange]) -> Result {\n        debug_assert!(! ranges.is_empty());\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for r in &ranges[0..ranges.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let next = self.insts.len();\n            self.byte_classes.set_range(r.start(), r.end());\n            holes\n                .push(\n                    self\n                        .push_hole(InstHole::Bytes {\n                            start: r.start(),\n                            end: r.end(),\n                        }),\n                );\n            prev_hole = self.fill_split(split, Some(next), None);\n        }\n        let next = self.insts.len();\n        let r = &ranges[ranges.len() - 1];\n        self.byte_classes.set_range(r.start(), r.end());\n        holes\n            .push(\n                self\n                    .push_hole(InstHole::Bytes {\n                        start: r.start(),\n                        end: r.end(),\n                    }),\n            );\n        self.fill(prev_hole, next);\n        Ok(Patch {\n            hole: Hole::Many(holes),\n            entry: first_split_entry,\n        })\n    }\n    fn c_empty_look(&mut self, look: EmptyLook) -> Result {\n        let hole = self.push_hole(InstHole::EmptyLook { look: look });\n        Ok(Patch {\n            hole: hole,\n            entry: self.insts.len() - 1,\n        })\n    }\n    fn c_concat<'a, I>(&mut self, exprs: I) -> Result\n    where\n        I: IntoIterator<Item = &'a Hir>,\n    {}\n    fn c_alternate(&mut self, exprs: &[Hir]) -> Result {\n        debug_assert!(exprs.len() >= 2, \"alternates must have at least 2 exprs\");\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for e in &exprs[0..exprs.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let prev_entry = self.insts.len();\n            let Patch { hole, entry } = self.c(e)?;\n            if prev_entry == self.insts.len() {\n                return Err(\n                    Error::Syntax(\n                        \"alternations cannot currently contain \\\n                     empty sub-expressions\"\n                            .to_string(),\n                    ),\n                );\n            }\n            holes.push(hole);\n            prev_hole = self.fill_split(split, Some(entry), None);\n        }\n        let prev_entry = self.insts.len();\n        let Patch { hole, entry } = self.c(&exprs[exprs.len() - 1])?;\n        if prev_entry == self.insts.len() {\n            return Err(\n                Error::Syntax(\n                    \"alternations cannot currently contain \\\n                 empty sub-expressions\"\n                        .to_string(),\n                ),\n            );\n        }\n        holes.push(hole);\n        self.fill(prev_hole, entry);\n        Ok(Patch {\n            hole: Hole::Many(holes),\n            entry: first_split_entry,\n        })\n    }\n    fn c_repeat(&mut self, rep: &hir::Repetition) -> Result {\n        use syntax::hir::RepetitionKind::*;\n        match rep.kind {\n            ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),\n            ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),\n            OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),\n            Range(hir::RepetitionRange::Exactly(min_max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)\n            }\n            Range(hir::RepetitionRange::AtLeast(min)) => {\n                self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)\n            }\n            Range(hir::RepetitionRange::Bounded(min, max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min, max)\n            }\n        }\n    }\n    fn c_repeat_zero_or_one(&mut self, expr: &Hir, greedy: bool) -> Result {}\n    fn c_repeat_zero_or_more(&mut self, expr: &Hir, greedy: bool) -> Result {}\n    fn c_repeat_one_or_more(&mut self, expr: &Hir, greedy: bool) -> Result {}\n    fn c_repeat_range_min_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n    ) -> Result {}\n    fn c_repeat_range(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> Result {}\n    fn fill(&mut self, hole: Hole, goto: InstPtr) {}\n    fn fill_to_next(&mut self, hole: Hole) {}\n    fn fill_split(\n        &mut self,\n        hole: Hole,\n        goto1: Option<InstPtr>,\n        goto2: Option<InstPtr>,\n    ) -> Hole {}\n    fn push_compiled(&mut self, inst: Inst) {}\n    fn push_hole(&mut self, inst: InstHole) -> Hole {}\n    fn push_split_hole(&mut self) -> Hole {}\n    fn check_size(&self) -> result::Result<(), Error> {\n        use std::mem::size_of;\n        if self.insts.len() * size_of::<Inst>() > self.size_limit {\n            Err(Error::CompiledTooBig(self.size_limit))\n        } else {\n            Ok(())\n        }\n    }\n}\nimpl Program {\n    pub fn new() -> Self {\n        Program {\n            insts: vec![],\n            matches: vec![],\n            captures: vec![],\n            capture_name_idx: Arc::new(HashMap::new()),\n            start: 0,\n            byte_classes: vec![0; 256],\n            only_utf8: true,\n            is_bytes: false,\n            is_dfa: false,\n            is_reverse: false,\n            is_anchored_start: false,\n            is_anchored_end: false,\n            has_unicode_word_boundary: false,\n            prefixes: LiteralSearcher::empty(),\n            dfa_size_limit: 2 * (1 << 20),\n        }\n    }\n    pub fn skip(&self, mut pc: usize) -> usize {}\n    pub fn leads_to_match(&self, pc: usize) -> bool {}\n    pub fn needs_dotstar(&self) -> bool {}\n    pub fn uses_bytes(&self) -> bool {\n        self.is_bytes || self.is_dfa\n    }\n    pub fn only_utf8(&self) -> bool {}\n    pub fn approximate_size(&self) -> usize {}\n}\nimpl ByteClassSet {\n    fn new() -> Self {\n        ByteClassSet([false; 256])\n    }\n    fn set_range(&mut self, start: u8, end: u8) {\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0[start as usize - 1] = true;\n        }\n        self.0[end as usize] = true;\n    }\n    fn set_word_boundary(&mut self) {\n        let iswb = is_word_byte;\n        let mut b1: u16 = 0;\n        let mut b2: u16;\n        while b1 <= 255 {\n            b2 = b1 + 1;\n            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {\n                b2 += 1;\n            }\n            self.set_range(b1 as u8, (b2 - 1) as u8);\n            b1 = b2;\n        }\n    }\n    fn byte_classes(&self) -> Vec<u8> {}\n}\n\nThe function to be tested is presented as follows:\n/// Compile expr into self.insts, returning a patch on success,\n/// or an error if we run out of memory.\n///\n/// All of the c_* methods of the compiler share the contract outlined\n/// here.\n///\n/// The main thing that a c_* method does is mutate `self.insts`\n/// to add a list of mostly compiled instructions required to execute\n/// the given expression. `self.insts` contains MaybeInsts rather than\n/// Insts because there is some backpatching required.\n///\n/// The `Patch` value returned by each c_* method provides metadata\n/// about the compiled instructions emitted to `self.insts`. The\n/// `entry` member of the patch refers to the first instruction\n/// (the entry point), while the `hole` member contains zero or\n/// more offsets to partial instructions that need to be backpatched.\n/// The c_* routine can't know where its list of instructions are going to\n/// jump to after execution, so it is up to the caller to patch\n/// these jumps to point to the right place. So compiling some\n/// expression, e, we would end up with a situation that looked like:\n///\n/// ```text\n/// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n///                     ^              ^             ^\n///                     |                \\         /\n///                   entry                \\     /\n///                                         hole\n/// ```\n///\n/// To compile two expressions, e1 and e2, concatinated together we\n/// would do:\n///\n/// ```ignore\n/// let patch1 = self.c(e1);\n/// let patch2 = self.c(e2);\n/// ```\n///\n/// while leaves us with a situation that looks like\n///\n/// ```text\n/// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n///                     ^        ^            ^        ^\n///                     |        |            |        |\n///                entry1        hole1   entry2        hole2\n/// ```\n///\n/// Then to merge the two patches together into one we would backpatch\n/// hole1 with entry2 and return a new patch that enters at entry1\n/// and has hole2 for a hole. In fact, if you look at the c_concat\n/// method you will see that it does exactly this, though it handles\n/// a list of expressions rather than just the two that we use for\n/// an example.\nfn c(&mut self, expr: &Hir) -> Result {\n    use prog;\n    use syntax::hir::HirKind::*;\n\n    self.check_size()?;\n    match *expr.kind() {\n        Empty => Ok(Patch { hole: Hole::None, entry: self.insts.len() }),\n        Literal(hir::Literal::Unicode(c)) => {\n            self.c_literal(&[c])\n        }\n        Literal(hir::Literal::Byte(b)) => {\n            assert!(self.compiled.uses_bytes());\n            self.c_bytes(&[b])\n        }\n        Class(hir::Class::Unicode(ref cls)) => {\n            self.c_class(cls.ranges())\n        }\n        Class(hir::Class::Bytes(ref cls)) => {\n            if self.compiled.uses_bytes() {\n                self.c_class_bytes(cls.ranges())\n            } else {\n                assert!(cls.is_all_ascii());\n                let mut char_ranges = vec![];\n                for r in cls.iter() {\n                    let (s, e) = (r.start() as char, r.end() as char);\n                    char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                }\n                self.c_class(&char_ranges)\n            }\n        }\n        Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::EndLine)\n        }\n        Anchor(hir::Anchor::StartLine) => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::StartLine)\n        }\n        Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::StartLine)\n        }\n        Anchor(hir::Anchor::EndLine) => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::EndLine)\n        }\n        Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n            self.c_empty_look(prog::EmptyLook::EndText)\n        }\n        Anchor(hir::Anchor::StartText) => {\n            self.c_empty_look(prog::EmptyLook::StartText)\n        }\n        Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n            self.c_empty_look(prog::EmptyLook::StartText)\n        }\n        Anchor(hir::Anchor::EndText) => {\n            self.c_empty_look(prog::EmptyLook::EndText)\n        }\n        WordBoundary(hir::WordBoundary::Unicode) => {\n            self.compiled.has_unicode_word_boundary = true;\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::WordBoundary)\n        }\n        WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n            self.compiled.has_unicode_word_boundary = true;\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n        }\n        WordBoundary(hir::WordBoundary::Ascii) => {\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n        }\n        WordBoundary(hir::WordBoundary::AsciiNegate) => {\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n        }\n        Group(ref g) => {\n            match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            }\n        }\n        Concat(ref es) => {\n            if self.compiled.is_reverse {\n                self.c_concat(es.iter().rev())\n            } else {\n                self.c_concat(es)\n            }\n        }\n        Alternation(ref es) => self.c_alternate(&**es),\n        Repetition(ref rep) => self.c_repeat(rep),\n    }\n}\n",
  "depend_pt": ""
}