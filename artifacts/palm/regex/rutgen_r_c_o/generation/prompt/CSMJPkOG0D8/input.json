{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/dfa.rs\n// crate name is regex\ntype InstPtr = u32;\ntype StatePtr = u32;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::iter::repeat;\nuse std::mem;\nuse exec::ProgramCache;\nuse prog::{Inst, Program};\nuse sparse::SparseSet;\nconst STATE_UNKNOWN: StatePtr = 1 << 31;\nconst STATE_DEAD: StatePtr = STATE_UNKNOWN + 1;\nconst STATE_QUIT: StatePtr = STATE_DEAD + 1;\nconst STATE_START: StatePtr = 1 << 30;\nconst STATE_MATCH: StatePtr = 1 << 29;\nconst STATE_MAX: StatePtr = STATE_MATCH - 1;\n#[derive(Debug)]\npub struct Fsm<'a> {\n    /// prog contains the NFA instruction opcodes. DFA execution uses either\n    /// the `dfa` instructions or the `dfa_reverse` instructions from\n    /// `exec::ExecReadOnly`. (It never uses `ExecReadOnly.nfa`, which may have\n    /// Unicode opcodes that cannot be executed by the DFA.)\n    prog: &'a Program,\n    /// The start state. We record it here because the pointer may change\n    /// when the cache is wiped.\n    start: StatePtr,\n    /// The current position in the input.\n    at: usize,\n    /// Should we quit after seeing the first match? e.g., When the caller\n    /// uses `is_match` or `shortest_match`.\n    quit_after_match: bool,\n    /// The last state that matched.\n    ///\n    /// When no match has occurred, this is set to STATE_UNKNOWN.\n    ///\n    /// This is only useful when matching regex sets. The last match state\n    /// is useful because it contains all of the match instructions seen,\n    /// thereby allowing us to enumerate which regexes in the set matched.\n    last_match_si: StatePtr,\n    /// The input position of the last cache flush. We use this to determine\n    /// if we're thrashing in the cache too often. If so, the DFA quits so\n    /// that we can fall back to the NFA algorithm.\n    last_cache_flush: usize,\n    /// All cached DFA information that is persisted between searches.\n    cache: &'a mut CacheInner,\n}\n#[derive(Clone, Eq, Hash, PartialEq)]\nstruct State {\n    data: Box<[u8]>,\n}\n#[derive(Copy, Clone, Debug)]\nstruct Byte(u16);\n#[derive(Clone, Debug)]\npub struct SparseSet {\n    /// Dense contains the instruction pointers in the order in which they\n    /// were inserted. Accessing elements >= self.size is illegal.\n    dense: Vec<usize>,\n    /// Sparse maps instruction pointers to their location in dense.\n    ///\n    /// An instruction pointer is in the set if and only if\n    /// sparse[ip] < size && ip == dense[sparse[ip]].\n    sparse: Vec<usize>,\n    /// The number of elements in the set.\n    size: usize,\n}\nstruct InstPtrs<'a> {\n    base: usize,\n    data: &'a [u8],\n}\n#[derive(Clone)]\npub struct Program {\n    /// A sequence of instructions that represents an NFA.\n    pub insts: Vec<Inst>,\n    /// Pointers to each Match instruction in the sequence.\n    ///\n    /// This is always length 1 unless this program represents a regex set.\n    pub matches: Vec<InstPtr>,\n    /// The ordered sequence of all capture groups extracted from the AST.\n    /// Unnamed groups are `None`.\n    pub captures: Vec<Option<String>>,\n    /// Pointers to all named capture groups into `captures`.\n    pub capture_name_idx: Arc<HashMap<String, usize>>,\n    /// A pointer to the start instruction. This can vary depending on how\n    /// the program was compiled. For example, programs for use with the DFA\n    /// engine have a `.*?` inserted at the beginning of unanchored regular\n    /// expressions. The actual starting point of the program is after the\n    /// `.*?`.\n    pub start: InstPtr,\n    /// A set of equivalence classes for discriminating bytes in the compiled\n    /// program.\n    pub byte_classes: Vec<u8>,\n    /// When true, this program can only match valid UTF-8.\n    pub only_utf8: bool,\n    /// When true, this program uses byte range instructions instead of Unicode\n    /// range instructions.\n    pub is_bytes: bool,\n    /// When true, the program is compiled for DFA matching. For example, this\n    /// implies `is_bytes` and also inserts a preceding `.*?` for unanchored\n    /// regexes.\n    pub is_dfa: bool,\n    /// When true, the program matches text in reverse (for use only in the\n    /// DFA).\n    pub is_reverse: bool,\n    /// Whether the regex must match from the start of the input.\n    pub is_anchored_start: bool,\n    /// Whether the regex must match at the end of the input.\n    pub is_anchored_end: bool,\n    /// Whether this program contains a Unicode word boundary instruction.\n    pub has_unicode_word_boundary: bool,\n    /// A possibly empty machine for very quickly matching prefix literals.\n    pub prefixes: LiteralSearcher,\n    /// A limit on the size of the cache that the DFA is allowed to use while\n    /// matching.\n    ///\n    /// The cache limit specifies approximately how much space we're willing to\n    /// give to the state cache. Once the state cache exceeds the size, it is\n    /// wiped and all states must be re-computed.\n    ///\n    /// Note that this value does not impact correctness. It can be set to 0\n    /// and the DFA will run just fine. (It will only ever store exactly one\n    /// state in the cache, and will likely run very slowly, but it will work.)\n    ///\n    /// Also note that this limit is *per thread of execution*. That is,\n    /// if the same regex is used to search text across multiple threads\n    /// simultaneously, then the DFA cache is not shared. Instead, copies are\n    /// made.\n    pub dfa_size_limit: usize,\n}\n#[derive(Clone, Debug)]\nstruct CacheInner {\n    /// A cache of pre-compiled DFA states, keyed by the set of NFA states\n    /// and the set of empty-width flags set at the byte in the input when the\n    /// state was observed.\n    ///\n    /// A StatePtr is effectively a `*State`, but to avoid various inconvenient\n    /// things, we just pass indexes around manually. The performance impact of\n    /// this is probably an instruction or two in the inner loop. However, on\n    /// 64 bit, each StatePtr is half the size of a *State.\n    compiled: HashMap<State, StatePtr>,\n    /// The transition table.\n    ///\n    /// The transition table is laid out in row-major order, where states are\n    /// rows and the transitions for each state are columns. At a high level,\n    /// given state `s` and byte `b`, the next state can be found at index\n    /// `s * 256 + b`.\n    ///\n    /// This is, of course, a lie. A StatePtr is actually a pointer to the\n    /// *start* of a row in this table. When indexing in the DFA's inner loop,\n    /// this removes the need to multiply the StatePtr by the stride. Yes, it\n    /// matters. This reduces the number of states we can store, but: the\n    /// stride is rarely 256 since we define transitions in terms of\n    /// *equivalence classes* of bytes. Each class corresponds to a set of\n    /// bytes that never discriminate a distinct path through the DFA from each\n    /// other.\n    trans: Transitions,\n    /// Our set of states. Note that `StatePtr / num_byte_classes` indexes\n    /// this Vec rather than just a `StatePtr`.\n    states: Vec<State>,\n    /// A set of cached start states, which are limited to the number of\n    /// permutations of flags set just before the initial byte of input. (The\n    /// index into this vec is a `EmptyFlags`.)\n    ///\n    /// N.B. A start state can be \"dead\" (i.e., no possible match), so we\n    /// represent it with a StatePtr.\n    start_states: Vec<StatePtr>,\n    /// Stack scratch space used to follow epsilon transitions in the NFA.\n    /// (This permits us to avoid recursion.)\n    ///\n    /// The maximum stack size is the number of NFA states.\n    stack: Vec<InstPtr>,\n    /// The total number of times this cache has been flushed by the DFA\n    /// because of space constraints.\n    flush_count: u64,\n    /// The total heap size of the DFA's cache. We use this to determine when\n    /// we should flush the cache.\n    size: usize,\n}\n#[derive(Clone, Debug)]\npub enum Result<T> {\n    Match(T),\n    NoMatch(usize),\n    Quit,\n}\nimpl<'a> Fsm<'a> {\n    #[inline(always)]\n    pub fn forward(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {}\n    #[inline(always)]\n    pub fn reverse(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {}\n    #[inline(always)]\n    pub fn forward_many(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {}\n    #[inline(always)]\n    fn exec_at(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize> {\n        debug_assert!(! self.prog.is_reverse);\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at < text.len() {\n            while next_si <= STATE_MAX && at < text.len() {\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX || at + 2 >= text.len() {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n                if next_si > STATE_MAX {\n                    break;\n                }\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n            }\n            if next_si & STATE_MATCH > 0 {\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at - 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n                if self.prog.matches.len() > 1 {\n                    let state = self.state(next_si);\n                    let just_matches = state\n                        .inst_ptrs()\n                        .all(|ip| self.prog[ip].is_match());\n                    if just_matches {\n                        return result;\n                    }\n                }\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si && at + 2 < text.len() {\n                    next_si = unsafe { self.next_si(next_si & !STATE_MATCH, text, at) };\n                    at += 1;\n                }\n                if at > cur {\n                    result = Result::Match(at - 2);\n                }\n            } else if next_si & STATE_START > 0 {\n                debug_assert!(self.has_prefix());\n                next_si &= !STATE_START;\n                prev_si = next_si;\n                at = match self.prefix_at(text, at) {\n                    None => return Result::NoMatch(text.len()),\n                    Some(i) => i,\n                };\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                let byte = Byte::byte(text[at - 1]);\n                prev_si &= STATE_MAX;\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at - 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n        prev_si &= STATE_MAX;\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(text.len()),\n            Some(si) => si & !STATE_START,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(text.len());\n        }\n        result\n    }\n    #[inline(always)]\n    fn exec_at_reverse(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize> {}\n    #[inline(always)]\n    unsafe fn next_si(&self, si: StatePtr, text: &[u8], i: usize) -> StatePtr {\n        debug_assert!(i < text.len());\n        let b = *text.get_unchecked(i);\n        debug_assert!((b as usize) < self.prog.byte_classes.len());\n        let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n        self.cache.trans.next_unchecked(si, cls as usize)\n    }\n    fn exec_byte(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        mut si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr> {}\n    fn follow_epsilons(&mut self, ip: InstPtr, q: &mut SparseSet, flags: EmptyFlags) {}\n    fn cached_state(\n        &mut self,\n        q: &SparseSet,\n        mut state_flags: StateFlags,\n        current_state: Option<&mut StatePtr>,\n    ) -> Option<StatePtr> {}\n    fn cached_state_key(\n        &mut self,\n        q: &SparseSet,\n        state_flags: &mut StateFlags,\n    ) -> Option<State> {}\n    fn clear_cache_and_save(&mut self, current_state: Option<&mut StatePtr>) -> bool {}\n    fn clear_cache(&mut self) -> bool {}\n    fn restore_state(&mut self, state: State) -> Option<StatePtr> {}\n    fn next_state(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr> {\n        if si == STATE_DEAD {\n            return Some(STATE_DEAD);\n        }\n        match self.cache.trans.next(si, self.byte_class(b)) {\n            STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),\n            STATE_QUIT => None,\n            STATE_DEAD => Some(STATE_DEAD),\n            nsi => Some(nsi),\n        }\n    }\n    #[inline(always)]\n    fn start_state(\n        &mut self,\n        q: &mut SparseSet,\n        empty_flags: EmptyFlags,\n        state_flags: StateFlags,\n    ) -> Option<StatePtr> {}\n    fn start_flags(&self, text: &[u8], at: usize) -> (EmptyFlags, StateFlags) {}\n    fn start_flags_reverse(&self, text: &[u8], at: usize) -> (EmptyFlags, StateFlags) {}\n    fn state(&self, si: StatePtr) -> &State {\n        &self.cache.states[si as usize / self.num_byte_classes()]\n    }\n    fn add_state(&mut self, state: State) -> Option<StatePtr> {}\n    fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {\n        self.prog.prefixes.find(&text[at..]).map(|(s, _)| at + s)\n    }\n    fn num_byte_classes(&self) -> usize {}\n    #[inline(always)]\n    fn byte_class(&self, b: Byte) -> usize {}\n    #[inline(always)]\n    fn u8_class(&self, b: u8) -> usize {}\n    fn continue_past_first_match(&self) -> bool {}\n    fn has_prefix(&self) -> bool {\n        !self.prog.is_reverse && !self.prog.prefixes.is_empty()\n            && !self.prog.is_anchored_start\n    }\n    fn start_ptr(&self, si: StatePtr) -> StatePtr {}\n    fn approximate_size(&self) -> usize {}\n}\nimpl State {\n    fn flags(&self) -> StateFlags {}\n    fn inst_ptrs(&self) -> InstPtrs {\n        InstPtrs {\n            base: 0,\n            data: &self.data[1..],\n        }\n    }\n}\nimpl Byte {\n    fn byte(b: u8) -> Self {\n        Byte(b as u16)\n    }\n    fn eof() -> Self {\n        Byte(256)\n    }\n    fn is_eof(&self) -> bool {}\n    fn is_ascii_word(&self) -> bool {}\n    fn as_byte(&self) -> Option<u8> {}\n}\nimpl<T> Result<T> {\n    pub fn is_match(&self) -> bool {}\n    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> Result<U> {}\n    fn set_non_match(self, at: usize) -> Result<T> {\n        match self {\n            Result::NoMatch(_) => Result::NoMatch(at),\n            r => r,\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Executes the DFA on a forward NFA.\n///\n/// {qcur,qnext} are scratch ordered sets which may be non-empty.\nfn exec_at(\n    &mut self,\n    qcur: &mut SparseSet,\n    qnext: &mut SparseSet,\n    text: &[u8],\n) -> Result<usize> {\n    // For the most part, the DFA is basically:\n    //\n    //   last_match = null\n    //   while current_byte != EOF:\n    //     si = current_state.next[current_byte]\n    //     if si is match\n    //       last_match = si\n    //   return last_match\n    //\n    // However, we need to deal with a few things:\n    //\n    //   1. This is an *online* DFA, so the current state's next list\n    //      may not point to anywhere yet, so we must go out and compute\n    //      them. (They are then cached into the current state's next list\n    //      to avoid re-computation.)\n    //   2. If we come across a state that is known to be dead (i.e., never\n    //      leads to a match), then we can quit early.\n    //   3. If the caller just wants to know if a match occurs, then we\n    //      can quit as soon as we know we have a match. (Full leftmost\n    //      first semantics require continuing on.)\n    //   4. If we're in the start state, then we can use a pre-computed set\n    //      of prefix literals to skip quickly along the input.\n    //   5. After the input is exhausted, we run the DFA on one symbol\n    //      that stands for EOF. This is useful for handling empty width\n    //      assertions.\n    //   6. We can't actually do state.next[byte]. Instead, we have to do\n    //      state.next[byte_classes[byte]], which permits us to keep the\n    //      'next' list very small.\n    //\n    // Since there's a bunch of extra stuff we need to consider, we do some\n    // pretty hairy tricks to get the inner loop to run as fast as\n    // possible.\n    debug_assert!(!self.prog.is_reverse);\n\n    // The last match is the currently known ending match position. It is\n    // reported as an index to the most recent byte that resulted in a\n    // transition to a match state and is always stored in capture slot `1`\n    // when searching forwards. Its maximum value is `text.len()`.\n    let mut result = Result::NoMatch(self.at);\n    let (mut prev_si, mut next_si) = (self.start, self.start);\n    let mut at = self.at;\n    while at < text.len() {\n        // This is the real inner loop. We take advantage of special bits\n        // set in the state pointer to determine whether a state is in the\n        // \"common\" case or not. Specifically, the common case is a\n        // non-match non-start non-dead state that has already been\n        // computed. So long as we remain in the common case, this inner\n        // loop will chew through the input.\n        //\n        // We also unroll the loop 4 times to amortize the cost of checking\n        // whether we've consumed the entire input. We are also careful\n        // to make sure that `prev_si` always represents the previous state\n        // and `next_si` always represents the next state after the loop\n        // exits, even if it isn't always true inside the loop.\n        while next_si <= STATE_MAX && at < text.len() {\n            // Argument for safety is in the definition of next_si.\n            prev_si = unsafe { self.next_si(next_si, text, at) };\n            at += 1;\n            if prev_si > STATE_MAX || at + 2 >= text.len() {\n                mem::swap(&mut prev_si, &mut next_si);\n                break;\n            }\n            next_si = unsafe { self.next_si(prev_si, text, at) };\n            at += 1;\n            if next_si > STATE_MAX {\n                break;\n            }\n            prev_si = unsafe { self.next_si(next_si, text, at) };\n            at += 1;\n            if prev_si > STATE_MAX {\n                mem::swap(&mut prev_si, &mut next_si);\n                break;\n            }\n            next_si = unsafe { self.next_si(prev_si, text, at) };\n            at += 1;\n        }\n        if next_si & STATE_MATCH > 0 {\n            // A match state is outside of the common case because it needs\n            // special case analysis. In particular, we need to record the\n            // last position as having matched and possibly quit the DFA if\n            // we don't need to keep matching.\n            next_si &= !STATE_MATCH;\n            result = Result::Match(at - 1);\n            if self.quit_after_match {\n                return result;\n            }\n            self.last_match_si = next_si;\n            prev_si = next_si;\n\n            // This permits short-circuiting when matching a regex set.\n            // In particular, if this DFA state contains only match states,\n            // then it's impossible to extend the set of matches since\n            // match states are final. Therefore, we can quit.\n            if self.prog.matches.len() > 1 {\n                let state = self.state(next_si);\n                let just_matches = state.inst_ptrs()\n                     .all(|ip| self.prog[ip].is_match());\n                if just_matches {\n                    return result;\n                }\n            }\n\n            // Another inner loop! If the DFA stays in this particular\n            // match state, then we can rip through all of the input\n            // very quickly, and only recording the match location once\n            // we've left this particular state.\n            let cur = at;\n            while (next_si & !STATE_MATCH) == prev_si\n                && at + 2 < text.len() {\n                // Argument for safety is in the definition of next_si.\n                next_si = unsafe {\n                    self.next_si(next_si & !STATE_MATCH, text, at)\n                };\n                at += 1;\n            }\n            if at > cur {\n                result = Result::Match(at - 2);\n            }\n        } else if next_si & STATE_START > 0 {\n            // A start state isn't in the common case because we may\n            // what to do quick prefix scanning. If the program doesn't\n            // have a detected prefix, then start states are actually\n            // considered common and this case is never reached.\n            debug_assert!(self.has_prefix());\n            next_si &= !STATE_START;\n            prev_si = next_si;\n            at = match self.prefix_at(text, at) {\n                None => return Result::NoMatch(text.len()),\n                Some(i) => i,\n            };\n        } else if next_si >= STATE_UNKNOWN {\n            if next_si == STATE_QUIT {\n                return Result::Quit;\n            }\n            // Finally, this corresponds to the case where the transition\n            // entered a state that can never lead to a match or a state\n            // that hasn't been computed yet. The latter being the \"slow\"\n            // path.\n            let byte = Byte::byte(text[at - 1]);\n            // We no longer care about the special bits in the state\n            // pointer.\n            prev_si &= STATE_MAX;\n            // Record where we are. This is used to track progress for\n            // determining whether we should quit if we've flushed the\n            // cache too much.\n            self.at = at;\n            next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return result.set_non_match(at),\n                Some(si) => si,\n            };\n            debug_assert!(next_si != STATE_UNKNOWN);\n            if next_si & STATE_MATCH > 0 {\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at - 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n            }\n            prev_si = next_si;\n        } else {\n            prev_si = next_si;\n        }\n    }\n\n    // Run the DFA once more on the special EOF senitnel value.\n    // We don't care about the special bits in the state pointer any more,\n    // so get rid of them.\n    prev_si &= STATE_MAX;\n    prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n        None => return Result::Quit,\n        Some(STATE_DEAD) => return result.set_non_match(text.len()),\n        Some(si) => si & !STATE_START,\n    };\n    debug_assert!(prev_si != STATE_UNKNOWN);\n    if prev_si & STATE_MATCH > 0 {\n        prev_si &= !STATE_MATCH;\n        self.last_match_si = prev_si;\n        result = Result::Match(text.len());\n    }\n    result\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}