{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/translate.rs\n// crate name is regex_syntax\ntype Result<T> = result::Result<T, Error>;\nuse std::cell::{Cell, RefCell};\nuse std::result;\nuse ast::{self, Ast, Span, Visitor};\nuse hir::{self, Error, ErrorKind, Hir};\nuse unicode::{self, ClassQuery};\n#[derive(Clone, Debug)]\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}\n#[derive(Clone, Copy, Debug, Default)]\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    info: HirInfo,\n}\n#[derive(Clone, Debug)]\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    allow_invalid_utf8: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Repetition {\n    /// The kind of this repetition operator.\n    pub kind: RepetitionKind,\n    /// Whether this repetition operator is greedy or not. A greedy operator\n    /// will match as much as it can. A non-greedy operator will match as\n    /// little as it can.\n    ///\n    /// Typically, operators are greedy by default and are only non-greedy when\n    /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is\n    /// not. However, this can be inverted via the `U` \"ungreedy\" flag.\n    pub greedy: bool,\n    /// The expression being repeated.\n    pub hir: Box<Hir>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Repetition {\n    /// The span of this operation.\n    pub span: Span,\n    /// The actual operation.\n    pub op: RepetitionOp,\n    /// Whether this operation was applied greedily or not.\n    pub greedy: bool,\n    /// The regular expression under repetition.\n    pub ast: Box<Ast>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum RepetitionRange {\n    /// Matches a sub-expression exactly this many times.\n    Exactly(u32),\n    /// Matches a sub-expression at least this many times.\n    AtLeast(u32),\n    /// Matches a sub-expression at least `m` times and at most `n` times.\n    Bounded(u32, u32),\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum RepetitionKind {\n    /// Matches a sub-expression zero or one times.\n    ZeroOrOne,\n    /// Matches a sub-expression zero or more times.\n    ZeroOrMore,\n    /// Matches a sub-expression one or more times.\n    OneOrMore,\n    /// Matches a sub-expression within a bounded range of times.\n    Range(RepetitionRange),\n}\nimpl<'t, 'p> TranslatorI<'t, 'p> {\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {}\n    fn trans(&self) -> &Translator {}\n    fn push(&self, frame: HirFrame) {}\n    fn pop(&self) -> Option<HirFrame> {}\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {}\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {}\n    fn hir_literal(&self, lit: &ast::Literal) -> Result<Hir> {}\n    fn literal_to_char(&self, lit: &ast::Literal) -> Result<hir::Literal> {}\n    fn hir_from_char(&self, span: Span, c: char) -> Result<Hir> {}\n    fn hir_from_char_case_insensitive(&self, span: Span, c: char) -> Result<Hir> {}\n    fn hir_dot(&self, span: Span) -> Result<Hir> {}\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {}\n    fn hir_group(&self, group: &ast::Group, expr: Hir) -> Hir {}\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {\n        let kind = match rep.op.kind {\n            ast::RepetitionKind::ZeroOrOne => hir::RepetitionKind::ZeroOrOne,\n            ast::RepetitionKind::ZeroOrMore => hir::RepetitionKind::ZeroOrMore,\n            ast::RepetitionKind::OneOrMore => hir::RepetitionKind::OneOrMore,\n            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(m, n)) => {\n                hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(m, n))\n            }\n        };\n        let greedy = if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };\n        Hir::repetition(hir::Repetition {\n            kind: kind,\n            greedy: greedy,\n            hir: Box::new(expr),\n        })\n    }\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {}\n    fn hir_perl_unicode_class(&self, ast_class: &ast::ClassPerl) -> hir::ClassUnicode {}\n    fn hir_perl_byte_class(&self, ast_class: &ast::ClassPerl) -> hir::ClassBytes {}\n    fn unicode_fold_and_negate(&self, negated: bool, class: &mut hir::ClassUnicode) {}\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {}\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {}\n}\nimpl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {}\n    fn merge(&mut self, previous: &Flags) {}\n    fn case_insensitive(&self) -> bool {}\n    fn multi_line(&self) -> bool {}\n    fn dot_matches_new_line(&self) -> bool {}\n    fn swap_greed(&self) -> bool {\n        self.swap_greed.unwrap_or(false)\n    }\n    fn unicode(&self) -> bool {}\n}\nimpl Hir {\n    pub fn kind(&self) -> &HirKind {}\n    pub fn into_kind(mut self) -> HirKind {}\n    pub fn empty() -> Hir {}\n    pub fn literal(lit: Literal) -> Hir {}\n    pub fn class(class: Class) -> Hir {}\n    pub fn anchor(anchor: Anchor) -> Hir {}\n    pub fn word_boundary(word_boundary: WordBoundary) -> Hir {}\n    pub fn repetition(rep: Repetition) -> Hir {\n        let mut info = HirInfo::new();\n        info.set_always_utf8(rep.hir.is_always_utf8());\n        info.set_all_assertions(rep.hir.is_all_assertions());\n        info.set_anchored_start(!rep.is_match_empty() && rep.hir.is_anchored_start());\n        info.set_anchored_end(!rep.is_match_empty() && rep.hir.is_anchored_end());\n        info.set_any_anchored_start(rep.hir.is_any_anchored_start());\n        info.set_any_anchored_end(rep.hir.is_any_anchored_end());\n        info.set_match_empty(rep.is_match_empty() || rep.hir.is_match_empty());\n        Hir {\n            kind: HirKind::Repetition(rep),\n            info: info,\n        }\n    }\n    pub fn group(group: Group) -> Hir {}\n    pub fn concat(mut exprs: Vec<Hir>) -> Hir {}\n    pub fn alternation(mut exprs: Vec<Hir>) -> Hir {}\n    pub fn dot(bytes: bool) -> Hir {}\n    pub fn any(bytes: bool) -> Hir {}\n    pub fn is_always_utf8(&self) -> bool {}\n    pub fn is_all_assertions(&self) -> bool {}\n    pub fn is_anchored_start(&self) -> bool {}\n    pub fn is_anchored_end(&self) -> bool {}\n    pub fn is_any_anchored_start(&self) -> bool {}\n    pub fn is_any_anchored_end(&self) -> bool {}\n    pub fn is_match_empty(&self) -> bool {}\n}\n\nThe function to be tested is presented as follows:\nfn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {\n    let kind = match rep.op.kind {\n        ast::RepetitionKind::ZeroOrOne => hir::RepetitionKind::ZeroOrOne,\n        ast::RepetitionKind::ZeroOrMore => hir::RepetitionKind::ZeroOrMore,\n        ast::RepetitionKind::OneOrMore => hir::RepetitionKind::OneOrMore,\n        ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n            hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(m))\n        }\n        ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n            hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(m))\n        }\n        ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(m,n)) => {\n            hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(m, n))\n        }\n    };\n    let greedy =\n        if self.flags().swap_greed() {\n            !rep.greedy\n        } else {\n            rep.greedy\n        };\n    Hir::repetition(hir::Repetition {\n        kind: kind,\n        greedy: greedy,\n        hir: Box::new(expr),\n    })\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}