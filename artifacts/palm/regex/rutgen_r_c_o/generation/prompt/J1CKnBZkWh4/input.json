{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/parse.rs\n// crate name is regex_syntax\ntype Result<T> = result::Result<T, ast::Error>;\nuse std::borrow::Borrow;\nuse std::cell::{Cell, RefCell};\nuse std::mem;\nuse std::result;\nuse ast::{self, Ast, Position, Span};\nuse either::Either;\nuse is_meta_character;\n#[derive(Clone, Debug)]\nstruct ParserI<'s, P> {\n    /// The parser state/configuration.\n    parser: P,\n    /// The full regular expression provided by the user.\n    pattern: &'s str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassSetUnion {\n    /// The span of the items in this operation. e.g., the `a-z0-9` in\n    /// `[^a-z0-9]`\n    pub span: Span,\n    /// The sequence of items that make up this union.\n    pub items: Vec<ClassSetItem>,\n}\n#[derive(Clone, Debug)]\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug)]\npub struct Parser {\n    /// The current position of the parser.\n    pos: Cell<Position>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The maximum number of open parens/brackets allowed. If the parser\n    /// exceeds this number, then an error is returned.\n    nest_limit: u32,\n    /// Whether to support octal syntax or not. When `false`, the parser will\n    /// return an error helpfully pointing out that backreferences are not\n    /// supported.\n    octal: bool,\n    /// The initial setting for `ignore_whitespace` as provided by\n    /// Th`ParserBuilder`. is is used when reseting the parser's state.\n    initial_ignore_whitespace: bool,\n    /// Whether whitespace should be ignored. When enabled, comments are\n    /// also permitted.\n    ignore_whitespace: Cell<bool>,\n    /// A list of comments, in order of appearance.\n    comments: RefCell<Vec<ast::Comment>>,\n    /// A stack of grouped sub-expressions, including alternations.\n    stack_group: RefCell<Vec<GroupState>>,\n    /// A stack of nested character classes. This is only non-empty when\n    /// parsing a class.\n    stack_class: RefCell<Vec<ClassState>>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<ast::CaptureName>>,\n    /// A scratch buffer used in various places. Mostly this is used to\n    /// accumulate relevant characters from parts of a pattern.\n    scratch: RefCell<String>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassSet {\n    /// An item, which can be a single literal, range, nested character class\n    /// or a union of items.\n    Item(ClassSetItem),\n    /// A single binary operation (i.e., &&, -- or ~~).\n    BinaryOp(ClassSetBinaryOp),\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum ClassSetBinaryOpKind {\n    /// The intersection of two sets, e.g., `\\pN&&[a-z]`.\n    Intersection,\n    /// The difference of two sets, e.g., `\\pN--[0-9]`.\n    Difference,\n    /// The symmetric difference of two sets. The symmetric difference is the\n    /// set of elements belonging to one but not both sets.\n    /// e.g., `[\\pL~~[:ascii:]]`.\n    SymmetricDifference,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum ClassSetItem {\n    /// An empty item.\n    ///\n    /// Note that a bracketed character class cannot contain a single empty\n    /// item. Empty items can appear when using one of the binary operators.\n    /// For example, `[&&]` is the intersection of two empty classes.\n    Empty(Span),\n    /// A single literal.\n    Literal(Literal),\n    /// A range between two literals.\n    Range(ClassSetRange),\n    /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.\n    Ascii(ClassAscii),\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(Box<ClassBracketed>),\n    /// A union of items.\n    Union(ClassSetUnion),\n}\n#[derive(Clone, Debug)]\nenum ClassState {\n    /// This state is pushed whenever an opening bracket is found.\n    Open {\n        /// The union of class items immediately preceding this class.\n        union: ast::ClassSetUnion,\n        /// The class that has been opened. Typically this just corresponds\n        /// to the `[`, but it can also include `[^` since `^` indicates\n        /// negation of the class.\n        set: ast::ClassBracketed,\n    },\n    /// This state is pushed when a operator is seen. When popped, the stored\n    /// set becomes the left hand side of the operator.\n    Op {\n        /// The type of the operation, i.e., &&, -- or ~~.\n        kind: ast::ClassSetBinaryOpKind,\n        /// The left-hand side of the operator.\n        lhs: ast::ClassSet,\n    },\n}\nimpl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {}\n    fn parser(&self) -> &Parser {\n        self.parser.borrow()\n    }\n    fn pattern(&self) -> &str {}\n    fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {}\n    fn offset(&self) -> usize {}\n    fn line(&self) -> usize {}\n    fn column(&self) -> usize {}\n    fn next_capture_index(&self, span: Span) -> Result<u32> {}\n    fn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()> {}\n    fn ignore_whitespace(&self) -> bool {}\n    fn char(&self) -> char {\n        self.char_at(self.offset())\n    }\n    fn char_at(&self, i: usize) -> char {}\n    fn bump(&self) -> bool {}\n    fn bump_if(&self, prefix: &str) -> bool {}\n    fn is_lookaround_prefix(&self) -> bool {}\n    fn bump_and_bump_space(&self) -> bool {}\n    fn bump_space(&self) {}\n    fn peek(&self) -> Option<char> {}\n    fn peek_space(&self) -> Option<char> {}\n    fn is_eof(&self) -> bool {}\n    fn pos(&self) -> Position {}\n    fn span(&self) -> Span {\n        Span::splat(self.pos())\n    }\n    fn span_char(&self) -> Span {}\n    fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {}\n    fn push_or_add_alternation(&self, concat: ast::Concat) {}\n    fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {}\n    fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {}\n    fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {}\n    fn push_class_open(\n        &self,\n        parent_union: ast::ClassSetUnion,\n    ) -> Result<ast::ClassSetUnion> {}\n    fn pop_class(\n        &self,\n        nested_union: ast::ClassSetUnion,\n    ) -> Result<Either<ast::ClassSetUnion, ast::Class>> {}\n    fn unclosed_class_error(&self) -> ast::Error {}\n    fn push_class_op(\n        &self,\n        next_kind: ast::ClassSetBinaryOpKind,\n        next_union: ast::ClassSetUnion,\n    ) -> ast::ClassSetUnion {\n        let item = ast::ClassSet::Item(next_union.into_item());\n        let new_lhs = self.pop_class_op(item);\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Op {\n                kind: next_kind,\n                lhs: new_lhs,\n            });\n        ast::ClassSetUnion {\n            span: self.span(),\n            items: vec![],\n        }\n    }\n    fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {\n        let mut stack = self.parser().stack_class.borrow_mut();\n        let (kind, lhs) = match stack.pop() {\n            Some(ClassState::Op { kind, lhs }) => (kind, lhs),\n            Some(state @ ClassState::Open { .. }) => {\n                stack.push(state);\n                return rhs;\n            }\n            None => unreachable!(),\n        };\n        let span = Span::new(lhs.span().start, rhs.span().end);\n        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span: span,\n            kind: kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n    }\n}\nimpl ClassSetUnion {\n    pub fn push(&mut self, item: ClassSetItem) {}\n    pub fn into_item(mut self) -> ClassSetItem {\n        match self.items.len() {\n            0 => ClassSetItem::Empty(self.span),\n            1 => self.items.pop().unwrap(),\n            _ => ClassSetItem::Union(self),\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Push the current set of class items on to the class parser's stack as\n/// the left hand side of the given operator.\n///\n/// A fresh set union is returned, which should be used to build the right\n/// hand side of this operator.\nfn push_class_op(\n    &self,\n    next_kind: ast::ClassSetBinaryOpKind,\n    next_union: ast::ClassSetUnion,\n) -> ast::ClassSetUnion {\n\n    let item = ast::ClassSet::Item(next_union.into_item());\n    let new_lhs = self.pop_class_op(item);\n    self.parser().stack_class.borrow_mut().push(ClassState::Op {\n        kind: next_kind,\n        lhs: new_lhs,\n    });\n    ast::ClassSetUnion { span: self.span(), items: vec![] }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}