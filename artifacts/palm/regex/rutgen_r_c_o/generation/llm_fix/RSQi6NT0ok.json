{
  "name": "regex_syntax::ast::visitor::ast::visitor::HeapVisitor<'a>::induct_class",
  "name_with_impl": "regex_syntax::ast::visitor::{impl#0}::induct_class",
  "mod_info": {
    "name": "ast::visitor",
    "loc": "regex-syntax/src/ast/mod.rs:23:1:23:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/visitor.rs:406:5:443:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches ClassInduct::BinaryOp(op) is true\n",
        "// constraint: *ast matches ClassInduct::BinaryOp(op) is true\n",
        "// expected return value/type: Some(ClassFrame::BinaryLHS {\n                    op: op,\n                    lhs: &op.lhs,\n                    rhs: &op.rhs,\n                })\n"
      ],
      "input_infer": "*ast: ClassInduct::BinaryOp with valid op having lhs and rhs both as non-empty ClassSet; op.kind being a valid binary operation type\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(0, 2),",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(lhs_class_set),",
                "        rhs: Box::new(rhs_class_set),",
                "    };",
                "    let ast = ClassInduct::BinaryOp(&op);",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert!(matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs }));"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert_eq!(op, &op);"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert_eq!(lhs, &op.lhs);"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert_eq!(rhs, &op.rhs);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert!(matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs }));",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert_eq!(op, &op);",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert_eq!(lhs, &op.lhs);",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    assert_eq!(rhs, &op.rhs);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:62\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:62\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:14\n    |\n570 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::new(0, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:579:25\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:579:40\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:62\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:25\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:40\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:62\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:14\n    |\n581 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:11\n    |\n583 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:593:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n593 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:593:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n593 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:593:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n593 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:593:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n593 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(0, 2),",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(lhs_class_set),",
                "        rhs: Box::new(rhs_class_set),",
                "    };",
                "    let ast = ClassInduct::BinaryOp(&op);",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(returned_op, &op);"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(lhs, &op.lhs);"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(rhs, &op.rhs);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(returned_op, &op);",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(lhs, &op.lhs);",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(rhs, &op.rhs);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:60\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:62\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:14\n    |\n570 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::new(0, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:579:25\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:579:40\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:60\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:25\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:40\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:62\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"b\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:14\n    |\n581 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:11\n    |\n583 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:595:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n590 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n591 |     match frame {\n592 |     ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {\n    |                                                            - this delimiter might not be properly closed...\n593 |     assert_eq!(returned_op, &op);\n594 | }\n    | - ...as it matches this but it has different indentation\n595 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:595:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n590 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n591 |     match frame {\n592 |     ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {\n    |                                                            - this delimiter might not be properly closed...\n593 |     assert_eq!(lhs, &op.lhs);\n594 | }\n    | - ...as it matches this but it has different indentation\n595 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:595:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n590 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n591 |     match frame {\n592 |     ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {\n    |                                                            - this delimiter might not be properly closed...\n593 |     assert_eq!(rhs, &op.rhs);\n594 | }\n    | - ...as it matches this but it has different indentation\n595 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(0, 2),",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(lhs_class_set),",
                "        rhs: Box::new(rhs_class_set),",
                "    };",
                "    let ast = ClassInduct::BinaryOp(&op);",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, Some(ClassFrame::BinaryLHS {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 2),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, Some(ClassFrame::BinaryLHS {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:62\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"a\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:60\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:14\n    |\n570 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::new(0, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:25\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:40\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Empty(Span::new(0, 0)));\n    |                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:14\n    |\n581 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:11\n    |\n583 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:590:28\n    |\n567 | {\n    | - closing delimiter possibly meant for this\n...\n590 |     assert_eq!(result, Some(ClassFrame::BinaryLHS {\n    |                            ^ unclosed delimiter\n591 | }\n592 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:592:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n592 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs_class_set = ClassSet::Union(ClassSetUnion {",
                "        span: Span::new(0, 5),",
                "        items: vec![",
                "            ClassSetItem::Literal(Literal::from(\"c\")),",
                "            ClassSetItem::Literal(Literal::from(\"d\")),",
                "        ],",
                "    });",
                "    let rhs_class_set = ClassSet::Union(ClassSetUnion {",
                "        span: Span::new(6, 10),",
                "        items: vec![",
                "            ClassSetItem::Literal(Literal::from(\"e\")),",
                "            ClassSetItem::Literal(Literal::from(\"f\")),",
                "        ],",
                "    });",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(0, 10),",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(lhs_class_set),",
                "        rhs: Box::new(rhs_class_set),",
                "    };",
                "    let ast = ClassInduct::BinaryOp(&op);",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(returned_op, &op);"
                ],
                [
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(lhs.as_ref(), &op.lhs);"
                ],
                [
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(rhs.as_ref(), &op.rhs);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(0, 5),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"c\")),",
                  "            ClassSetItem::Literal(Literal::from(\"d\")),",
                  "        ],",
                  "    });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(6, 10),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"e\")),",
                  "            ClassSetItem::Literal(Literal::from(\"f\")),",
                  "        ],",
                  "    });",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 10),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(0, 5),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"c\")),",
                  "            ClassSetItem::Literal(Literal::from(\"d\")),",
                  "        ],",
                  "    });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(6, 10),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"e\")),",
                  "            ClassSetItem::Literal(Literal::from(\"f\")),",
                  "        ],",
                  "    });",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 10),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(returned_op, &op);",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(0, 5),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"c\")),",
                  "            ClassSetItem::Literal(Literal::from(\"d\")),",
                  "        ],",
                  "    });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(6, 10),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"e\")),",
                  "            ClassSetItem::Literal(Literal::from(\"f\")),",
                  "        ],",
                  "    });",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 10),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(lhs.as_ref(), &op.lhs);",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(0, 5),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"c\")),",
                  "            ClassSetItem::Literal(Literal::from(\"d\")),",
                  "        ],",
                  "    });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion {",
                  "        span: Span::new(6, 10),",
                  "        items: vec![",
                  "            ClassSetItem::Literal(Literal::from(\"e\")),",
                  "            ClassSetItem::Literal(Literal::from(\"f\")),",
                  "        ],",
                  "    });",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 10),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });",
                  "    let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });",
                  "    let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rhs_class_set), };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {",
                  "    assert_eq!(rhs.as_ref(), &op.rhs);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let lhs_class_set = ClassSet::Union(ClassSetUnion {\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let lhs_class_set = ClassSet::Union(ClassSetUnion {\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |             ClassSetItem::Literal(Literal::from(\"c\")),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:571:35\n    |\n571 |             ClassSetItem::Literal(Literal::from(\"c\")),\n    |                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |             ClassSetItem::Literal(Literal::from(\"d\")),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:35\n    |\n572 |             ClassSetItem::Literal(Literal::from(\"d\")),\n    |                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let rhs_class_set = ClassSet::Union(ClassSetUnion {\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:41\n    |\n575 |     let rhs_class_set = ClassSet::Union(ClassSetUnion {\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         span: Span::new(6, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |             ClassSetItem::Literal(Literal::from(\"e\")),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:35\n    |\n578 |             ClassSetItem::Literal(Literal::from(\"e\")),\n    |                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |             ClassSetItem::Literal(Literal::from(\"f\")),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:35\n    |\n579 |             ClassSetItem::Literal(Literal::from(\"f\")),\n    |                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:14\n    |\n582 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:15\n    |\n583 |         span: Span::new(0, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:584:15\n    |\n584 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:25\n    |\n591 |     let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), Cla...\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:41\n    |\n591 |     let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), Cla...\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:63\n    |\n591 |     let lhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), Cla...\n    |                                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:92\n    |\n591 | ...nion { span: Span::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:114\n    |\n591 | ...::new(0, 5), items: vec![ClassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:135\n    |\n591 | ...lassSetItem::Literal(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:157\n    |\n591 | ...ral(Literal::from(\"c\")), ClassSetItem::Literal(Literal::from(\"d\")),], });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:592:25\n    |\n592 |     let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), Cl...\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:41\n    |\n592 |     let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), Cl...\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:592:63\n    |\n592 |     let rhs_class_set = ClassSet::Union(ClassSetUnion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), Cl...\n    |                                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:93\n    |\n592 | ...ion { span: Span::new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:115\n    |\n592 | ...:new(6, 10), items: vec![ClassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:136\n    |\n592 | ...lassSetItem::Literal(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:158\n    |\n592 | ...ral(Literal::from(\"e\")), ClassSetItem::Literal(Literal::from(\"f\")),], });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:14\n    |\n593 |     let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rh...\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:593:39\n    |\n593 |     let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rh...\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:593:63\n    |\n593 |     let op = ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Union, lhs: Box::new(lhs_class_set), rhs: Box::new(rh...\n    |                                                               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:602:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n599 |     ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {\n    |                                                            - this delimiter might not be properly closed...\n600 |     assert_eq!(returned_op, &op);\n601 | }\n    | - ...as it matches this but it has different indentation\n602 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:602:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n599 |     ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {\n    |                                                            - this delimiter might not be properly closed...\n600 |     assert_eq!(lhs.as_ref(), &op.lhs);\n601 | }\n    | - ...as it matches this but it has different indentation\n602 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:602:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n599 |     ClassFrame::BinaryLHS { op: returned_op, lhs, rhs } => {\n    |                                                            - this delimiter might not be properly closed...\n600 |     assert_eq!(rhs.as_ref(), &op.rhs);\n601 | }\n    | - ...as it matches this but it has different indentation\n602 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));",
                "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(0, 3),",
                "        kind: ClassSetBinaryOpKind::Invalid, // Assuming this is an invalid kind to test edge behavior.",
                "        lhs: Box::new(lhs_class_set),",
                "        rhs: Box::new(rhs_class_set),",
                "    };",
                "    let ast = ClassInduct::BinaryOp(&op);",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 3),",
                  "    kind: ClassSetBinaryOpKind::Invalid,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 3),",
                  "    kind: ClassSetBinaryOpKind::Invalid,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    assert_matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 3),",
                  "        kind: ClassSetBinaryOpKind::Invalid, // Assuming this is an invalid kind to test edge behavior.",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 3),",
                  "    kind: ClassSetBinaryOpKind::Invalid,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 3),",
                  "        kind: ClassSetBinaryOpKind::Invalid, // Assuming this is an invalid kind to test edge behavior.",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 3),",
                  "    kind: ClassSetBinaryOpKind::Invalid,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    let frame = result.unwrap();",
                  "    assert_matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:62\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:62\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:14\n    |\n570 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSetBinaryOpKind::Invalid, // Assuming this is an invalid kind to test edge behavior.\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:579:25\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:579:40\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:62\n    |\n579 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:25\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:40\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:62\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:14\n    |\n581 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 3),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:11\n    |\n583 |     kind: ClassSetBinaryOpKind::Invalid,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: cannot find macro `assert_matches` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:5\n    |\n591 |     assert_matches!(frame, ClassFrame::BinaryLHS { op, lhs, rhs });\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n560 +    use std::assert_matches::assert_matches;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:62\n    |\n568 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"x\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:62\n    |\n569 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:14\n    |\n570 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSetBinaryOpKind::Invalid, // Assuming this is an invalid kind to test edge behavior.\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:25\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:40\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:62\n    |\n580 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from(\"y\")));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:14\n    |\n581 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 3),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:11\n    |\n583 |     kind: ClassSetBinaryOpKind::Invalid,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches _ is true\n",
        "// constraint: *ast matches ClassInduct::BinaryOp(op) is false\n",
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) is false\n",
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is false\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "ClassInduct with ClassSetItem as Union with empty items, ClassInduct with BinaryOp, ClassInduct with random item not matching Bracketed or Union, ClassInduct with empty Bracketed.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let empty_union = ClassSetItem::Union(ClassSetUnion {",
                "        span: Span::default(),",
                "        items: vec![]",
                "    });",
                "    ",
                "    let ast = ClassInduct::Item(&empty_union);",
                "    let visitor = HeapVisitor::new();",
                "    ",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: vec![] });",
                  "    let ast = ClassInduct::Item(&empty_union);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let empty_union = ClassSetItem::Union(ast::ClassSetUnion {  ",
                  "        span: Span::default(),",
                  "        items: vec![]",
                  "    });",
                  "    ",
                  "    let ast = ClassInduct::Item(&empty_union);",
                  "    let visitor = HeapVisitor::new();",
                  "    ",
                  "    let result = visitor.induct_class(&ast);",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: vec![] });",
                  "    let ast = ClassInduct::Item(&empty_union);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |     let empty_union = ClassSetItem::Union(ast::ClassSetUnion {  \n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:577:23\n    |\n577 |     let empty_union = ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: vec![] });\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:43\n    |\n577 |     let empty_union = ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: vec![] });\n    |                                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:65\n    |\n577 |     let empty_union = ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: vec![] });\n    |                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ClassFrame<'_>>\n    |     Option<ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ClassSetBinaryOpKind::SomeKind,",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))),",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default())))",
                "    };",
                "    ",
                "    let ast = ClassInduct::BinaryOp(&op);",
                "    let visitor = HeapVisitor::new();",
                "    ",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default())))",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, Some(ClassFrame::BinaryLHS {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))),",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default())))",
                  "    };",
                  "    ",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    ",
                  "    let result = visitor.induct_class(&ast);",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default())))",
                  "    };",
                  "    let ast = ClassInduct::BinaryOp(&op);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, Some(ClassFrame::BinaryLHS {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:588:28\n    |\n567 | {\n    | - closing delimiter possibly meant for this\n...\n588 |     assert_eq!(result, Some(ClassFrame::BinaryLHS {\n    |                            ^ unclosed delimiter\n589 | }\n590 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let random_item = ClassSetItem::Literal(Literal::default());",
                "    ",
                "    let ast = ClassInduct::Item(&random_item);",
                "    let visitor = HeapVisitor::new();",
                "    ",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let random_item = ClassSetItem::Literal(Literal::default());",
                  "    let ast = ClassInduct::Item(&random_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let random_item = ClassSetItem::Literal(Literal::default());",
                  "    ",
                  "    let ast = ClassInduct::Item(&random_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    ",
                  "    let result = visitor.induct_class(&ast);",
                  "    let random_item = ClassSetItem::Literal(Literal::default());",
                  "    let ast = ClassInduct::Item(&random_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, None);  ",
                  "#[derive(PartialEq)]  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected statement after outer attribute\n   --> regex-syntax/src/ast/visitor.rs:579:1\n    |\n579 | #[derive(PartialEq)]  \n    | ^^^^^^^^^^^^^^^^^^^^\n\nerror: unexpected end of input, expected expression\n   --> regex-syntax/src/ast/visitor.rs:580:1\n    |\n580 | }\n    | ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_induct_class_19` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_induct_class_19()\n567 | | {\n568 | |     let random_item = ClassSetItem::Literal(Literal::default());\n...   |\n579 | | #[derive(PartialEq)]  \n580 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let empty_bracketed = ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Empty(Span::default()))",
                "    };",
                "    ",
                "    let ast = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(empty_bracketed)));",
                "    let visitor = HeapVisitor::new();",
                "    ",
                "    let result = visitor.induct_class(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let empty_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default())) };",
                  "    let ast = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(empty_bracketed)));",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let empty_bracketed = ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Empty(Span::default()))",
                  "    };",
                  "    ",
                  "    let ast = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(empty_bracketed)));",
                  "    let visitor = HeapVisitor::new();",
                  "    ",
                  "    let result = visitor.induct_class(&ast);",
                  "    let empty_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default())) };",
                  "    let ast = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(empty_bracketed)));",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&ast);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:27\n    |\n568 |     let empty_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         kind: ClassSet::Item(ClassSetItem::Empty(Span::default()))\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:571:30\n    |\n571 |         kind: ClassSet::Item(ClassSetItem::Empty(Span::default()))\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:50\n    |\n571 |         kind: ClassSet::Item(ClassSetItem::Empty(Span::default()))\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:34\n    |\n574 |     let ast = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(empty_bracketed)));\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let empty_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default(...\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:50\n    |\n578 |     let empty_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default(...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:578:89\n    |\n578 |     let empty_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default(...\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:104\n    |\n578 | ...t(), negated: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default())) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:124\n    |\n578 | ...: false, kind: ClassSet::Item(ClassSetItem::Empty(Span::default())) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:579:34\n    |\n579 |     let ast = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(empty_bracketed)));\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ClassFrame<'_>>\n    |     Option<ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) is true\n",
        "// constraint: x.items.is_empty() is true\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: some_span, items: vec![] }))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let some_span = Span { start: 0, end: 0 }; // Example span initialization",
                "    let union_class_set = ClassSetUnion {",
                "        span: some_span,",
                "        items: vec![],",
                "    };",
                "    let class_set_item = ClassSetItem::Union(union_class_set);",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_result = None;",
                  "    assert_eq!(result, expected_result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let some_span = Span { start: 0, end: 0 }; // Example span initialization",
                  "    let union_class_set = ClassSetUnion {",
                  "        span: some_span,",
                  "        items: vec![],",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(union_class_set);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let expected_result = None;",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let some_span = Span { start: 0, end: 0 }; // Example span initialization\n    |                     ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let union_class_set = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let class_set_item = ClassSetItem::Union(union_class_set);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:579:5\n    |\n579 |     assert_eq!(result, expected_result);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ClassFrame<'_>>\n    |     Option<ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let some_span = Span { start: 0, end: 1 }; // Example span initialization",
                "    let bracketed_class = ClassBracketed {",
                "        span: some_span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                "    };",
                "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let some_span = Span { start: 0, end: 1 };",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: some_span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_eq!(result, Some(ClassFrame::Union { head: &ClassSetItem::Literal(Literal::from('a')), tail: &[] }));"
                ],
                [
                  "    let some_span = Span { start: 0, end: 1 };",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: some_span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let empty_union = ClassSetUnion { span: some_span, items: vec![] };",
                  "    let class_set_item_empty = ClassSetItem::Union(empty_union);",
                  "    let class_induct_empty = ClassInduct::Item(&class_set_item_empty);",
                  "    let result_empty = visitor.induct_class(&class_induct_empty);",
                  "    assert_eq!(result_empty, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let some_span = Span { start: 0, end: 1 }; // Example span initialization",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: some_span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: some_span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_eq!(result, Some(ClassFrame::Union { head: &ClassSetItem::Literal(Literal::from('a')), tail: &[] }));",
                  "}"
                ],
                [
                  "{",
                  "    let some_span = Span { start: 0, end: 1 }; // Example span initialization",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: some_span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let some_span = Span { start: 0, end: 1 };",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: some_span,",
                  "    negated: false,",
                  "",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let empty_union = ClassSetUnion { span: some_span, items: vec![] };",
                  "    let class_set_item_empty = ClassSetItem::Union(empty_union);",
                  "    let class_induct_empty = ClassInduct::Item(&class_set_item_empty);",
                  "    let result_empty = visitor.induct_class(&class_induct_empty);",
                  "    assert_eq!(result_empty, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let some_span = Span { start: 0, end: 1 }; // Example span initialization\n    |                     ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:30\n    |\n572 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:52\n    |\n572 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:583:11\n    |\n583 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:26\n    |\n583 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:48\n    |\n583 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:26\n    |\n585 |     let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:56\n    |\n589 |     assert_eq!(result, Some(ClassFrame::Union { head: &ClassSetItem::Literal(Literal::from('a')), tail: &[] }));\n    |                                                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:78\n    |\n589 |     assert_eq!(result, Some(ClassFrame::Union { head: &ClassSetItem::Literal(Literal::from('a')), tail: &[] }));\n    |                                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:589:5\n    |\n589 |     assert_eq!(result, Some(ClassFrame::Union { head: &ClassSetItem::Literal(Literal::from('a')), tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::ClassFrame<'_>>\n    |     Option<ast::visitor::ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let some_span = Span { start: 0, end: 1 }; // Example span initialization\n    |                     ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:30\n    |\n572 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:52\n    |\n572 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:21\n    |\n579 |     let some_span = Span { start: 0, end: 1 };\n    |                     ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:26\n    |\n585 |     let class_set_item = ClassSetItem::Bracketed(Box::new(bracketed_class));\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:23\n    |\n589 |     let empty_union = ClassSetUnion { span: some_span, items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let class_set_item_empty = ClassSetItem::Union(empty_union);\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:593:5\n    |\n593 |     assert_eq!(result_empty, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ClassFrame<'_>>\n    |     Option<ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let some_span = Span { start: 0, end: 2 }; // Example span initialization",
                "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));",
                "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));",
                "    let binary_op = ClassSetBinaryOp {",
                "        span: some_span,",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(lhs_class_set),",
                "        rhs: Box::new(rhs_class_set),",
                "    };",
                "    let class_set_item = ClassSetItem::BinaryOp(binary_op);",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let some_span = Span { start: 0, end: 2 };",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span: some_span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(ClassSetUnion {",
                  "    span: some_span,",
                  "    items: vec![],",
                  "    });",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let some_span = Span { start: 0, end: 2 }; // Example span initialization",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));",
                  "    use ast::ClassSetItem; let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span: some_span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs_class_set),",
                  "        rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let class_set_item = ClassSetItem::BinaryOp(binary_op);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));",
                  "    let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span: some_span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs_class_set),",
                  "    rhs: Box::new(rhs_class_set),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(ClassSetUnion {",
                  "    span: some_span,",
                  "    items: vec![],",
                  "    });",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let some_span = Span { start: 0, end: 2 }; // Example span initialization\n    |                     ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:62\n    |\n569 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:48\n    |\n570 |     use ast::ClassSetItem; let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));\n    |                                                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:85\n    |\n570 |     use ast::ClassSetItem; let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:21\n    |\n571 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:583:25\n    |\n583 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:62\n    |\n583 |     let lhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('a')));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:584:25\n    |\n584 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));\n    |                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:584:62\n    |\n584 |     let rhs_class_set = ClassSet::Item(ClassSetItem::Literal(Literal::from('b')));\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:21\n    |\n585 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:46\n    |\n591 |     let class_set_item = ClassSetItem::Union(ClassSetUnion {\n    |                                              ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `BinaryOp` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let class_set_item = ClassSetItem::BinaryOp(binary_op);\n    |                                        ^^^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `BinaryOp` not found for this enum\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:598:5\n    |\n598 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ClassFrame<'_>>\n    |     Option<ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) is true\n",
        "// constraint: x.items.is_empty() is false\n",
        "// constraint: x.items[0] is \n",
        "// constraint: x.items[1..] is \n",
        "// expected return value/type: Some(ClassFrame::Union {\n                        head: &x.items[0],\n                        tail: &x.items[1..],\n                    })\n"
      ],
      "input_infer": "ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { items: vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))]}))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let items = vec![",
                "        ClassSetItem::Literal(Literal::new('a')),",
                "        ClassSetItem::Literal(Literal::new('b')),",
                "    ];",
                "    let class_set_union = ClassSetUnion {",
                "        span: Span::new(),",
                "        items,",
                "    };",
                "    let class_set_item = ClassSetItem::Union(class_set_union);",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_matches!(result, Some(ClassFrame::Union { head, tail }) if head == &ClassSetItem::Literal(Literal::new('a')) && tail == &[ClassSetItem::Literal(Literal::new('b'))]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('a')),",
                  "        ClassSetItem::Literal(Literal::new('b')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('a')),",
                  "        ClassSetItem::Literal(Literal::new('b')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_matches!(result, Some(ClassFrame::Union { head, tail }) if head == &ClassSetItem::Literal(Literal::new('a')) && tail == &[ClassSetItem::Literal(Literal::new('b'))]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:9\n    |\n569 |         ClassSetItem::Literal(Literal::new('a')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         ClassSetItem::Literal(Literal::new('a')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:9\n    |\n570 |         ClassSetItem::Literal(Literal::new('b')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:31\n    |\n570 |         ClassSetItem::Literal(Literal::new('b')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:27\n    |\n572 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     ClassSetItem::Literal(Literal::new('a')),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:27\n    |\n582 |     ClassSetItem::Literal(Literal::new('a')),\n    |                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     ClassSetItem::Literal(Literal::new('b')),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:27\n    |\n583 |     ClassSetItem::Literal(Literal::new('b')),\n    |                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:11\n    |\n586 |     span: Span::new(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:26\n    |\n589 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: cannot find macro `assert_matches` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:5\n    |\n593 |     assert_matches!(result, Some(ClassFrame::Union { head, tail }) if head == &ClassSetItem::Literal(Literal::new('a')) && tail == &[Clas...\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n560 +    use std::assert_matches::assert_matches;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:9\n    |\n569 |         ClassSetItem::Literal(Literal::new('a')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         ClassSetItem::Literal(Literal::new('a')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:9\n    |\n570 |         ClassSetItem::Literal(Literal::new('b')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:31\n    |\n570 |         ClassSetItem::Literal(Literal::new('b')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:27\n    |\n572 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     ClassSetItem::Literal(Literal::new('a')),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:27\n    |\n582 |     ClassSetItem::Literal(Literal::new('a')),\n    |                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     ClassSetItem::Literal(Literal::new('b')),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:27\n    |\n583 |     ClassSetItem::Literal(Literal::new('b')),\n    |                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:11\n    |\n586 |     span: Span::new(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:26\n    |\n589 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_bracketed = ClassBracketed {",
                "        span: Span::new(),",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                "    };",
                "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert_eq!(head, &ClassSetItem::Literal(Literal::new('a')));"
                ],
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert!(tail.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let class_bracketed = ClassBracketed {",
                  "        span: Span::new(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let class_bracketed = ClassBracketed {",
                  "        span: Span::new(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert_eq!(head, &ClassSetItem::Literal(Literal::new('a')));",
                  "}"
                ],
                [
                  "{",
                  "    let class_bracketed = ClassBracketed {",
                  "        span: Span::new(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                  "    };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert!(tail.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:27\n    |\n568 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:571:30\n    |\n571 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:571:52\n    |\n571 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'...\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:50\n    |\n578 |     let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:578:85\n    |\n578 |     let class_bracketed = ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'...\n    |                                                                                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:100\n    |\n578 | ...w(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:122\n    |\n578 | ...se, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:579:26\n    |\n579 |     let class_set_item = ClassSetItem::Bracketed(Box::new(class_bracketed));\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:588:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n583 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n584 |     match frame {\n585 |     ClassFrame::Union { head, tail } => {\n    |                                         - this delimiter might not be properly closed...\n586 |     assert_eq!(head, &ClassSetItem::Literal(Literal::new('a')));\n587 | }\n    | - ...as it matches this but it has different indentation\n588 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:588:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n583 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n584 |     match frame {\n585 |     ClassFrame::Union { head, tail } => {\n    |                                         - this delimiter might not be properly closed...\n586 |     assert!(tail.is_empty());\n587 | }\n    | - ...as it matches this but it has different indentation\n588 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let items = vec![",
                "        ClassSetItem::Literal(Literal::new('a')),",
                "        ClassSetItem::Literal(Literal::new('b')),",
                "        ClassSetItem::Literal(Literal::new('c')),",
                "    ];",
                "    let class_set_union = ClassSetUnion {",
                "        span: Span::new(),",
                "        items,",
                "    };",
                "    let class_set_item = ClassSetItem::Union(class_set_union);",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert_eq!(head, &class_set_item.items[0]);"
                ],
                [
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert_eq!(tail, &class_set_item.items[1..]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('a')),",
                  "        ClassSetItem::Literal(Literal::new('b')),",
                  "        ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    use ast::Literal;  ",
                  "    ClassSetItem::Literal(Literal::new('b')),  ",
                  "    ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('a')),",
                  "        ClassSetItem::Literal(Literal::new('b')),",
                  "        ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert_eq!(head, &class_set_item.items[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('a')),",
                  "        ClassSetItem::Literal(Literal::new('b')),",
                  "        ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items = vec![",
                  "    ClassSetItem::Literal(Literal::new('a')),",
                  "    ClassSetItem::Literal(Literal::new('b')),",
                  "    ClassSetItem::Literal(Literal::new('c')),",
                  "    ];",
                  "    let class_set_union = ClassSetUnion {",
                  "    span: Span::new(),",
                  "    items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    match frame {",
                  "    ClassFrame::Union { head, tail } => {",
                  "    assert_eq!(tail, &class_set_item.items[1..]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: no rules expected the token `use`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     use ast::Literal;  \n    |     ^^^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$x:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs:49:8\n    |\n49  |     ($($x:expr),+ $(,)?) => (\n    |        ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:9\n    |\n569 |         ClassSetItem::Literal(Literal::new('a')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |         ClassSetItem::Literal(Literal::new('a')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:9\n    |\n570 |         ClassSetItem::Literal(Literal::new('b')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:31\n    |\n570 |         ClassSetItem::Literal(Literal::new('b')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:571:9\n    |\n571 |         ClassSetItem::Literal(Literal::new('c')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:571:31\n    |\n571 |         ClassSetItem::Literal(Literal::new('c')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:27\n    |\n573 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:27\n    |\n588 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:589:11\n    |\n589 |     span: Span::new(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:26\n    |\n592 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:600:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n597 |     ClassFrame::Union { head, tail } => {\n    |                                         - this delimiter might not be properly closed...\n598 |     assert_eq!(head, &class_set_item.items[0]);\n599 | }\n    | - ...as it matches this but it has different indentation\n600 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:600:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n567 | {\n    | - unclosed delimiter\n...\n597 |     ClassFrame::Union { head, tail } => {\n    |                                         - this delimiter might not be properly closed...\n598 |     assert_eq!(tail, &class_set_item.items[1..]);\n599 | }\n    | - ...as it matches this but it has different indentation\n600 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let items: Vec<ClassSetItem> = vec![];",
                "    let class_set_union = ClassSetUnion {",
                "        span: Span::new(),",
                "        items,",
                "    };",
                "    let class_set_item = ClassSetItem::Union(class_set_union);",
                "    let class_induct = ClassInduct::Item(&class_set_item);",
                "    ",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &items[0]);"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert!(tail.is_empty());"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &items[0]);"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(tail.len(), 1);"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(tail[0], &items[1]);"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &ClassSetItem::Bracketed(any));"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert!(tail.is_empty());"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Binary { op }) = result {",
                  "    assert_eq!(op.kind, ClassSetBinaryOpKind::Subtraction);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &items[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert!(tail.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &items[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(tail.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(tail[0], &items[1]);",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &ClassSetItem::Bracketed(any));",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert!(tail.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let items: Vec<ClassSetItem> = vec![];",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span::new(),",
                  "        items,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    ",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];",
                  "    let class_set_union = ClassSetUnion { span: Span::new(), items };",
                  "    let class_set_item = ClassSetItem::Union(class_set_union);",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    }",
                  "    let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));",
                  "    let class_induct = ClassInduct::Item(&class_set_item);",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    if let Some(Frame::Binary { op }) = result {",
                  "    assert_eq!(op.kind, ClassSetBinaryOpKind::Subtraction);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:20\n    |\n568 |     let items: Vec<ClassSetItem> = vec![];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:20\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:41\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:63\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:27\n    |\n579 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:49\n    |\n579 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0412, E0422, E0433.\nFor more information about an error, try `rustc --explain E0412`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:587:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n587 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:587:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n587 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:20\n    |\n568 |     let items: Vec<ClassSetItem> = vec![];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:20\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:41\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:63\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:20\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:41\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:63\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:83\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                                                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:105\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:27\n    |\n587 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:49\n    |\n587 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:26\n    |\n588 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant named `Union` found for enum `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:584:24\n    |\n147 | enum Frame<'a> {\n    | -------------- variant `Union` not found here\n...\n584 |     if let Some(Frame::Union { head, tail }) = result {\n    |                        ^^^^^ variant not found in `ast::visitor::Frame<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0412, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:595:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n595 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:595:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n595 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:595:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n595 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:20\n    |\n568 |     let items: Vec<ClassSetItem> = vec![];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:20\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:41\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:63\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:27\n    |\n579 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:49\n    |\n579 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:20\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:41\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:63\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:83\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                                                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:105\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:27\n    |\n587 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:49\n    |\n587 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:26\n    |\n588 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:20\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:41\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:74\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                                                                          ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:97\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                                                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:132\n    |\n594 | ...ed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:147\n    |\n594 | ...w(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:594:169\n    |\n594 | ...se, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:27\n    |\n595 |     let class_set_union = ClassSetUnion { span: Span::new(), items };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:49\n    |\n595 |     let class_set_union = ClassSetUnion { span: Span::new(), items };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:596:26\n    |\n596 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant named `Union` found for enum `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:584:24\n    |\n147 | enum Frame<'a> {\n    | -------------- variant `Union` not found here\n...\n584 |     if let Some(Frame::Union { head, tail }) = result {\n    |                        ^^^^^ variant not found in `ast::visitor::Frame<'_>`\n\nerror[E0599]: no variant named `Union` found for enum `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:592:24\n    |\n147 | enum Frame<'a> {\n    | -------------- variant `Union` not found here\n...\n592 |     if let Some(Frame::Union { head, tail }) = result {\n    |                        ^^^^^ variant not found in `ast::visitor::Frame<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0412, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:603:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n603 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:603:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n603 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:20\n    |\n568 |     let items: Vec<ClassSetItem> = vec![];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:20\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:578:41\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:63\n    |\n578 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:27\n    |\n579 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:49\n    |\n579 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:20\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:41\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:63\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:83\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                                                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:105\n    |\n586 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Literal(Literal::new('a')), ClassSetItem::Literal(Literal::new('b'))];\n    |                                                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:27\n    |\n587 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:49\n    |\n587 |     let class_set_union = ClassSetUnion { span: Span::new(), items: items.clone() };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:26\n    |\n588 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0412]: cannot find type `ClassSetItem` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:20\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                    ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:41\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:74\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                                                                          ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:97\n    |\n594 |     let items: Vec<ClassSetItem> = vec![ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassS...\n    |                                                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:132\n    |\n594 | ...ed { span: Span::new(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:147\n    |\n594 | ...w(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:594:169\n    |\n594 | ...se, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))) }))];\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:27\n    |\n595 |     let class_set_union = ClassSetUnion { span: Span::new(), items };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:49\n    |\n595 |     let class_set_union = ClassSetUnion { span: Span::new(), items };\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:596:26\n    |\n596 |     let class_set_item = ClassSetItem::Union(class_set_union);\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:26\n    |\n602 |     let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(Cl...\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:602:59\n    |\n602 |     let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(Cl...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:602:82\n    |\n602 |     let class_set_item = ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(Cl...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:117\n    |\n602 | ...ed { span: Span::new(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Sub...\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:602:136\n    |\n602 | ...ew(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box...\n    |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:602:161\n    |\n602 | ...kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(C...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:602:180\n    |\n602 | ...naryOp { span: Span::new(), kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('...\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:229\n    |\n602 | ...ssSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(...\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:244\n    |\n602 | ...Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Liter...\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:602:266\n    |\n602 | ... Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('...\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:302\n    |\n602 | ...::Literal(Literal::new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:317\n    |\n602 | ...new('d')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:602:339\n    |\n602 | ... Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('e')))) }) }));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant named `Union` found for enum `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:584:24\n    |\n147 | enum Frame<'a> {\n    | -------------- variant `Union` not found here\n...\n584 |     if let Some(Frame::Union { head, tail }) = result {\n    |                        ^^^^^ variant not found in `ast::visitor::Frame<'_>`\n\nerror[E0599]: no variant named `Union` found for enum `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:592:24\n    |\n147 | enum Frame<'a> {\n    | -------------- variant `Union` not found here\n...\n592 |     if let Some(Frame::Union { head, tail }) = result {\n    |                        ^^^^^ variant not found in `ast::visitor::Frame<'_>`\n\nerror[E0599]: no variant named `Union` found for enum `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:600:24\n    |\n147 | enum Frame<'a> {\n    | -------------- variant `Union` not found here\n...\n600 |     if let Some(Frame::Union { head, tail }) = result {\n    |                        ^^^^^ variant not found in `ast::visitor::Frame<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0412, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:609:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n609 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: x.kind matches ast::ClassSet::BinaryOp(ref op) is true\n",
        "// expected return value/type: Some(ClassFrame::Binary { op: op })\n"
      ],
      "input_infer": "ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span { start: 1, end: 10 }, negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span { start: 1, end: 5 }, kind: ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { value: 'a' }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { value: 'b' }))) }) }))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                "",
                "    let binary_op = ClassSetBinaryOp {",
                "        span: Span { start: 1, end: 5 },",
                "        kind: ClassSetBinaryOpKind::Subtraction,",
                "        lhs: Box::new(ClassSet::Item(literal_a)),",
                "        rhs: Box::new(ClassSet::Item(literal_b)),",
                "    };",
                "",
                "    let class_bracketed = ClassBracketed {",
                "        span: Span { start: 1, end: 10 },",
                "        negated: false,",
                "        kind: ClassSet::BinaryOp(binary_op.clone()),",
                "    };",
                "",
                "    let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));",
                "",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "",
                "    // The function returns an Option<ClassFrame>",
                "    // No assertion, just invoking the method",
                "}"
              ],
              "oracles": [
                [
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span: Span { start: 1, end: 5 },",
                  "    kind: ClassSetBinaryOpKind::Subtraction,",
                  "    lhs: Box::new(ClassSet::Item(literal_a)),",
                  "    rhs: Box::new(ClassSet::Item(literal_b)),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span: Span { start: 1, end: 10 },",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op.clone()),",
                  "    };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span: Span { start: 1, end: 5 },",
                  "    kind: ClassSetBinaryOpKind::Subtraction,",
                  "    lhs: Box::new(ClassSet::Item(literal_a)),",
                  "    rhs: Box::new(ClassSet::Item(literal_b)),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span: Span { start: 1, end: 10 },",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op.clone()),",
                  "    };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    assert!(matches!(frame, ClassFrame::Binary { op: _ }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span: Span { start: 1, end: 5 },",
                  "        kind: ClassSetBinaryOpKind::Subtraction,",
                  "        lhs: Box::new(ClassSet::Item(literal_a)),",
                  "        rhs: Box::new(ClassSet::Item(literal_b)),",
                  "    };",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span: Span { start: 1, end: 10 },",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op.clone()),",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span: Span { start: 1, end: 5 },",
                  "    kind: ClassSetBinaryOpKind::Subtraction,",
                  "    lhs: Box::new(ClassSet::Item(literal_a)),",
                  "    rhs: Box::new(ClassSet::Item(literal_b)),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span: Span { start: 1, end: 10 },",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op.clone()),",
                  "    };",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span: Span { start: 1, end: 5 },",
                  "        kind: ClassSetBinaryOpKind::Subtraction,",
                  "        lhs: Box::new(ClassSet::Item(literal_a)),",
                  "        rhs: Box::new(ClassSet::Item(literal_b)),",
                  "    };",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span: Span { start: 1, end: 10 },",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op.clone()),",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span: Span { start: 1, end: 5 },",
                  "    kind: ClassSetBinaryOpKind::Subtraction,",
                  "    lhs: Box::new(ClassSet::Item(literal_a)),",
                  "    rhs: Box::new(ClassSet::Item(literal_b)),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span: Span { start: 1, end: 10 },",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op.clone()),",
                  "    };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    assert!(matches!(frame, ClassFrame::Binary { op: _ }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:21\n    |\n569 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:43\n    |\n569 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:21\n    |\n571 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 1, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |         kind: ClassSetBinaryOpKind::Subtraction,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         lhs: Box::new(ClassSet::Item(literal_a)),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |         rhs: Box::new(ClassSet::Item(literal_b)),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:15\n    |\n579 |         span: Span { start: 1, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |         kind: ClassSet::BinaryOp(binary_op.clone()),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:21\n    |\n591 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:43\n    |\n591 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:21\n    |\n592 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:43\n    |\n592 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:21\n    |\n593 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     span: Span { start: 1, end: 5 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:595:11\n    |\n595 |     kind: ClassSetBinaryOpKind::Subtraction,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:19\n    |\n596 |     lhs: Box::new(ClassSet::Item(literal_a)),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:19\n    |\n597 |     rhs: Box::new(ClassSet::Item(literal_b)),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:600:11\n    |\n600 |     span: Span { start: 1, end: 10 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:11\n    |\n602 |     kind: ClassSet::BinaryOp(binary_op.clone()),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:21\n    |\n569 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:43\n    |\n569 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:21\n    |\n571 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 1, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |         kind: ClassSetBinaryOpKind::Subtraction,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         lhs: Box::new(ClassSet::Item(literal_a)),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |         rhs: Box::new(ClassSet::Item(literal_b)),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:15\n    |\n579 |         span: Span { start: 1, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |         kind: ClassSet::BinaryOp(binary_op.clone()),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:21\n    |\n591 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:43\n    |\n591 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:21\n    |\n593 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     span: Span { start: 1, end: 5 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:595:11\n    |\n595 |     kind: ClassSetBinaryOpKind::Subtraction,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:19\n    |\n596 |     lhs: Box::new(ClassSet::Item(literal_a)),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:19\n    |\n597 |     rhs: Box::new(ClassSet::Item(literal_b)),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:600:11\n    |\n600 |     span: Span { start: 1, end: 10 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:11\n    |\n602 |     kind: ClassSet::BinaryOp(binary_op.clone()),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:43\n    |\n604 |     let class_induct = ClassInduct::Item(&ClassSetItem::Bracketed(class_bracketed));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                "",
                "    let class_set_union = ClassSetUnion {",
                "        span: Span { start: 1, end: 5 },",
                "        items: vec![literal_a.clone(), literal_b.clone()],",
                "    };",
                "",
                "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                "",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "",
                "    // The function returns an Option<ClassFrame>",
                "    // No assertion, just invoking the method",
                "}"
              ],
              "oracles": [
                [
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    if let ClassFrame::Union { head, tail } = frame {",
                  "    assert_eq!(head, &literal_a);"
                ],
                [
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    if let ClassFrame::Union { head, tail } = frame {",
                  "    assert!(!tail.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "",
                  "    let class_set_union = ClassSetUnion {",
                  "",
                  "        items: vec![literal_a.clone(), literal_b.clone()],",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span { start: 1, end: 5 },",
                  "        items: vec![literal_a.clone(), literal_b.clone()],",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    if let ClassFrame::Union { head, tail } = frame {",
                  "    assert_eq!(head, &literal_a);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span { start: 1, end: 5 },",
                  "        items: vec![literal_a.clone(), literal_b.clone()],",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let literal_a = ClassSetItem::Literal(Literal { value: 'a' });",
                  "    let literal_b = ClassSetItem::Literal(Literal { value: 'b' });",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let frame = result.unwrap();",
                  "    if let ClassFrame::Union { head, tail } = frame {",
                  "    assert!(!tail.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:21\n    |\n568 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:21\n    |\n569 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:43\n    |\n569 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:21\n    |\n583 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:43\n    |\n583 |     let literal_a = ClassSetItem::Literal(Literal { value: 'a' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:21\n    |\n584 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let literal_b = ClassSetItem::Literal(Literal { value: 'b' });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:49\n    |\n585 |     let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![literal_a.clone(), literal_b.clone()] };\n    |                                                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:43\n    |\n586 |     let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:593:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n593 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:593:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n593 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_set_union = ClassSetUnion {",
                "        span: Span { start: 1, end: 5 },",
                "        items: vec![],",
                "    };",
                "",
                "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                "",
                "    let mut visitor = HeapVisitor::new();",
                "    let result = visitor.induct_class(&class_induct);",
                "",
                "    // The function returns an Option<ClassFrame>",
                "    // No assertion, just invoking the method",
                "}"
              ],
              "oracles": [
                [
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_eq!(result, None);"
                ],
                [
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let bracketed_class_set = ClassBracketed { span: Span { start: 1, end: 5 }, negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span { start: 1, end: 5 }, kind: ClassSetBinaryOpKind::SomeOp, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b')))) });",
                  "    let class_induct_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(bracketed_class_set));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result_bracketed = visitor.induct_class(&class_induct_bracketed);",
                  "    assert!(result_bracketed.is_some());"
                ],
                [
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let bracketed_class_set = ClassBracketed { span: Span { start: 1, end: 5 }, negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span { start: 1, end: 5 }, kind: ClassSetBinaryOpKind::SomeOp, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b')))) });",
                  "    let class_induct_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(bracketed_class_set));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result_bracketed = visitor.induct_class(&class_induct_bracketed);",
                  "    assert_eq!(result_bracketed.unwrap(), ClassFrame::Binary { op: &class_set_binary_op });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span { start: 1, end: 5 },",
                  "        items: vec![],",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    assert_eq!(result, None);",
                  "}"
                ],
                [
                  "{",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span { start: 1, end: 5 },",
                  "        items: vec![],",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let bracketed_class_set = ClassBracketed { span: Span { start: 1, end: 5 }, negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span { start: 1, end: 5 }, kind: ClassSetBinaryOpKind::SomeOp, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b')))) });",
                  "    let class_induct_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(bracketed_class_set));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result_bracketed = visitor.induct_class(&class_induct_bracketed);",
                  "    assert!(result_bracketed.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let class_set_union = ClassSetUnion {",
                  "        span: Span { start: 1, end: 5 },",
                  "        items: vec![],",
                  "    };",
                  "",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "",
                  "    // The function returns an Option<ClassFrame>",
                  "    // No assertion, just invoking the method",
                  "    let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };",
                  "    let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&class_induct);",
                  "    let bracketed_class_set = ClassBracketed { span: Span { start: 1, end: 5 }, negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span { start: 1, end: 5 }, kind: ClassSetBinaryOpKind::SomeOp, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b')))) });",
                  "    let class_induct_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(bracketed_class_set));",
                  "    let mut visitor = HeapVisitor::new();",
                  "    let result_bracketed = visitor.induct_class(&class_induct_bracketed);",
                  "    assert_eq!(result_bracketed.unwrap(), ClassFrame::Binary { op: &class_set_binary_op });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:27\n    |\n568 |     let class_set_union = ClassSetUnion {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span { start: 1, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:43\n    |\n573 |     let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |     let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:49\n    |\n580 |     let class_set_union = ClassSetUnion { span: Span { start: 1, end: 5 }, items: vec![] };\n    |                                                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let class_induct = ClassInduct::Item(&ClassSetItem::Union(class_set_union));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ClassFrame<'_>>\n    |     Option<ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) is true\n",
        "// constraint: x.kind matches ast::ClassSet::Item(ref item) is true\n",
        "// constraint: x.kind matches ast::ClassSet::Item(ref item) is true\n",
        "// expected return value/type: Some(ClassFrame::Union {\n                            head: item,\n                            tail: &[],\n                        })\n"
      ],
      "input_infer": "ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) with 0 items or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) where x.kind is ast::ClassSet::BinaryOp(ref op) where op has lhs and rhs, or ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) where x.kind is ast::ClassSet::Item(ref item) where item is a single ranged item.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                "    let item = ast::ClassSetItem::Union(frame);",
                "    let induct = ClassInduct::Item(&item);",
                "    let visitor = HeapVisitor::new();",
                "    visitor.induct_class(&induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_none());"
                ],
                [
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(matches!(result, Some(ClassFrame::Union { head, tail }) if tail.is_empty()));"
                ],
                [
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let y = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(y) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(matches!(result, Some(ClassFrame::Binary { op }) if op == &y));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(matches!(result, Some(ClassFrame::Union { head, tail }) if tail.is_empty()));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };",
                  "    let item = ast::ClassSetItem::Union(frame);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(x) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    let y = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryOp(y) }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(matches!(result, Some(ClassFrame::Binary { op }) if op == &y));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:44\n    |\n578 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:44\n    |\n578 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:54\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:77\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:136\n    |\n583 | ...negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:158\n    |\n583 | ...ind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:44\n    |\n578 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:54\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:77\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:136\n    |\n583 | ...negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:158\n    |\n583 | ...ind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:44\n    |\n587 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:73\n    |\n587 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };\n    |                                                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:95\n    |\n587 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };\n    |                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:44\n    |\n578 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:54\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:77\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:136\n    |\n583 | ...negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:158\n    |\n583 | ...ind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:592:43\n    |\n592 |     let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Ite...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:140\n    |\n592 | ...action, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem:...\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:162\n    |\n592 | ...:new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal:...\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:219\n    |\n592 | ...t()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:241\n    |\n592 | ...:new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:54\n    |\n593 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryO...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryO...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0599]: no variant or associated item named `Subtraction` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:592:93\n     |\n592  | ...d: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::ne...\n     |                                  ^^^^^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `Subtraction` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:44\n    |\n578 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:54\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:77\n    |\n583 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Item(Cl...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:136\n    |\n583 | ...negated: false, kind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:158\n    |\n583 | ...ind: ast::ClassSet::Item(ClassSetItem::Literal(Literal::default())) }));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:44\n    |\n587 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:73\n    |\n587 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };\n    |                                                                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:95\n    |\n587 |     let frame = ast::ClassSetUnion { span: Span::default(), items: vec![ClassSetItem::Literal(Literal::default())] };\n    |                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:592:43\n    |\n592 |     let x = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Ite...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:140\n    |\n592 | ...action, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem:...\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:162\n    |\n592 | ...:new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal:...\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:219\n    |\n592 | ...t()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:241\n    |\n592 | ...:new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:54\n    |\n593 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryO...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryO...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:43\n    |\n597 |     let y = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(Clas...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:597:134\n    |\n597 | ...:Union, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem:...\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:597:156\n    |\n597 | ...:new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal:...\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:597:213\n    |\n597 | ...t()))), rhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:597:235\n    |\n597 | ...:new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:598:54\n    |\n598 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryO...\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:598:77\n    |\n598 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::BinaryO...\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0599]: no variant or associated item named `Subtraction` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:592:93\n     |\n592  | ...d: ast::ClassSetBinaryOpKind::Subtraction, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::ne...\n     |                                  ^^^^^^^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `Subtraction` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:597:93\n     |\n597  | ...kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(a...\n     |                                     ^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `Union` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "    let item = ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                "    let induct = ClassInduct::Item(&class_set_item);",
                "    let visitor = HeapVisitor::new();",
                "    visitor.induct_class(&induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &ClassSetItem::Literal(Literal::from('a')));"
                ],
                [
                  "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert!(tail.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item = ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item = ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert_eq!(head, &ClassSetItem::Literal(Literal::from('a')));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item = ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let item = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))) };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(item));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    let result = visitor.induct_class(&induct);",
                  "    if let Some(Frame::Union { head, tail }) = result {",
                  "    assert!(tail.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let item = ClassBracketed {\n    |                ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:576:30\n    |\n576 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
                "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs,",
                "        rhs,",
                "    };",
                "    let bracketed = ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassSet::BinaryOp(op),",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                "    let induct = ClassInduct::Item(&class_set_item);",
                "    let visitor = HeapVisitor::new();",
                "    visitor.induct_class(&induct);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
                  "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs,",
                  "    rhs,",
                  "    };",
                  "    let bracketed = ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(op),",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
                  "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs,",
                  "        rhs,",
                  "    };",
                  "    let bracketed = ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(op),",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    let lhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('a'))));",
                  "    let rhs = Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::from('b'))));",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs,",
                  "    rhs,",
                  "    };",
                  "    let bracketed = ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(op),",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:605:51\n    |\n567 | {\n    | - closing delimiter possibly meant for this\n...\n605 |     assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union {\n    |                                                   ^ unclosed delimiter\n606 | }\n607 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:607:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n607 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
                "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
                "    let union = ClassSetUnion {",
                "        span: Span::default(),",
                "        items: vec![item1, item2],",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Union(union);",
                "    let induct = ClassInduct::Item(&class_set_item);",
                "    let visitor = HeapVisitor::new();",
                "    visitor.induct_class(&induct);",
                "}"
              ],
              "oracles": [
                [
                  "    visitor.induct_class(&induct);",
                  "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union { head: &item1, tail: &[item2] }));"
                ],
                [
                  "    visitor.induct_class(&induct);",
                  "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: Vec::new() }))).is_none());"
                ],
                [
                  "    visitor.induct_class(&induct);",
                  "    assert!(visitor.induct_class(&ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) })).is_some());"
                ],
                [
                  "    visitor.induct_class(&induct);",
                  "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(Box::new(item1)) }))).is_some());"
                ],
                [
                  "    visitor.induct_class(&induct);",
                  "    assert_eq!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) }) }))), Some(ClassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) } }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
                  "    let union = ClassSetUnion {",
                  "        span: Span::default(),",
                  "        items: vec![item1, item2],",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    visitor.induct_class(&induct);",
                  "    assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union { head: &item1, tail: &[item2] }));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
                  "    let union = ClassSetUnion {",
                  "        span: Span::default(),",
                  "        items: vec![item1, item2],",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    visitor.induct_class(&induct);",
                  "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: Vec::new() }))).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
                  "    let union = ClassSetUnion {",
                  "        span: Span::default(),",
                  "        items: vec![item1, item2],",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    visitor.induct_class(&induct);",
                  "    assert!(visitor.induct_class(&ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) })).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
                  "    let union = ClassSetUnion {",
                  "        span: Span::default(),",
                  "        items: vec![item1, item2],",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    visitor.induct_class(&induct);",
                  "    assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(Box::new(item1)) }))).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "    let item1 = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let item2 = ast::ClassSetItem::Literal(Literal::from('b'));",
                  "    let union = ClassSetUnion {",
                  "        span: Span::default(),",
                  "        items: vec![item1, item2],",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&class_set_item);",
                  "    let visitor = HeapVisitor::new();",
                  "    visitor.induct_class(&induct);",
                  "    visitor.induct_class(&induct);",
                  "    assert_eq!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) }) }))), Some(ClassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) } }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let item1 = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:44\n    |\n574 |     let item2 = ast::ClassSetItem::Literal(Literal::from('b'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:17\n    |\n575 |     let union = ClassSetUnion {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     assert_eq!(visitor.induct_class(&induct), Some(ClassFrame::Union { head: &item1, tail: &[item2] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::ClassFrame<'_>>\n    |     Option<ast::visitor::ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let item1 = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:44\n    |\n574 |     let item2 = ast::ClassSetItem::Literal(Literal::from('b'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:17\n    |\n575 |     let union = ClassSetUnion {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:79\n    |\n584 |     assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: Vec::new() })...\n    |                                                                               ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:101\n    |\n584 |     assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { span: Span::default(), items: Vec::new() })...\n    |                                                                                                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let item1 = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:44\n    |\n574 |     let item2 = ast::ClassSetItem::Literal(Literal::from('b'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:17\n    |\n575 |     let union = ClassSetUnion {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:57\n    |\n584 |     assert!(visitor.induct_class(&ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, l...\n    |                                                         ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:82\n    |\n584 |     assert!(visitor.induct_class(&ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, l...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:584:105\n    |\n584 | ...Op { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) })).is_some());\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let item1 = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:44\n    |\n574 |     let item2 = ast::ClassSetItem::Literal(Literal::from('b'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:17\n    |\n575 |     let union = ClassSetUnion {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:83\n    |\n584 |     assert!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false,...\n    |                                                                                   ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:106\n    |\n584 | ...t::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Item(Box::new(item1)) }))).is_some());\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:584:145\n    |\n584 | ... span: Span::default(), negated: false, kind: ClassSet::Item(Box::new(item1)) }))).is_some());\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:44\n    |\n573 |     let item1 = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:44\n    |\n574 |     let item2 = ast::ClassSetItem::Literal(Literal::from('b'));\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:17\n    |\n575 |     let union = ClassSetUnion {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:86\n    |\n584 |     assert_eq!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: fal...\n    |                                                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:109\n    |\n584 | ...t::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: S...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:584:148\n    |\n584 | ... span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind:...\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:167\n    |\n584 | ...lt(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Bo...\n    |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:192\n    |\n584 | ...kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Bo...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:584:215\n    |\n584 | ...Op { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) }) }))), Some(ClassFrame:...\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:330\n    |\n584 | ...item2) }) }))), Some(ClassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Bo...\n    |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:355\n    |\n584 | ...lassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Bo...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:584:378\n    |\n584 | ...Op { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) } }));\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:569:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n569 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::ClassFrame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     assert_eq!(visitor.induct_class(&ClassInduct::Item(&ast::ClassSetItem::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) }) }))), Some(ClassFrame::Binary { op: &ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(item1), rhs: Box::new(item2) } }...\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::ClassFrame<'_>>\n    |     Option<ast::visitor::ClassFrame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}