{
  "name": "regex_syntax::ast::print::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post",
  "name_with_impl": "regex_syntax::ast::print::{impl#3}::visit_class_set_item_post",
  "mod_info": {
    "name": "ast::print",
    "loc": "regex-syntax/src/ast/mod.rs:22:1:22:15"
  },
  "visible": true,
  "loc": "regex-syntax/src/ast/print.rs:139:5:160:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *ast matches Union(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Union(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestWriter {",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for TestWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut writer = TestWriter { output: String::new() };",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "",
                "    let union_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                "        // Initialize with appropriate test data",
                "    });",
                "",
                "    let _ = visitor.visit_class_set_item_post(&union_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let union_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                  "    });",
                  "    assert_eq!(writer.output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestWriter {",
                  "        output: String,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for TestWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "    ",
                  "    let mut writer = TestWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "",
                  "    let union_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                  "        // Initialize with appropriate test data",
                  "    });",
                  "",
                  "    let _ = visitor.visit_class_set_item_post(&union_item);",
                  "    let union_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                  "    });",
                  "    assert_eq!(writer.output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let union_item = ast::ClassSetItem::Union(ast::ClassSetUnion {\n    |                                               ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/print.rs:616:47\n    |\n616 |     let union_item = ast::ClassSetItem::Union(ast::ClassSetUnion {\n    |                                               ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestWriter {",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for TestWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut writer = TestWriter { output: String::new() };",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "",
                "    let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                "        // Initialize with minimal test data",
                "    });",
                "",
                "    let _ = visitor.visit_class_set_item_post(&union_empty_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let writer_output = writer.output.clone();",
                  "    assert_eq!(writer_output, \"\");"
                ],
                [
                  "    let writer_output = writer.output.clone();",
                  "    assert!(visitor.visit_class_set_item_post(&union_empty_item).is_ok());"
                ],
                [
                  "    let writer_output = writer.output.clone();",
                  "    assert_eq!(writer_output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestWriter {",
                  "        output: String,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for TestWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = TestWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "",
                  "    let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                  "        // Initialize with minimal test data",
                  "    });",
                  "",
                  "    let _ = visitor.visit_class_set_item_post(&union_empty_item);",
                  "    let writer_output = writer.output.clone();",
                  "    assert_eq!(writer_output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    struct TestWriter {",
                  "        output: String,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for TestWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = TestWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "",
                  "    let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                  "        // Initialize with minimal test data",
                  "    });",
                  "",
                  "    let _ = visitor.visit_class_set_item_post(&union_empty_item);",
                  "    let writer_output = writer.output.clone();",
                  "    assert!(visitor.visit_class_set_item_post(&union_empty_item).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestWriter {",
                  "        output: String,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for TestWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = TestWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "",
                  "    let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {",
                  "        // Initialize with minimal test data",
                  "    });",
                  "",
                  "    let _ = visitor.visit_class_set_item_post(&union_empty_item);",
                  "    let writer_output = writer.output.clone();",
                  "    assert_eq!(writer_output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/print.rs:611:53\n    |\n611 |     let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {\n    |                                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/print.rs:611:53\n    |\n611 |     let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {\n    |                                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/print.rs:611:53\n    |\n611 |     let union_empty_item = ast::ClassSetItem::Union(ast::ClassSetUnion {\n    |                                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches Bracketed(ref x) is true\n",
        "// constraint: *ast matches Bracketed(ref x) is true\n"
      ],
      "input_infer": "Bracketed(ref x) where x contains varying numbers of nested classes, at least one of which must be empty or contain a single literal.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ast::ClassSet::Normal,",
                "    }));",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:15\n    |\n600 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:602:30\n    |\n602 |         kind: ast::ClassSet::Normal,\n    |                              ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     kind: ast::ClassSet::Normal,\n    |                          ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let literal = ast::Literal {",
                "        span: Span::default(),",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'a',",
                "    };",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ast::ClassSet::Normal,",
                "    }));",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = ast::Literal {",
                  "        span: Span::default(),",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:15\n    |\n600 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:11\n    |\n613 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:607:30\n    |\n607 |         kind: ast::ClassSet::Normal,\n    |                              ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:615:26\n    |\n615 |     kind: ast::ClassSet::Normal,\n    |                          ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let nested_class = ast::ClassSetItem::Literal(ast::Literal {",
                "        span: Span::default(),",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'b',",
                "    });",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ast::ClassSet::Union,",
                "    }));",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_class = ast::ClassSetItem::Literal(ast::Literal {",
                  "    span: Span::default(),",
                  "    kind: ast::LiteralKind::Verbatim,",
                  "    c: 'b',",
                  "    });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_class = ast::ClassSetItem::Literal(ast::Literal {",
                  "        span: Span::default(),",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'b',",
                  "    });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_class = ast::ClassSetItem::Literal(ast::Literal {",
                  "    span: Span::default(),",
                  "    kind: ast::LiteralKind::Verbatim,",
                  "    c: 'b',",
                  "    });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:15\n    |\n600 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:11\n    |\n613 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:11\n    |\n618 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:607:30\n    |\n607 |         kind: ast::ClassSet::Union,\n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nhelp: there is an associated function `union` with a similar name\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     kind: ast::ClassSet::Union,\n    |                          ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nhelp: there is an associated function `union` with a similar name\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal {",
                "        span: Span::default(),",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'c',",
                "    });",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ast::ClassSet::Normal,",
                "    }));",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: 'c', });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Normal, }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: 'c', });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Normal, }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert!(output.len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal {",
                  "        span: Span::default(),",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'c',",
                  "    });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: 'c', });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Normal, }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal {",
                  "        span: Span::default(),",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'c',",
                  "    });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let nested_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let nested_literal = ast::ClassSetItem::Literal(ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: 'c', });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Normal, }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert!(output.len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let nested_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:15\n    |\n601 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:15\n    |\n606 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:49\n    |\n613 |     let nested_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:74\n    |\n614 |     let nested_literal = ast::ClassSetItem::Literal(ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: 'c', });\n    |                                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:615:81\n    |\n615 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Nor...\n    |                                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |         kind: ast::ClassSet::Normal,\n    |                              ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:615:135\n    |\n615 | ... negated: false, kind: ast::ClassSet::Normal, }));\n    |                                          ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let nested_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:15\n    |\n601 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:15\n    |\n606 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:49\n    |\n613 |     let nested_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:74\n    |\n614 |     let nested_literal = ast::ClassSetItem::Literal(ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: 'c', });\n    |                                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:615:81\n    |\n615 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::default(), negated: false, kind: ast::ClassSet::Nor...\n    |                                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |         kind: ast::ClassSet::Normal,\n    |                              ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:615:135\n    |\n615 | ... negated: false, kind: ast::ClassSet::Normal, }));\n    |                                          ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ast::ClassSet::Normal,",
                "    }));",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:15\n    |\n600 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:602:30\n    |\n602 |         kind: ast::ClassSet::Normal,\n    |                              ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     kind: ast::ClassSet::Normal,\n    |                          ^^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches Perl(ref x) is true\n",
        "// constraint: *ast matches Perl(ref x) is true\n"
      ],
      "input_infer": "negated: true, kind: { Digit, Space, Word }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };",
                "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, \"\\\\D\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, \"\\\\D\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: false };",
                "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Digit, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\S\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\S\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: false };",
                "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\s\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\s\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Space, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\W\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer, r\"\\W\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: true };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    assert_eq!(visitor.visit_class_set_item_post(&ast_item), Ok(()));"
                ],
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    assert_eq!(writer, r\"\\w\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    assert_eq!(visitor.visit_class_set_item_post(&ast_item), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };",
                  "    let ast_item = ast::ClassSetItem::Perl(perl_class);",
                  "    assert_eq!(writer, r\"\\w\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:45\n    |\n604 |     let perl_class = ast::ClassPerl { span: Span::default(), kind: ast::ClassPerlKind::Word, negated: false };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches Unicode(ref x) is true\n",
        "// constraint: *ast matches Unicode(ref x) is true\n"
      ],
      "input_infer": "Literal character values for the `Unicode` class, e.g., `c: 'a'` to `c: 'z'`, `c: 'A'` to `c: 'Z'`, and `c: '\\u{00A0}'` to `c: '\\u{FFFF}'`, also include `negated: false` and `negated: true` for edge cases, as well as various named classes like `Named(ref x)` with values such as `Name: \"Scx\"` and `Value: \"Katakana\"`; therefore, the ranges should be: 'a' to 'z', 'A' to 'Z', '\\u{00A0}' to '\\u{FFFF}', and included tests for `negated: true` and `negated: false`.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassUnicodeKind::OneLetter('a'),",
                "    });",
                "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    });",
                  "    assert_eq!(output, r\"\\p{a}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
                  "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    });",
                  "    assert_eq!(output, r\"\\p{a}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::OneLetter('a'),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:11\n    |\n609 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:611:11\n    |\n611 |     kind: ClassUnicodeKind::OneLetter('a'),\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                "        span: Span::default(),",
                "        negated: true,",
                "        kind: ClassUnicodeKind::OneLetter('A'),",
                "    });",
                "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "    span: Span::default(),",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::OneLetter('A'),",
                  "    });",
                  "    assert_eq!(output, r\"\\PA\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: true,",
                  "        kind: ClassUnicodeKind::OneLetter('A'),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_literal).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let unicode_literal = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "    span: Span::default(),",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::OneLetter('A'),",
                  "    });",
                  "    assert_eq!(output, r\"\\PA\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::OneLetter('A'),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:11\n    |\n614 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:616:11\n    |\n616 |     kind: ClassUnicodeKind::OneLetter('A'),\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassUnicodeKind::Named(\"Scx\"),",
                "    });",
                "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert_eq!(output, expected_output);"
                ],
                [
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert!(output.contains(r\"\\p{\" ));"
                ],
                [
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert!(output.contains(\"Scx\"));"
                ],
                [
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert!(!output.contains(r\"\\P{\" ));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::Named(\"Scx\"),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::Named(\"Scx\"),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert!(output.contains(r\"\\p{\" ));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::Named(\"Scx\"),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert!(output.contains(\"Scx\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_named = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::Named(\"Scx\"),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named).unwrap();",
                  "    let expected_output = r\"\\p{Scx}\";",
                  "    assert!(!output.contains(r\"\\P{\" ));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::Named(\"Scx\"),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::Named(\"Scx\"),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::Named(\"Scx\"),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::Named(\"Scx\"),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                "        span: Span::default(),",
                "        negated: true,",
                "        kind: ClassUnicodeKind::NamedValue {",
                "            op: ClassUnicodeOpKind::Equal,",
                "            name: \"Scx\".to_string(),",
                "            value: \"Katakana\".to_string(),",
                "        },",
                "    });",
                "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    output.clear();",
                  "    assert_eq!(output, r\"\\P{Scx=Katakana}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: true,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            op: ClassUnicodeOpKind::Equal,",
                  "            name: \"Scx\".to_string(),",
                  "            value: \"Katakana\".to_string(),",
                  "        },",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
                  "    output.clear();",
                  "    assert_eq!(output, r\"\\P{Scx=Katakana}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::NamedValue {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeOpKind`\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |             op: ClassUnicodeOpKind::Equal,\n    |                 ^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeOpKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassUnicodeKind::NamedValue {",
                "            op: ClassUnicodeOpKind::NotEqual,",
                "            name: \"Scx\".to_string(),",
                "            value: \"Hiragana\".to_string(),",
                "        },",
                "    });",
                "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ClassUnicodeOpKind::NotEqual,",
                  "    name: \"Scx\".to_string(),",
                  "    value: \"Hiragana\".to_string(),",
                  "    },",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
                  "    assert_eq!(output, r\"\\p{Scx!=Hiragana}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            op: ClassUnicodeOpKind::NotEqual,",
                  "            name: \"Scx\".to_string(),",
                  "            value: \"Hiragana\".to_string(),",
                  "        },",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let unicode_named_value = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ClassUnicodeOpKind::NotEqual,",
                  "    name: \"Scx\".to_string(),",
                  "    value: \"Hiragana\".to_string(),",
                  "    },",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_named_value).unwrap();",
                  "    assert_eq!(output, r\"\\p{Scx!=Hiragana}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::NamedValue {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeOpKind`\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |             op: ClassUnicodeOpKind::NotEqual,\n    |                 ^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeOpKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:11\n    |\n618 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:11\n    |\n620 |     kind: ClassUnicodeKind::NamedValue {\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeOpKind`\n   --> regex-syntax/src/ast/print.rs:621:9\n    |\n621 |     op: ClassUnicodeOpKind::NotEqual,\n    |         ^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeOpKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                "        span: Span::default(),",
                "        negated: false,",
                "        kind: ClassUnicodeKind::Range(ast::ClassSetRange {",
                "            span: Span::default(),",
                "            start: ast::Literal {",
                "                span: Span::default(),",
                "                kind: ast::LiteralKind::Verbatim,",
                "                c: '\\u{00A0}',",
                "            },",
                "            end: ast::Literal {",
                "                span: Span::default(),",
                "                kind: ast::LiteralKind::Verbatim,",
                "                c: '\\u{FFFF}',",
                "            },",
                "        }),",
                "    });",
                "    writer.visit_class_set_item_post(&unicode_range).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let output = String::new();",
                  "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::Range(ast::ClassSetRange { span: Span::default(), start: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{00A0}', }, end: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{FFFF}', }, }), });",
                  "    assert_eq!(output, r\"\\u00A0-\\uFFFF\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode {",
                  "        span: Span::default(),",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::Range(ast::ClassSetRange {",
                  "            span: Span::default(),",
                  "            start: ast::Literal {",
                  "                span: Span::default(),",
                  "                kind: ast::LiteralKind::Verbatim,",
                  "                c: '\\u{00A0}',",
                  "            },",
                  "            end: ast::Literal {",
                  "                span: Span::default(),",
                  "                kind: ast::LiteralKind::Verbatim,",
                  "                c: '\\u{FFFF}',",
                  "            },",
                  "        }),",
                  "    });",
                  "    writer.visit_class_set_item_post(&unicode_range).unwrap();",
                  "    let output = String::new();",
                  "    let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::Range(ast::ClassSetRange { span: Span::default(), start: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{00A0}', }, end: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{FFFF}', }, }), });",
                  "    assert_eq!(output, r\"\\u00A0-\\uFFFF\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:15\n    |\n603 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         kind: ClassUnicodeKind::Range(ast::ClassSetRange {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:19\n    |\n606 |             span: Span::default(),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:23\n    |\n608 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:23\n    |\n613 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:78\n    |\n621 |     let unicode_range = ast::ClassSetItem::Unicode(ast::ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::Ran...\n    |                                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:621:117\n    |\n621 | ...pan::default(), negated: false, kind: ClassUnicodeKind::Range(ast::ClassSetRange { span: Span::default(), start: ast::Literal { span: ...\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:168\n    |\n621 | ...lassUnicodeKind::Range(ast::ClassSetRange { span: Span::default(), start: ast::Literal { span: Span::default(), kind: ast::LiteralKind...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:213\n    |\n621 | ...pan: Span::default(), start: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{00A0}', }, end: ast::Liter...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:308\n    |\n621 | ...atim, c: '\\u{00A0}', }, end: ast::Literal { span: Span::default(), kind: ast::LiteralKind::Verbatim, c: '\\u{FFFF}', }, }), });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches Ascii(ref x) is true\n",
        "// constraint: *ast matches Ascii(ref x) is true\n"
      ],
      "input_infer": "0 <= ast.kind <= 255, negated in {true, false}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; // Initialize the span as required",
                "    let class_ascii = ast::ClassAscii {",
                "        span,",
                "        kind: ast::ClassAsciiKind::Alnum,",
                "        negated: true,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer.wtr, \"[:^alnum:]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Alnum,",
                  "        negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Alnum,",
                  "        negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer.wtr, \"[:^alnum:]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0609]: no field `wtr` on type `ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:617:23\n    |\n617 |     assert_eq!(writer.wtr, \"[:^alnum:]\");\n    |                       ^^^ unknown field\n    |\n    = note: available field is: `_priv`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; // Initialize the span as required",
                "    let class_ascii = ast::ClassAscii {",
                "        span,",
                "        kind: ast::ClassAsciiKind::Alpha,",
                "        negated: false,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = \"[:alpha:]\";",
                  "    assert_eq!(visitor.wtr, expected_output);"
                ],
                [
                  "    let expected_output = \"[:alpha:]\";",
                  "    assert!(matches!(visitor.visit_class_set_item_post(&ast_item), Ok(())));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let expected_output = \"[:alpha:]\";",
                  "    assert_eq!(visitor.wtr, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let expected_output = \"[:alpha:]\";",
                  "    assert!(matches!(visitor.visit_class_set_item_post(&ast_item), Ok(())));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; // Initialize the span as required",
                "    let class_ascii = ast::ClassAscii {",
                "        span,",
                "        kind: ast::ClassAsciiKind::Punct,",
                "        negated: true,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Punct,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Punct,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(visitor.wtr, \"[:^punct:]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Punct,",
                  "        negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    use ast::Span;",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Punct,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Punct,",
                  "        negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Punct,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(visitor.wtr, \"[:^punct:]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `end` and `start` in initializer of `Span`\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ missing `end` and `start`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; // Initialize the span as required",
                "    let class_ascii = ast::ClassAscii {",
                "        span,",
                "        kind: ast::ClassAsciiKind::Space,",
                "        negated: false,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer.wtr, \"[:space:]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer.wtr, \"[:space:]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0609]: no field `wtr` on type `ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:617:23\n    |\n617 |     assert_eq!(writer.wtr, \"[:space:]\");\n    |                       ^^^ unknown field\n    |\n    = note: available field is: `_priv`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; // Initialize the span as required",
                "    let class_ascii = ast::ClassAscii {",
                "        span,",
                "        kind: ast::ClassAsciiKind::Digit,",
                "        negated: true,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer.wtr, r\"[:^digit:]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: true,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(writer.wtr, r\"[:^digit:]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0609]: no field `wtr` on type `ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:617:23\n    |\n617 |     assert_eq!(writer.wtr, r\"[:^digit:]\");\n    |                       ^^^ unknown field\n    |\n    = note: available field is: `_priv`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; // Initialize the span as required",
                "    let class_ascii = ast::ClassAscii {",
                "        span,",
                "        kind: ast::ClassAsciiKind::Digit,",
                "        negated: false,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(visitor.wtr, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {}; // Initialize the span as required",
                  "    let class_ascii = ast::ClassAscii {",
                  "        span,",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let span = Span {};",
                  "    let class_ascii = ast::ClassAscii {",
                  "    span,",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(class_ascii);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(visitor.wtr, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:16\n    |\n597 |     let span = Span {}; // Initialize the span as required\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: self.fmt_literal(&x.start)? is Err/None\n"
      ],
      "input_infer": "0 <= x.start <= x.end <= 0x10FFFF\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = ast::ClassSetItem::Empty(Span::default());",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert_eq!(writer.wtr, \"a-z\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\pb\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert_eq!(writer.wtr, \"a-z\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\pb\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Empty(Span::default());",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
                  "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                        ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:59\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:604:82\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                        ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:59\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:604:82\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                          ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:63\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:102\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                                                                      ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                        ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:59\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:604:82\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                       ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:57\n    |\n606 |     let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:80\n    |\n606 |     let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                          ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:63\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:102\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                                                                      ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                        ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:59\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:604:82\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                          ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:63\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:102\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                                                                      ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:53\n    |\n607 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));\n    |                                                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:40\n    |\n599 |     let ast = ast::ClassSetItem::Empty(Span::default());\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:603:40\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:62\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:86\n    |\n603 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::...\n    |                                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:102\n    |\n603 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:125\n    |\n603 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:163\n    |\n603 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:179\n    |\n603 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:202\n    |\n603 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                        ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:59\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:604:82\n    |\n604 |     let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                          ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:63\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:605:102\n    |\n605 |     let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });\n    |                                                                                                      ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                       ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:57\n    |\n606 |     let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:80\n    |\n606 |     let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:53\n    |\n607 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));\n    |                                                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 |     let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                "    let ast = ast::ClassSetItem::Literal(literal);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
                  "    assert_eq!(writer.visit_class_set_item_post(&ast), Err(fmt::Error));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
                  "    let result = writer.wtr;",
                  "    assert_eq!(result, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
                  "    let result = writer.wtr;",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal, end: literal });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Literal(literal);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
                  "    assert_eq!(writer.visit_class_set_item_post(&ast), Err(fmt::Error));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Literal(literal);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "",
                  "    let result = writer.wtr;",
                  "    assert_eq!(result, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = ast::ClassSetItem::Literal(literal);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
                  "    let result = writer.wtr;",
                  "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal, end: literal });",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:599:19\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:35\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:599:58\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:19\n    |\n604 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:35\n    |\n604 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:58\n    |\n604 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:62\n    |\n605 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:599:19\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:35\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:599:58\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:19\n    |\n604 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:35\n    |\n604 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:58\n    |\n604 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:599:19\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:35\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:599:58\n    |\n599 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:62\n    |\n605 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal, end: literal });\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:62\n    |\n607 |     let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal, end: literal });\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                "    let ast = ast::ClassSetItem::Range(range);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_err());"
                ],
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:599:25\n    |\n599 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:41\n    |\n599 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:599:64\n    |\n599 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:23\n    |\n600 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:39\n    |\n600 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:62\n    |\n600 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:599:25\n    |\n599 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:41\n    |\n599 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:599:64\n    |\n599 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:23\n    |\n600 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:39\n    |\n600 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:62\n    |\n600 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' }; // valid but non-integer",
                "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                "    let ast = ast::ClassSetItem::Range(range);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' }; // valid but non-integer",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let ast = ast::ClassSetItem::Range(range);",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:25\n    |\n600 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' }; // valid but non-integer\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:41\n    |\n600 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' }; // valid but non-integer\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:64\n    |\n600 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' }; // valid but non-integer\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:23\n    |\n601 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:62\n    |\n601 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:602:17\n    |\n602 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:39\n    |\n602 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:25\n    |\n606 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:64\n    |\n606 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:23\n    |\n607 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:62\n    |\n607 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:608:17\n    |\n608 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:39\n    |\n608 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert!(writer.wtr == \"a-z\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_empty).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_union).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_literal).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    assert!(writer.wtr == \"x\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_ascii).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    assert!(writer.wtr == \"[:alpha:]\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_unicode).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    assert!(writer.wtr == r\"\\pA\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_perl).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert!(writer.wtr == r\"\\D\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_bracketed).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    assert!(writer.wtr == \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    assert!(writer.wtr == \"a-z\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_empty).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_union).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_literal).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    assert!(writer.wtr == \"x\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_ascii).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    assert!(writer.wtr == \"[:alpha:]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_unicode).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    assert!(writer.wtr == r\"\\pA\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_perl).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    assert!(writer.wtr == r\"\\D\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item_bracketed).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
                  "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
                  "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
                  "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
                  "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
                  "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
                  "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
                  "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
                  "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    assert!(writer.wtr == \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:42\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:599:65\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:604:51\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:73\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:97\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:113\n    |\n604 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:136\n    |\n604 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:174\n    |\n604 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:190\n    |\n604 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:213\n    |\n604 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:42\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:599:65\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:604:51\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:73\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:97\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:113\n    |\n604 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:136\n    |\n604 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:174\n    |\n604 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:190\n    |\n604 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:213\n    |\n604 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:42\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:599:65\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:604:51\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:73\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:97\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:113\n    |\n604 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:136\n    |\n604 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:174\n    |\n604 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:190\n    |\n604 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:213\n    |\n604 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:42\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:599:65\n    |\n599 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:604:51\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:73\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:97\n    |\n604 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:113\n    |\n604 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:136\n    |\n604 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:174\n    |\n604 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:190\n    |\n604 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:213\n    |\n604 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:606:57\n    |\n606 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                             ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:121\n    |\n606 | ...pan::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                             ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:121\n    |\n606 | ...pan::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                             ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:121\n    |\n606 | ...pan::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                       ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:73\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:607:96\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                             ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:121\n    |\n606 | ...pan::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                       ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:73\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:607:96\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                             ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:121\n    |\n606 | ...pan::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                       ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:73\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:607:96\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:74\n    |\n608 |     let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: Cl...\n    |                                                                          ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:97\n    |\n608 |     let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: Cl...\n    |                                                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ... span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                       ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:42\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:596:65\n    |\n596 |     let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };\n    |                                                                 ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:174\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:190\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:213\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:57\n    |\n602 |     let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());\n    |                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:603:57\n    |\n603 |     let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});\n    |                                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:61\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:77\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:100\n    |\n604 |     let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:605:57\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:76\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:605:99\n    |\n605 |     let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });\n    |                                                                                                   ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                             ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind:...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:121\n    |\n606 | ...pan::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                       ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:73\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:607:96\n    |\n607 |     let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });\n    |                                                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:74\n    |\n608 |     let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: Cl...\n    |                                                                          ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:97\n    |\n608 |     let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: Cl...\n    |                                                                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ... span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };",
                "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert_eq!(writer.wtr, \"a-z\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert_eq!(printer, Printer { _priv: () });"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert!(writer.wtr.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };",
                  "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };",
                  "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert_eq!(writer.wtr, \"a-z\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };",
                  "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert_eq!(printer, Printer { _priv: () });",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };",
                  "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
                  "    let ast = ast::ClassSetItem::Range(class_range);",
                  "    let result = writer.visit_class_set_item_post(&ast);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:23\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:45\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:69\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                     ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:108\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:146\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:162\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:185\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:23\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:45\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:69\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                     ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:108\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:146\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:162\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:185\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:23\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:45\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:69\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                     ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:108\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:146\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:162\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:185\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:604:5\n    |\n604 |     assert_eq!(printer, Printer { _priv: () });\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::print::Printer\n    |     ast::print::Printer\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:59:1\n    |\n59  | pub struct Printer {\n    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::print::Printer` with `#[derive(PartialEq)]`\n    |\n59  + #[derive(PartialEq)]\n60  | pub struct Printer {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:23\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:45\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:69\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                     ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:108\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:146\n    |\n601 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:162\n    |\n601 | ...ralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:185\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                "    let ast = ast::ClassSetItem::Perl(class_perl);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = ast::ClassSetItem::Perl(class_perl);",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = ast::ClassSetItem::Perl(class_perl);",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = ast::ClassSetItem::Perl(class_perl);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = ast::ClassSetItem::Perl(class_perl);",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = ast::ClassSetItem::Perl(class_perl);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = ast::ClassSetItem::Perl(class_perl);",
                  "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:40\n    |\n596 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:596:63\n    |\n596 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:601:22\n    |\n601 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:40\n    |\n601 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:601:63\n    |\n601 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:40\n    |\n596 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:596:63\n    |\n596 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:601:22\n    |\n601 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:40\n    |\n601 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:601:63\n    |\n601 |     let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_err());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
                  "    assert_eq!(writer.wtr, \"A-Z\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
                  "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
                  "    assert_eq!(writer.wtr, \"A-Z\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:177\n    |\n601 | ...(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:193\n    |\n601 | ...Kind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:216\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:177\n    |\n601 | ...(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:193\n    |\n601 | ...Kind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:216\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:177\n    |\n601 | ...(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:193\n    |\n601 | ...Kind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:216\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:602:51\n    |\n602 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:97\n    |\n602 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:113\n    |\n602 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:136\n    |\n602 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:174\n    |\n602 | ...ult(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:190\n    |\n602 | ...ralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:213\n    |\n602 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:97\n    |\n601 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:113\n    |\n601 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:136\n    |\n601 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:177\n    |\n601 | ...(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:193\n    |\n601 | ...Kind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:216\n    |\n601 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:602:51\n    |\n602 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                   ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:97\n    |\n602 |     let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Li...\n    |                                                                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:113\n    |\n602 | ...e { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::d...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:136\n    |\n602 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:174\n    |\n602 | ...ult(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:190\n    |\n602 | ...ralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:213\n    |\n602 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                "    let ast = ast::ClassSetItem::Union(class_union);",
                "    writer.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    assert!(writer.visit_class_set_item_post(&class_empty).is_ok());"
                ],
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    assert_eq!(writer.visit_class_set_item_post(&class_literal).is_ok(), true);"
                ],
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    assert!(writer.visit_class_set_item_post(&class_range).is_ok());"
                ],
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    assert!(writer.visit_class_set_item_post(&class_ascii).is_ok());"
                ],
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let class_unicode = ClassSetItem::Unicode(unicode);",
                  "    assert!(writer.visit_class_set_item_post(&class_unicode).is_ok());"
                ],
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let class_unicode = ClassSetItem::Unicode(unicode);",
                  "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let class_perl = ClassSetItem::Perl(perl);",
                  "    assert!(writer.visit_class_set_item_post(&class_perl).is_ok());"
                ],
                [
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let class_unicode = ClassSetItem::Unicode(unicode);",
                  "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let class_perl = ClassSetItem::Perl(perl);",
                  "    let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };",
                  "    let class_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    assert!(writer.visit_class_set_item_post(&class_bracketed).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    assert!(writer.visit_class_set_item_post(&class_empty).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    assert_eq!(writer.visit_class_set_item_post(&class_literal).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    assert!(writer.visit_class_set_item_post(&class_range).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    assert!(writer.visit_class_set_item_post(&class_ascii).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let class_unicode = ClassSetItem::Unicode(unicode);",
                  "    assert!(writer.visit_class_set_item_post(&class_unicode).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let class_unicode = ClassSetItem::Unicode(unicode);",
                  "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let class_perl = ClassSetItem::Perl(perl);",
                  "    assert!(writer.visit_class_set_item_post(&class_perl).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
                  "    let ast = ast::ClassSetItem::Union(class_union);",
                  "    writer.visit_class_set_item_post(&ast).unwrap();",
                  "    let class_empty = ClassSetItem::Empty(Span::default());",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let class_literal = ClassSetItem::Literal(literal);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_range = ClassSetItem::Range(range);",
                  "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
                  "    let class_ascii = ClassSetItem::Ascii(ascii);",
                  "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let class_unicode = ClassSetItem::Unicode(unicode);",
                  "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
                  "    let class_perl = ClassSetItem::Perl(perl);",
                  "    let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };",
                  "    let class_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    assert!(writer.visit_class_set_item_post(&class_bracketed).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:19\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:35\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:604:25\n    |\n604 |     let class_literal = ClassSetItem::Literal(literal);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:19\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:35\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:604:25\n    |\n604 |     let class_literal = ClassSetItem::Literal(literal);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:23\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:608:23\n    |\n608 |     let class_range = ClassSetItem::Range(range);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:19\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:35\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:604:25\n    |\n604 |     let class_literal = ClassSetItem::Literal(literal);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:23\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:608:23\n    |\n608 |     let class_range = ClassSetItem::Range(range);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:609:17\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                 ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:36\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:609:59\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                                           ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:610:23\n    |\n610 |     let class_ascii = ClassSetItem::Ascii(ascii);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:19\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:35\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:604:25\n    |\n604 |     let class_literal = ClassSetItem::Literal(literal);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:23\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:608:23\n    |\n608 |     let class_range = ClassSetItem::Range(range);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:609:17\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                 ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:36\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:609:59\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                                           ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:610:23\n    |\n610 |     let class_ascii = ClassSetItem::Ascii(ascii);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                   ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:40\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:611:79\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let class_unicode = ClassSetItem::Unicode(unicode);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:19\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:35\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:604:25\n    |\n604 |     let class_literal = ClassSetItem::Literal(literal);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:23\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:608:23\n    |\n608 |     let class_range = ClassSetItem::Range(range);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:609:17\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                 ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:36\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:609:59\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                                           ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:610:23\n    |\n610 |     let class_ascii = ClassSetItem::Ascii(ascii);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                   ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:40\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:611:79\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let class_unicode = ClassSetItem::Unicode(unicode);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:613:16\n    |\n613 |     let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:34\n    |\n613 |     let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:613:57\n    |\n613 |     let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                                         ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:614:22\n    |\n614 |     let class_perl = ClassSetItem::Perl(perl);\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:23\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:45\n    |\n596 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:23\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                       ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:45\n    |\n599 |     let class_union = ClassSetUnion { span: Span::default(), items: vec![] };\n    |                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:602:23\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let class_empty = ClassSetItem::Empty(Span::default());\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:19\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:35\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:604:25\n    |\n604 |     let class_literal = ClassSetItem::Literal(literal);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:41\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:64\n    |\n605 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:23\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:39\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };\n    |                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:607:17\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:608:23\n    |\n608 |     let class_range = ClassSetItem::Range(range);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/print.rs:609:17\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                 ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:36\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAsciiKind`\n   --> regex-syntax/src/ast/print.rs:609:59\n    |\n609 |     let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };\n    |                                                           ^^^^^^^^^^^^^^ use of undeclared type `ClassAsciiKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassAsciiKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:610:23\n    |\n610 |     let class_ascii = ClassSetItem::Ascii(ascii);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                   ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:40\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:611:79\n    |\n611 |     let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let class_unicode = ClassSetItem::Unicode(unicode);\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:613:16\n    |\n613 |     let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:613:34\n    |\n613 |     let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:613:57\n    |\n613 |     let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };\n    |                                                         ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:614:22\n    |\n614 |     let class_perl = ClassSetItem::Perl(perl);\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:615:21\n    |\n615 |     let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };\n    |                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:615:44\n    |\n615 |     let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:615:83\n    |\n615 |     let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };\n    |                                                                                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:616:27\n    |\n616 |     let class_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));\n    |                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 36 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: self.fmt_literal(&x.start)? is Ok/Some\n",
        "// constraint: self.wtr.write_str(\"-\")? is Err/None\n"
      ],
      "input_infer": "test input ranges: x.start and x.end must be valid literals where x.start < x.end, self.wtr must trigger an error during write, literals must be within valid Unicode scalar values (0 to 0x10FFFF)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockWriter {",
                "        should_error: bool,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                "            if self.should_error {",
                "                Err(fmt::Error)",
                "            } else {",
                "                Ok(())",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = MockWriter { should_error: true };",
                "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                "    ",
                "    let start_literal = Literal {",
                "        span: Span,",
                "        kind: LiteralKind::Verbatim,",
                "        c: 'a',",
                "    };",
                "    ",
                "    let end_literal = Literal {",
                "        span: Span,",
                "        kind: LiteralKind::Verbatim,",
                "        c: 'z',",
                "    };",
                "    ",
                "    let class_set_range = ClassSetRange {",
                "        span: Span,",
                "        start: start_literal,",
                "        end: end_literal,",
                "    };",
                "    ",
                "    let ast_item = ClassSetItem::Range(class_set_range);",
                "    ",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = MockWriter { should_error: true };",
                  "    assert_eq!(visitor.visit_class_set_item_post(&ast_item), Err(fmt::Error));"
                ],
                [
                  "    let mut writer = MockWriter { should_error: true };",
                  "    assert!(writer.should_error);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockWriter {",
                  "        should_error: bool,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                  "            if self.should_error {",
                  "                Err(fmt::Error)",
                  "            } else {",
                  "                Ok(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = MockWriter { should_error: true };",
                  "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'z',",
                  "    };",
                  "    ",
                  "    let class_set_range = ClassSetRange {",
                  "        span: Span,",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "    ",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = MockWriter { should_error: true };",
                  "    assert_eq!(visitor.visit_class_set_item_post(&ast_item), Err(fmt::Error));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockWriter {",
                  "        should_error: bool,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                  "            if self.should_error {",
                  "                Err(fmt::Error)",
                  "            } else {",
                  "                Ok(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = MockWriter { should_error: true };",
                  "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'z',",
                  "    };",
                  "    ",
                  "    let class_set_range = ClassSetRange {",
                  "        span: Span,",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "    ",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = MockWriter { should_error: true };",
                  "    assert!(writer.should_error);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:613:15\n    |\n613 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:614:15\n    |\n614 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:618:23\n    |\n618 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:619:15\n    |\n619 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:620:15\n    |\n620 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let class_set_range = ClassSetRange {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:15\n    |\n625 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:630:20\n    |\n630 |     let ast_item = ClassSetItem::Range(class_set_range);\n    |                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:613:15\n    |\n613 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:614:15\n    |\n614 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:618:23\n    |\n618 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:619:15\n    |\n619 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:620:15\n    |\n620 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let class_set_range = ClassSetRange {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:15\n    |\n625 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:630:20\n    |\n630 |     let ast_item = ClassSetItem::Range(class_set_range);\n    |                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockWriter {",
                "        should_error: bool,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                "            if self.should_error {",
                "                Err(fmt::Error)",
                "            } else {",
                "                Ok(())",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = MockWriter { should_error: false };",
                "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                "    ",
                "    let start_literal = Literal {",
                "        span: Span,",
                "        kind: LiteralKind::Verbatim,",
                "        c: '0',",
                "    };",
                "    ",
                "    let end_literal = Literal {",
                "        span: Span,",
                "        kind: LiteralKind::Verbatim,",
                "        c: '9',",
                "    };",
                "    ",
                "    let class_set_range = ClassSetRange {",
                "        span: Span,",
                "        start: start_literal,",
                "        end: end_literal,",
                "    };",
                "    ",
                "    let ast_item = ClassSetItem::Range(class_set_range);",
                "    ",
                "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let start_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '0',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '9',",
                  "    };",
                  "    let class_set_range = ClassSetRange {",
                  "    span: Span,",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let start_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '0',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '9',",
                  "    };",
                  "    let class_set_range = ClassSetRange {",
                  "    span: Span,",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = MockWriter { should_error: true };",
                  "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockWriter {",
                  "        should_error: bool,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                  "            if self.should_error {",
                  "                Err(fmt::Error)",
                  "            } else {",
                  "                Ok(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = MockWriter { should_error: false };",
                  "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '0',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '9',",
                  "    };",
                  "    ",
                  "    let class_set_range = ClassSetRange {",
                  "        span: Span,",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "    ",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let start_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '0',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '9',",
                  "    };",
                  "    let class_set_range = ClassSetRange {",
                  "    span: Span,",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockWriter {",
                  "        should_error: bool,",
                  "    }",
                  "    ",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                  "            if self.should_error {",
                  "                Err(fmt::Error)",
                  "            } else {",
                  "                Ok(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = MockWriter { should_error: false };",
                  "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '0',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '9',",
                  "    };",
                  "    ",
                  "    let class_set_range = ClassSetRange {",
                  "        span: Span,",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "    ",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast_item);",
                  "    let start_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '0',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: '9',",
                  "    };",
                  "    let class_set_range = ClassSetRange {",
                  "    span: Span,",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let ast_item = ClassSetItem::Range(class_set_range);",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    let mut writer = MockWriter { should_error: true };",
                  "    let mut visitor = Writer { printer: &mut printer, wtr: &mut writer };",
                  "    let result = visitor.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:613:15\n    |\n613 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:614:15\n    |\n614 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:618:23\n    |\n618 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:619:15\n    |\n619 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:620:15\n    |\n620 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let class_set_range = ClassSetRange {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:15\n    |\n625 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:630:20\n    |\n630 |     let ast_item = ClassSetItem::Range(class_set_range);\n    |                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:633:25\n    |\n633 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:634:11\n    |\n634 |     span: Span,\n    |           ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:635:11\n    |\n635 |     kind: LiteralKind::Verbatim,\n    |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:638:23\n    |\n638 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:639:11\n    |\n639 |     span: Span,\n    |           ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:640:11\n    |\n640 |     kind: LiteralKind::Verbatim,\n    |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:643:27\n    |\n643 |     let class_set_range = ClassSetRange {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:644:11\n    |\n644 |     span: Span,\n    |           ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:648:20\n    |\n648 |     let ast_item = ClassSetItem::Range(class_set_range);\n    |                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:612:25\n    |\n612 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:613:15\n    |\n613 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:614:15\n    |\n614 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:618:23\n    |\n618 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:619:15\n    |\n619 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:620:15\n    |\n620 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let class_set_range = ClassSetRange {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:15\n    |\n625 |         span: Span,\n    |               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:630:20\n    |\n630 |     let ast_item = ClassSetItem::Range(class_set_range);\n    |                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:633:25\n    |\n633 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:634:11\n    |\n634 |     span: Span,\n    |           ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:635:11\n    |\n635 |     kind: LiteralKind::Verbatim,\n    |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:638:23\n    |\n638 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:639:11\n    |\n639 |     span: Span,\n    |           ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:640:11\n    |\n640 |     kind: LiteralKind::Verbatim,\n    |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:643:27\n    |\n643 |     let class_set_range = ClassSetRange {\n    |                           ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:644:11\n    |\n644 |     span: Span,\n    |           ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/print.rs:648:20\n    |\n648 |     let ast_item = ClassSetItem::Range(class_set_range);\n    |                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: self.fmt_literal(&x.start)? is Ok/Some\n",
        "// constraint: self.wtr.write_str(\"-\")? is Ok/Some\n",
        "// constraint: self.fmt_literal(&x.end)? is Err/None\n"
      ],
      "input_infer": "ClassSetItem::Range(ClassSetRange { start: Literal { c: '\\u{0000}', kind: LiteralKind::Verbatim, .. }, end: Literal { c: '\\u{FFFF}', kind: LiteralKind::Verbatim, .. })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let start_literal = Literal {",
                "        span: Span {}, // Replace with actual span initialization",
                "        kind: LiteralKind::Verbatim,",
                "        c: '\\u{0000}',",
                "    };",
                "",
                "    let end_literal = Literal {",
                "        span: Span {}, // Replace with actual span initialization",
                "        kind: LiteralKind::Verbatim,",
                "        c: '\\u{FFFF}',",
                "    };",
                "",
                "    let range = ClassSetRange {",
                "        span: Span {}, // Replace with actual span initialization",
                "        start: start_literal,",
                "        end: end_literal,",
                "    };",
                "",
                "    let range_item = ast::ClassSetItem::Range(range);",
                "",
                "    let result = writer.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };",
                  "    let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };",
                  "    let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };",
                  "    let range_item = ast::ClassSetItem::Range(range);",
                  "    let result = writer.visit_class_set_item_post(&range_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };",
                  "    let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };",
                  "    let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };",
                  "    let range_item = ast::ClassSetItem::Range(range);",
                  "    let result = writer.visit_class_set_item_post(&range_item);",
                  "    assert!(output.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let start_literal = Literal {",
                  "        span: Span {}, // Replace with actual span initialization",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{0000}',",
                  "    };",
                  "",
                  "    let end_literal = Literal {",
                  "        span: Span {}, // Replace with actual span initialization",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{FFFF}',",
                  "    };",
                  "",
                  "    let range = ClassSetRange {",
                  "        span: Span {}, // Replace with actual span initialization",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "",
                  "    let range_item = ast::ClassSetItem::Range(range);",
                  "",
                  "    let result = writer.visit_class_set_item_post(&range_item);",
                  "    let output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };",
                  "    let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };",
                  "    let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };",
                  "    let range_item = ast::ClassSetItem::Range(range);",
                  "    let result = writer.visit_class_set_item_post(&range_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let start_literal = Literal {",
                  "        span: Span {}, // Replace with actual span initialization",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{0000}',",
                  "    };",
                  "",
                  "    let end_literal = Literal {",
                  "        span: Span {}, // Replace with actual span initialization",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{FFFF}',",
                  "    };",
                  "",
                  "    let range = ClassSetRange {",
                  "        span: Span {}, // Replace with actual span initialization",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "",
                  "    let range_item = ast::ClassSetItem::Range(range);",
                  "",
                  "    let result = writer.visit_class_set_item_post(&range_item);",
                  "    let output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };",
                  "    let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };",
                  "    let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };",
                  "    let range_item = ast::ClassSetItem::Range(range);",
                  "    let result = writer.visit_class_set_item_post(&range_item);",
                  "    assert!(output.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:598:25\n    |\n598 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:15\n    |\n599 |         span: Span {}, // Replace with actual span initialization\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:15\n    |\n600 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:23\n    |\n604 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         span: Span {}, // Replace with actual span initialization\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:15\n    |\n606 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:610:17\n    |\n610 |     let range = ClassSetRange {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:15\n    |\n611 |         span: Span {}, // Replace with actual span initialization\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:622:25\n    |\n622 |     let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:622:41\n    |\n622 |     let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };\n    |                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:622:56\n    |\n622 |     let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:623:23\n    |\n623 |     let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:623:39\n    |\n623 |     let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:623:54\n    |\n623 |     let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };\n    |                                                      ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:624:17\n    |\n624 |     let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:39\n    |\n624 |     let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:598:25\n    |\n598 |     let start_literal = Literal {\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:15\n    |\n599 |         span: Span {}, // Replace with actual span initialization\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:15\n    |\n600 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:23\n    |\n604 |     let end_literal = Literal {\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:15\n    |\n605 |         span: Span {}, // Replace with actual span initialization\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:15\n    |\n606 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:610:17\n    |\n610 |     let range = ClassSetRange {\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:15\n    |\n611 |         span: Span {}, // Replace with actual span initialization\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:622:25\n    |\n622 |     let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };\n    |                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:622:41\n    |\n622 |     let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };\n    |                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:622:56\n    |\n622 |     let start_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{0000}' };\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:623:23\n    |\n623 |     let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };\n    |                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:623:39\n    |\n623 |     let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:623:54\n    |\n623 |     let end_literal = Literal { span: Span {}, kind: LiteralKind::Verbatim, c: '\\u{FFFF}' };\n    |                                                      ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:624:17\n    |\n624 |     let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };\n    |                 ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:39\n    |\n624 |     let range = ClassSetRange { span: Span {}, start: start_literal, end: end_literal };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: *ast matches Range(ref x) is true\n",
        "// constraint: self.fmt_literal(&x.start)? is Ok/Some\n",
        "// constraint: self.wtr.write_str(\"-\")? is Ok/Some\n",
        "// constraint: self.fmt_literal(&x.end)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= start <= end <= 0x10FFFF\n",
      "answers": [
        {
          "uses": [
            "use ast::Literal;",
            "use ast::ClassSetItem;",
            "use ast::Span;",
            "use ast::LiteralKind;",
            "use ast::ClassSetRange;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                "",
                "    let start_literal = Literal {",
                "        span: Span::default(),",
                "        kind: LiteralKind::Verbatim,",
                "        c: 'a',",
                "    };",
                "    ",
                "    let end_literal = Literal {",
                "        span: Span::default(),",
                "        kind: LiteralKind::Verbatim,",
                "        c: 'z',",
                "    };",
                "    ",
                "    let range = ClassSetRange {",
                "        span: Span::default(),",
                "        start: start_literal,",
                "        end: end_literal,",
                "    };",
                "",
                "    let class_set_item = ClassSetItem::Range(range);",
                "",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    writer.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let start_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'z',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
                ],
                [
                  "    let start_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'z',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert_eq!(output, \"a-z\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                  "",
                  "    let start_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'z',",
                  "    };",
                  "    ",
                  "    let range = ClassSetRange {",
                  "        span: Span::default(),",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let start_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'z',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                  "",
                  "    let start_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'z',",
                  "    };",
                  "    ",
                  "    let range = ClassSetRange {",
                  "        span: Span::default(),",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let start_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    };",
                  "    let end_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'z',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: start_literal,",
                  "    end: end_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert_eq!(output, \"a-z\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:597:21\n    |\n597 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:603:21\n    |\n603 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:609:21\n    |\n609 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:625:17\n    |\n625 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:630:17\n    |\n630 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:635:17\n    |\n635 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:597:21\n    |\n597 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:603:21\n    |\n603 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:609:21\n    |\n609 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:625:17\n    |\n625 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:630:17\n    |\n630 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:635:17\n    |\n635 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                "",
                "    let same_literal = Literal {",
                "        span: Span::default(),",
                "        kind: LiteralKind::Verbatim,",
                "        c: 'm',",
                "    };",
                "    ",
                "    let range = ClassSetRange {",
                "        span: Span::default(),",
                "        start: same_literal.clone(),",
                "        end: same_literal,",
                "    };",
                "",
                "    let class_set_item = ClassSetItem::Range(range);",
                "",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    writer.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let same_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'm',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: same_literal.clone(),",
                  "    end: same_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
                ],
                [
                  "    let same_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'm',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: same_literal.clone(),",
                  "    end: same_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert_eq!(output, \"m-m\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                  "",
                  "    let same_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'm',",
                  "    };",
                  "    ",
                  "    let range = ClassSetRange {",
                  "        span: Span::default(),",
                  "        start: same_literal.clone(),",
                  "        end: same_literal,",
                  "    };",
                  "",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let same_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'm',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: same_literal.clone(),",
                  "    end: same_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                  "",
                  "    let same_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'm',",
                  "    };",
                  "    ",
                  "    let range = ClassSetRange {",
                  "        span: Span::default(),",
                  "        start: same_literal.clone(),",
                  "        end: same_literal,",
                  "    };",
                  "",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let same_literal = Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'm',",
                  "    };",
                  "    let range = ClassSetRange {",
                  "    span: Span::default(),",
                  "    start: same_literal.clone(),",
                  "    end: same_literal,",
                  "    };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    assert_eq!(output, \"m-m\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:597:21\n    |\n597 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:603:21\n    |\n603 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:619:17\n    |\n619 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:624:17\n    |\n624 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:597:21\n    |\n597 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:603:21\n    |\n603 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:619:17\n    |\n619 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:624:17\n    |\n624 |     span: Span::default(),\n    |                 ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                "",
                "    let start_literal = Literal {",
                "        span: Span::default(),",
                "        kind: LiteralKind::Verbatim,",
                "        c: '\\u{0030}', // '0'",
                "    };",
                "    ",
                "    let end_literal = Literal {",
                "        span: Span::default(),",
                "        kind: LiteralKind::Verbatim,",
                "        c: '\\u{0039}', // '9'",
                "    };",
                "    ",
                "    let range = ClassSetRange {",
                "        span: Span::default(),",
                "        start: start_literal,",
                "        end: end_literal,",
                "    };",
                "",
                "    let class_set_item = ClassSetItem::Range(range);",
                "",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    writer.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0030}' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0039}' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0030}' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0039}' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(output, \"0-9\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                  "",
                  "    let start_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{0030}', // '0'",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{0039}', // '9'",
                  "    };",
                  "    ",
                  "    let range = ClassSetRange {",
                  "        span: Span::default(),",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0030}' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0039}' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal, Span, LiteralKind};",
                  "",
                  "    let start_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{0030}', // '0'",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: '\\u{0039}', // '9'",
                  "    };",
                  "    ",
                  "    let range = ClassSetRange {",
                  "        span: Span::default(),",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    };",
                  "",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0030}' };",
                  "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0039}' };",
                  "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
                  "    let class_set_item = ClassSetItem::Range(range);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(output, \"0-9\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:597:21\n    |\n597 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:603:21\n    |\n603 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:609:21\n    |\n609 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:624:47\n    |\n624 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0030}' };\n    |                                               ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:625:45\n    |\n625 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0039}' };\n    |                                             ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:626:45\n    |\n626 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                             ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:597:21\n    |\n597 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:603:21\n    |\n603 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:609:21\n    |\n609 |         span: Span::default(),\n    |                     ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:624:47\n    |\n624 |     let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0030}' };\n    |                                               ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:625:45\n    |\n625 |     let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '\\u{0039}' };\n    |                                             ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:626:45\n    |\n626 |     let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };\n    |                                             ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span};",
                "",
                "    let class_set_item = ClassSetItem::Empty(Span::default());",
                "",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    writer.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });",
                  "    let expected_output = \"a-b\";",
                  "    assert_eq!(output, expected_output);"
                ],
                [
                  "    let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });",
                  "    let expected_output = \"a-b\";",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span};",
                  "",
                  "    let class_set_item = ClassSetItem::Empty(Span::default());",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });",
                  "    let expected_output = \"a-b\";",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span};",
                  "",
                  "    let class_set_item = ClassSetItem::Empty(Span::default());",
                  "",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    writer.visit_class_set_item_post(&class_set_item);",
                  "    let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });",
                  "    let expected_output = \"a-b\";",
                  "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:606:46\n    |\n606 |     let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Literal...\n    |                                              ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:92\n    |\n606 |     let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Literal...\n    |                                                                                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:131\n    |\n606 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:169\n    |\n606 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:208\n    |\n606 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:596:52\n    |\n596 |     let class_set_item = ClassSetItem::Empty(Span::default());\n    |                                                    ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:606:74\n    |\n606 |     let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Literal...\n    |                                                                          ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:606:114\n    |\n606 | ...efault(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: L...\n    |                                           ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:606:191\n    |\n606 | ..., c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });\n    |                                           ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/print.rs:606:46\n    |\n606 |     let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Literal...\n    |                                              ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:92\n    |\n606 |     let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Literal...\n    |                                                                                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:131\n    |\n606 | ...rt: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::V...\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:169\n    |\n606 | ...ult(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:208\n    |\n606 | ...nd: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:596:52\n    |\n596 |     let class_set_item = ClassSetItem::Empty(Span::default());\n    |                                                    ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:606:74\n    |\n606 |     let class_set_item = ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: Literal...\n    |                                                                          ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:606:114\n    |\n606 | ...efault(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: L...\n    |                                           ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `Span` in the current scope\n   --> regex-syntax/src/ast/print.rs:606:191\n    |\n606 | ..., c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' } });\n    |                                           ^^^^^^^ function or associated item not found in `Span`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | --------------- function or associated item `default` not found for this struct\n    |\nnote: if you're trying to build a new `Span` consider using one of the following associated functions:\n      Span::new\n      Span::splat\n   --> regex-syntax/src/ast/mod.rs:396:5\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401 |     pub fn splat(pos: Position) -> Span {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `default`, perhaps you need to implement it:\n            candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: *ast matches Literal(ref x) is true\n",
        "// constraint: *ast matches Literal(ref x) is true\n"
      ],
      "input_infer": "start: 'a', end: 'z'\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut ast_item = ast::ClassSetItem::Literal(ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'a',",
                "    });",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let writer = Printer { _priv: () };",
                  "    let ast_item = ast::ClassSetItem::Literal(ast::Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    });",
                  "    let visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    assert_eq!(visitor.wtr, \"a\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut ast_item = ast::ClassSetItem::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    });",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let writer = Printer { _priv: () };",
                  "    let ast_item = ast::ClassSetItem::Literal(ast::Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    });",
                  "    let visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    assert_eq!(visitor.wtr, \"a\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:15\n    |\n596 |         span: Span { start: 0, end: 1 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:11\n    |\n604 |     span: Span { start: 0, end: 1 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut ast_item = ast::ClassSetItem::Literal(ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'z',",
                "    });",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = \"z\";",
                  "    assert_eq!(visitor.wtr, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut ast_item = ast::ClassSetItem::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'z',",
                  "    });",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let expected_output = \"z\";",
                  "    assert_eq!(visitor.wtr, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:15\n    |\n596 |         span: Span { start: 0, end: 1 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let start_literal = ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'a',",
                "    };",
                "    let end_literal = ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Verbatim,",
                "        c: 'z',",
                "    };",
                "    let mut ast_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: 0, end: 3 },",
                "        start: start_literal,",
                "        end: end_literal,",
                "    });",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let start_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'z' };",
                  "    let ast_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: 0, end: 3 }, start: start_literal, end: end_literal });",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    assert_eq!(visitor.wtr, \"a-z\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let start_literal = ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    let end_literal = ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Verbatim,",
                  "        c: 'z',",
                  "    };",
                  "    let mut ast_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: 0, end: 3 },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let start_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' };",
                  "    let end_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'z' };",
                  "    let ast_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: 0, end: 3 }, start: start_literal, end: end_literal });",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    visitor.visit_class_set_item_post(&ast_item).unwrap();",
                  "    assert_eq!(visitor.wtr, \"a-z\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:15\n    |\n596 |         span: Span { start: 0, end: 1 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:15\n    |\n601 |         span: Span { start: 0, end: 1 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:15\n    |\n606 |         span: Span { start: 0, end: 3 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:46\n    |\n612 |     let start_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' };\n    |                                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:613:44\n    |\n613 |     let end_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'z' };\n    |                                            ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:614:72\n    |\n614 |     let ast_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: 0, end: 3 }, start: start_literal, end: end_literal });\n    |                                                                        ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: *ast matches Empty(_) is true\n",
        "// constraint: *ast matches Empty(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "test input ranges: ast::ClassSetItem::Empty(Span::new(0, 0)), ast::ClassSetItem::Empty(Span::new(1, 1)), ast::ClassSetItem::Empty(Span::new(100, 100)), ast::ClassSetItem::Empty(Span::new(usize::MAX, usize::MAX))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 0);",
                "    let ast = ast::ClassSetItem::Empty(span);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                "    visitor.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let span = Span::new(0, 0);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let span = Span::new(0, 0);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1);",
                "    let ast = ast::ClassSetItem::Empty(span);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                "    visitor.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 1);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.unwrap(), ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let span = Span::new(1, 1);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let span = Span::new(1, 1);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.unwrap(), ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(100, 100);",
                "    let ast = ast::ClassSetItem::Empty(span);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                "    visitor.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(100, 100);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(100, 100);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let span = Span::new(100, 100);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(100, 100);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(100, 100);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(usize::MAX, usize::MAX);",
                "    let ast = ast::ClassSetItem::Empty(span);",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                "    visitor.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(usize::MAX, usize::MAX);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    assert_eq!(visitor.visit_class_set_item_post(&ast).unwrap(), ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(usize::MAX, usize::MAX);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let span = Span::new(usize::MAX, usize::MAX);",
                  "    let ast = ast::ClassSetItem::Empty(span);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };",
                  "    assert_eq!(visitor.visit_class_set_item_post(&ast).unwrap(), ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(usize::MAX, usize::MAX);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(usize::MAX, usize::MAX);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:597:59\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n597 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:602:59\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new() };\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n602 |     let mut visitor = Writer { printer: &mut writer, wtr: std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */) };\n    |                                                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}