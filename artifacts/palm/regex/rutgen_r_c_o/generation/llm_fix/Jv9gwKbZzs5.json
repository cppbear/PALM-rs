{
  "name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::pop_class_op",
  "name_with_impl": "regex_syntax::ast::parse::{impl#4}::pop_class_op",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:21:1:21:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:949:5:966:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: stack.pop() matches Some(state @ ClassState::Open { .. }) or Some(ClassState::Op { kind, lhs }) is true\n",
        "// constraint: stack.pop() matches Some(state @ ClassState::Open { .. }) or Some(ClassState::Op { kind, lhs }) is true\n",
        "// constraint: stack.pop() matches Some(ClassState::Op { kind, lhs }) is true\n",
        "// expected return value/type: ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span: span,\n            kind: kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n"
      ],
      "input_infer": "0 <= stack.length <= 10, 0 <= rhs.lhs.count <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                "    let span = Span::new(position_start, position_end);",
                "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                "    let mut parser = Parser {",
                "        stack_class: RefCell::new(vec![ClassState::Open {",
                "            union: ast::ClassSetUnion::default(),",
                "            set: ast::ClassBracketed::new(),",
                "        }]),",
                "        // Other fields initialized as needed...",
                "    };",
                "    ",
                "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                "    ",
                "    parser.pop_class_op(rhs);",
                "}"
              ],
              "oracles": [
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs },",
                  "    ]),",
                  "    };",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(rhs);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));"
                ],
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs },",
                  "    ]),",
                  "    };",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(rhs);",
                  "    assert!(if let ClassSet::BinaryOp(ref op) = result {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![ClassState::Open {",
                  "            union: ast::ClassSetUnion::default(),",
                  "            set: ast::ClassBracketed::new(),",
                  "        }]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs },",
                  "    ]),",
                  "    };",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(rhs);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![ClassState::Open {",
                  "            union: ast::ClassSetUnion::default(),",
                  "            set: ast::ClassBracketed::new(),",
                  "        }]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs },",
                  "    ]),",
                  "    };",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(rhs);",
                  "    assert!(if let ClassSet::BinaryOp(ref op) = result {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:15\n     |\n5379 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5379 |     let lhs = ClassSet::Item(ClassState::new(span.clone()));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5388:15\n     |\n5388 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5388 |     let rhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5394:15\n     |\n5394 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5394 |     let lhs = ClassSet::Item(ClassState::new(span.clone()));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5397:28\n     |\n5397 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5400:15\n     |\n5400 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5400 |     let rhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     assert!(matches!(result, ClassSet::BinaryOp(_)));\n     |                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:40\n     |\n5382 |             union: ast::ClassSetUnion::default(),\n     |                                        ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:39\n     |\n5383 |             set: ast::ClassBracketed::new(),\n     |                                       ^^^ function or associated item not found in `ClassBracketed`\n     |\n    ::: regex-syntax/src/ast/mod.rs:912:1\n     |\n912  | pub struct ClassBracketed {\n     | ------------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:22\n     |\n5380 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5390 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:22\n     |\n5395 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5401:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5401 |     let result = parser.pop_class_op(rhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n    --> regex-syntax/src/ast/parse.rs:5402:12\n     |\n5375 | {\n     | - closing delimiter possibly meant for this\n...\n5402 |     assert!(if let ClassSet::BinaryOp(ref op) = result {\n     |            ^ unclosed delimiter\n5403 | }\n5404 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5404:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5404 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                "    let span = Span::new(position_start, position_end);",
                "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                "    let mut parser = Parser {",
                "        stack_class: RefCell::new(vec![ClassState::Op {",
                "            kind: ClassSetBinaryOpKind::Intersection,",
                "            lhs: lhs.clone(),",
                "        }]),",
                "        // Other fields initialized as needed...",
                "    };",
                "    ",
                "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                "    ",
                "    parser.pop_class_op(rhs);",
                "}"
              ],
              "oracles": [
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs.clone(), }]), };",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(rhs);",
                  "    let expected = ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp { span: span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs), });",
                  "    assert_eq!(result, expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![ClassState::Op {",
                  "            kind: ClassSetBinaryOpKind::Intersection,",
                  "            lhs: lhs.clone(),",
                  "        }]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs.clone(), }]), };",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(rhs);",
                  "    let expected = ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp { span: span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs), });",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:15\n     |\n5379 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5379:30\n     |\n5379 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5379 |     let lhs = ClassSet::Item(ClassState::new(span.clone()));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5382:19\n     |\n5382 |             kind: ClassSetBinaryOpKind::Intersection,\n     |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5388:15\n     |\n5388 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5388 |     let rhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5394:15\n     |\n5394 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |     let lhs = ClassSet::Item(ClassSetItem::new(span.clone()));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5394 |     let lhs = ClassSet::Item(ClassState::new(span.clone()));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5395:85\n     |\n5395 | ...::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs.clone(), }]), };\n     |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:15\n     |\n5396 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5396:30\n     |\n5396 |     let rhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5396 |     let rhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5398:86\n     |\n5398 | ...ssSetBinaryOp { span: span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs), });\n     |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5380:22\n     |\n5380 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5390 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5395:22\n     |\n5395 |     let mut parser = Parser { stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs.clone(),...\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5397 |     let result = parser.pop_class_op(rhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                "    let span_lhs = Span::new(position_start, position_end);",
                "    ",
                "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                "    let mut parser = Parser {",
                "        stack_class: RefCell::new(vec![",
                "            ClassState::Open {",
                "                union: ast::ClassSetUnion::default(),",
                "                set: ast::ClassBracketed::new(),",
                "            },",
                "            ClassState::Op {",
                "                kind: ClassSetBinaryOpKind::Difference,",
                "                lhs: lhs.clone(),",
                "            }",
                "        ]),",
                "        // Other fields initialized as needed...",
                "    };",
                "    ",
                "    parser.pop_class_op(rhs);",
                "}"
              ],
              "oracles": [
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    assert!(matches!(result, ast::ClassSet::BinaryOp(_)));"
                ],
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.kind, ClassSetBinaryOpKind::Difference);"
                ],
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.lhs.as_ref(), &lhs);"
                ],
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.rhs.as_ref(), &rhs);"
                ],
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.span.start, span_lhs.start);"
                ],
                [
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.span.end, span_lhs.end);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    ",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion::default(),",
                  "                set: ast::ClassBracketed::new(),",
                  "            },",
                  "            ClassState::Op {",
                  "                kind: ClassSetBinaryOpKind::Difference,",
                  "                lhs: lhs.clone(),",
                  "            }",
                  "        ]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    assert!(matches!(result, ast::ClassSet::BinaryOp(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    ",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion::default(),",
                  "                set: ast::ClassBracketed::new(),",
                  "            },",
                  "            ClassState::Op {",
                  "                kind: ClassSetBinaryOpKind::Difference,",
                  "                lhs: lhs.clone(),",
                  "            }",
                  "        ]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.kind, ClassSetBinaryOpKind::Difference);",
                  "}"
                ],
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    ",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion::default(),",
                  "                set: ast::ClassBracketed::new(),",
                  "            },",
                  "            ClassState::Op {",
                  "                kind: ClassSetBinaryOpKind::Difference,",
                  "                lhs: lhs.clone(),",
                  "            }",
                  "        ]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.lhs.as_ref(), &lhs);",
                  "}"
                ],
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    ",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion::default(),",
                  "                set: ast::ClassBracketed::new(),",
                  "            },",
                  "            ClassState::Op {",
                  "                kind: ClassSetBinaryOpKind::Difference,",
                  "                lhs: lhs.clone(),",
                  "            }",
                  "        ]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.rhs.as_ref(), &rhs);",
                  "}"
                ],
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    ",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion::default(),",
                  "                set: ast::ClassBracketed::new(),",
                  "            },",
                  "            ClassState::Op {",
                  "                kind: ClassSetBinaryOpKind::Difference,",
                  "                lhs: lhs.clone(),",
                  "            }",
                  "        ]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.span.start, span_lhs.start);",
                  "}"
                ],
                [
                  "{",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    ",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion::default(),",
                  "                set: ast::ClassBracketed::new(),",
                  "            },",
                  "            ClassState::Op {",
                  "                kind: ClassSetBinaryOpKind::Difference,",
                  "                lhs: lhs.clone(),",
                  "            }",
                  "        ]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let position_start = Position { offset: 0, line: 1, column: 1 };",
                  "    let position_end = Position { offset: 5, line: 1, column: 6 };",
                  "    let span_lhs = Span::new(position_start, position_end);",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));",
                  "    let mut parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion::default(),",
                  "    set: ast::ClassBracketed::new(),",
                  "    },",
                  "    ClassState::Op {",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: lhs.clone(),",
                  "    }",
                  "    ]),",
                  "    };",
                  "    let result = parser.pop_class_op(rhs);",
                  "    if let ast::ClassSet::BinaryOp(ref binary_op) = result {",
                  "    assert_eq!(binary_op.span.end, span_lhs.end);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5380:15\n     |\n5380 |     let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5380:30\n     |\n5380 |     let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5380 |     let lhs = ClassSet::Item(ClassState::new(span_lhs));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5381:15\n     |\n5381 |     let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5381:30\n     |\n5381 |     let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5381 |     let rhs = ClassSet::Item(ClassState::new(span_lhs));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5389:23\n     |\n5389 |                 kind: ClassSetBinaryOpKind::Difference,\n     |                       ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5400:15\n     |\n5400 |     let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5400:30\n     |\n5400 |     let lhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5400 |     let lhs = ClassSet::Item(ClassState::new(span_lhs));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5401:15\n     |\n5401 |     let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5401:30\n     |\n5401 |     let rhs = ClassSet::Item(ClassSetItem::new(span_lhs));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5401 |     let rhs = ClassSet::Item(ClassState::new(span_lhs));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5409:11\n     |\n5409 |     kind: ClassSetBinaryOpKind::Difference,\n     |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:44\n     |\n5385 |                 union: ast::ClassSetUnion::default(),\n     |                                            ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:43\n     |\n5386 |                 set: ast::ClassBracketed::new(),\n     |                                           ^^^ function or associated item not found in `ClassBracketed`\n     |\n    ::: regex-syntax/src/ast/mod.rs:912:1\n     |\n912  | pub struct ClassBracketed {\n     | ------------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5382:22\n     |\n5382 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5396:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5396 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5405:32\n     |\n5405 |     union: ast::ClassSetUnion::default(),\n     |                                ^^^^^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5406:31\n     |\n5406 |     set: ast::ClassBracketed::new(),\n     |                               ^^^ function or associated item not found in `ClassBracketed`\n     |\n    ::: regex-syntax/src/ast/mod.rs:912:1\n     |\n912  | pub struct ClassBracketed {\n     | ------------------------- function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5402:22\n     |\n5402 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5414:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5414 |     let result = parser.pop_class_op(rhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5418:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5418 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5418:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5418 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5418:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5418 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5418:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5418 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/ast/parse.rs:5418:3\n     |\n5367 | mod llmtests {\n     |              - unclosed delimiter\n...\n5418 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                "    let mut parser = Parser {",
                "        stack_class: RefCell::new(vec![]),",
                "        // Other fields initialized as needed...",
                "    };",
                "    ",
                "    parser.pop_class_op(rhs);",
                "}"
              ],
              "oracles": [
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    assert!(parser.stack_class.borrow().is_empty());"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    assert!(std::panic::catch_unwind(|| parser.pop_class_op(rhs)).is_err());"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    assert_eq!(parser.stack_class.borrow().len(), 0);"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert_eq!(result.span(), &span);"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert_eq!(result.lhs, Box::new(lhs));"
                ],
                [
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert_eq!(result.rhs, Box::new(rhs));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    assert!(parser.stack_class.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    assert!(std::panic::catch_unwind(|| parser.pop_class_op(rhs)).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert_eq!(result.span(), &span);",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert_eq!(result.lhs, Box::new(lhs));",
                  "}"
                ],
                [
                  "{",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser {",
                  "        stack_class: RefCell::new(vec![]),",
                  "        // Other fields initialized as needed...",
                  "    };",
                  "    ",
                  "    parser.pop_class_op(rhs);",
                  "    let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));",
                  "    let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };",
                  "    parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });",
                  "    let result = parser.pop_class_op(rhs.clone());",
                  "    let span = Span::new(Position::default(), Position::default());",
                  "    let lhs = ClassSet::Item(ClassSetItem::new(span));",
                  "    let result = parser.pop_class_op(lhs);",
                  "    assert_eq!(result.rhs, Box::new(rhs));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:48\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5386 |     assert!(std::panic::catch_unwind(|| parser.pop_class_op(rhs)).is_err());\n     |                                                ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5388:30\n     |\n5388 |     assert!(matches!(result, ClassSet::BinaryOp(_)));\n     |                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5387 |     let result = parser.pop_class_op(rhs.clone());\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5387 |     let result = parser.pop_class_op(rhs.clone());\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5389:30\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5389 |     let lhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5387 |     let result = parser.pop_class_op(rhs.clone());\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                    ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:57\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                                         ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5390 |     let result = parser.pop_class_op(lhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5389:30\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5389 |     let lhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     assert!(matches!(result, ClassSet::BinaryOp(_)));\n     |                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5387 |     let result = parser.pop_class_op(rhs.clone());\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                    ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:57\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                                         ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5390 |     let result = parser.pop_class_op(lhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5389:30\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5389 |     let lhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5387 |     let result = parser.pop_class_op(rhs.clone());\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                    ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:57\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                                         ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5390 |     let result = parser.pop_class_op(lhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5377:15\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5377:30\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5377 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5384:15\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5384:30\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5384 |     let rhs = ClassSet::Item(ClassState::new(Span::splat(Position::default())));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5386:65\n     |\n5386 |     parser.stack_class.borrow_mut().push(ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: rhs.clone() });\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:15\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n    --> regex-syntax/src/ast/parse.rs:5389:30\n     |\n5389 |     let lhs = ClassSet::Item(ClassSetItem::new(span));\n     |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n     |\nhelp: an enum with a similar name exists\n     |\n5389 |     let lhs = ClassSet::Item(ClassState::new(span));\n     |                              ~~~~~~~~~~\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetItem;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5377:70\n     |\n5377 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5378:22\n     |\n5378 |     let mut parser = Parser {\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5383:12\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5383 |     parser.pop_class_op(rhs);\n     |            ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let rhs = ClassSet::Item(ClassSetItem::new(Span::splat(Position::default())));\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `capture_index`, `capture_names`, `comments` and 7 other fields in initializer of `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |     let mut parser = Parser { stack_class: RefCell::new(vec![]), /* Other fields initialized as needed... */ };\n     |                      ^^^^^^ missing `capture_index`, `capture_names`, `comments` and 7 other fields\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5387:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5387 |     let result = parser.pop_class_op(rhs.clone());\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:36\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                    ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:57\n     |\n5388 |     let span = Span::new(Position::default(), Position::default());\n     |                                                         ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `pop_class_op` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5390:25\n     |\n233  | pub struct Parser {\n     | ----------------- method `pop_class_op` not found for this struct\n...\n5390 |     let result = parser.pop_class_op(lhs);\n     |                         ^^^^^^^^^^^^ method not found in `Parser`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: stack.pop() matches Some(state @ ClassState::Open { .. }) or Some(ClassState::Op { kind, lhs }) is true\n",
        "// constraint: stack.pop() matches None is true\n",
        "// constraint: stack.pop() matches Some(state @ ClassState::Open { .. }) is true\n",
        "// expected return value/type: rhs\n"
      ],
      "input_infer": "0 <= stack size <= 1, rhs must be of type ast::ClassSet\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                "    ",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(Vec::new()),",
                "        ..Parser::default()",
                "    };",
                "    ",
                "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                "    let result = parser_instance.pop_class_op(class_set);",
                "}"
              ],
              "oracles": [
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    assert_eq!(result, class_set);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_eq!(result, class_set);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_ne!(result, class_set);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_eq!(result, class_set);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Difference, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_ne!(result, class_set);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(Vec::new()),",
                  "        ..Parser::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::new()  ",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    assert_eq!(result, class_set);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(Vec::new()),",
                  "        ..Parser::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_eq!(result, class_set);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(Vec::new()),",
                  "        ..Parser::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_ne!(result, class_set);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(Vec::new()),",
                  "        ..Parser::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),",
                  "    ..Parser::new()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_eq!(result, class_set);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    ",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(Vec::new()),",
                  "        ..Parser::default()",
                  "    };",
                  "    ",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::new()  ",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(Vec::new()),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Difference, lhs: class_set.clone() }]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(class_set);",
                  "    assert_ne!(result, class_set);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:21\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:21\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:37\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5382 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5389:37\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:21\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:21\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:37\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5382 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5389:37\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5392 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                              ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5396:90\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                                                          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:21\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:21\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5402:59\n     |\n5402 |     stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),\n     |                                                           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:37\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5382 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5389:37\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5392 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                              ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5396:90\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                                                          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5403 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:21\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:21\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5402:59\n     |\n5402 |     stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),\n     |                                                           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:37\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5382 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5389:37\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5392:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5392 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                              ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5396:90\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                                                          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5409:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5409 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:21\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5389:21\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                     ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5402:59\n     |\n5402 |     stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: class_set.clone() }]),\n     |                                                           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5414:59\n     |\n5414 |     stack_class: RefCell::new(vec![ClassState::Op { kind: ClassSetBinaryOpKind::Difference, lhs: class_set.clone() }]),\n     |                                                           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:37\n     |\n5378 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5382 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5389:37\n     |\n5389 |     let class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                     ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:62\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                              ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5396:90\n     |\n5396 |     stack_class: RefCell::new(vec![ClassState::Open { union: ast::ClassSetUnion {}, set: ast::ClassBracketed {} }]),\n     |                                                                                          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5397:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5397 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5403:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5403 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5409:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5409 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5415 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                "",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![",
                "            ClassState::Open {",
                "                union: ast::ClassSetUnion {},",
                "                set: ast::ClassBracketed {},",
                "            }",
                "        ]),",
                "        ..Parser::default()",
                "    };",
                "",
                "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                "    let result = parser_instance.pop_class_op(rhs_class_set);",
                "}"
              ],
              "oracles": [
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result, rhs_class_set);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op {",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: lhs_class_set.clone(),",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.span(), &Span::new(lhs_class_set.span().start, rhs_class_set.span().end));"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op {",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: lhs_class_set.clone(),",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op {",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: lhs_class_set.clone(),",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(matches!(result, ClassSet::Item(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion {},",
                  "                set: ast::ClassBracketed {},",
                  "            }",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result, rhs_class_set);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion {},",
                  "                set: ast::ClassBracketed {},",
                  "            }",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op {",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: lhs_class_set.clone(),",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.span(), &Span::new(lhs_class_set.span().start, rhs_class_set.span().end));",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion {},",
                  "                set: ast::ClassBracketed {},",
                  "            }",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op {",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: lhs_class_set.clone(),",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Open {",
                  "                union: ast::ClassSetUnion {},",
                  "                set: ast::ClassBracketed {},",
                  "            }",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Open {",
                  "    union: ast::ClassSetUnion {},",
                  "    set: ast::ClassBracketed {},",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op {",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: lhs_class_set.clone(),",
                  "    }",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(matches!(result, ClassSet::Item(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5395:25\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:25\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |                 union: ast::ClassSetUnion {},\n     |                        ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |                 set: ast::ClassBracketed {},\n     |                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5388 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5395:41\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:41\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5400:12\n     |\n5400 |     union: ast::ClassSetUnion {},\n     |            ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5401:10\n     |\n5401 |     set: ast::ClassBracketed {},\n     |          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5404 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5395:25\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:25\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |                 union: ast::ClassSetUnion {},\n     |                        ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |                 set: ast::ClassBracketed {},\n     |                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5388 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5395:41\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:41\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5400:12\n     |\n5400 |     union: ast::ClassSetUnion {},\n     |            ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5401:10\n     |\n5401 |     set: ast::ClassBracketed {},\n     |          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5404 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5415 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5395:25\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:25\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5419:30\n     |\n5419 |     assert!(matches!(result, ClassSet::BinaryOp(_)));\n     |                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |                 union: ast::ClassSetUnion {},\n     |                        ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |                 set: ast::ClassBracketed {},\n     |                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5388 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5395:41\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:41\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5400:12\n     |\n5400 |     union: ast::ClassSetUnion {},\n     |            ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5401:10\n     |\n5401 |     set: ast::ClassBracketed {},\n     |          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5404 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5415 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5395:25\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5396:25\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5425:30\n     |\n5425 |     assert!(matches!(result, ClassSet::Item(_)));\n     |                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5384:24\n     |\n5384 |                 union: ast::ClassSetUnion {},\n     |                        ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5385:22\n     |\n5385 |                 set: ast::ClassBracketed {},\n     |                      ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5388 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5395:41\n     |\n5395 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5396:41\n     |\n5396 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5400:12\n     |\n5400 |     union: ast::ClassSetUnion {},\n     |            ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `kind`, `negated` and `span` in initializer of `ClassBracketed`\n    --> regex-syntax/src/ast/parse.rs:5401:10\n     |\n5401 |     set: ast::ClassBracketed {},\n     |          ^^^^^^^^^^^^^^^^^^^ missing `kind`, `negated` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5404:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5404 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5415:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5415 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5421:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5421 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                "",
                "    let parser = Parser {",
                "        stack_class: RefCell::new(vec![",
                "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                "        ]),",
                "        ..Parser::default()",
                "    };",
                "",
                "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                "    let result = parser_instance.pop_class_op(rhs_class_set);",
                "}"
              ],
              "oracles": [
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.span().start, span.start);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.span().end, span.end);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.kind(), ClassSetBinaryOpKind::Intersection);"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(result.lhs().is_equal(lhs_class_set));"
                ],
                [
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(result.rhs().is_equal(rhs_class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(matches!(result, ClassSet::BinaryOp(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.span().start, span.start);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.span().end, span.end);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert_eq!(result.kind(), ClassSetBinaryOpKind::Intersection);",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(result.lhs().is_equal(lhs_class_set));",
                  "}"
                ],
                [
                  "{",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "",
                  "    let parser = Parser {",
                  "        stack_class: RefCell::new(vec![",
                  "            ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "        ]),",
                  "        ..Parser::default()",
                  "    };",
                  "",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    let position = Position { offset: 0, line: 1, column: 1 };",
                  "    let span = Span::new(position, position);",
                  "    let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});",
                  "    let parser = Parser {",
                  "    stack_class: RefCell::new(vec![",
                  "    ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },",
                  "    ]),",
                  "    ..Parser::default()",
                  "    };",
                  "    let parser_instance = ParserI::new(&parser, \"test_pattern\");",
                  "    let result = parser_instance.pop_class_op(rhs_class_set);",
                  "    assert!(result.rhs().is_equal(rhs_class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5383:36\n     |\n5383 |             ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5392:25\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5396:28\n     |\n5396 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5402:30\n     |\n5402 |     assert!(matches!(result, ClassSet::BinaryOp(_)));\n     |                              ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5385 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5392:41\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5393:41\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5398 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5383:36\n     |\n5383 |             ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5396:28\n     |\n5396 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5385 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5393:41\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5398 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5383:36\n     |\n5383 |             ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5392:25\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5396:28\n     |\n5396 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5385 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5392:41\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5393:41\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5398 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5383:36\n     |\n5383 |             ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5392:25\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5396:28\n     |\n5396 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5402:31\n     |\n5402 |     assert_eq!(result.kind(), ClassSetBinaryOpKind::Intersection);\n     |                               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5385 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5392:41\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5393:41\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5398 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `kind` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:23\n     |\n5402 |     assert_eq!(result.kind(), ClassSetBinaryOpKind::Intersection);\n     |                       ^^^^ method not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- method `kind` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5383:36\n     |\n5383 |             ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5392:25\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5396:28\n     |\n5396 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5385 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5392:41\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5393:41\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5398 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `lhs` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:20\n     |\n5402 |     assert!(result.lhs().is_equal(lhs_class_set));\n     |                    ^^^ method not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- method `lhs` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5378:25\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5379:25\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5383:36\n     |\n5383 |             ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5392:25\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/ast/parse.rs:5393:25\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                         ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n    --> regex-syntax/src/ast/parse.rs:5396:28\n     |\n5396 |     ClassState::Op { kind: ClassSetBinaryOpKind::Intersection, lhs: lhs_class_set },\n     |                            ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassSetBinaryOpKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5378:41\n     |\n5378 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5379:41\n     |\n5379 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5385:19\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5385 |         ..Parser::default()\n     |                   ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5392:41\n     |\n5392 |     let lhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0063]: missing fields `items` and `span` in initializer of `ClassSetUnion`\n    --> regex-syntax/src/ast/parse.rs:5393:41\n     |\n5393 |     let rhs_class_set = ClassSet::union(ast::ClassSetUnion {});\n     |                                         ^^^^^^^^^^^^^^^^^^ missing `items` and `span`\n\nerror[E0599]: no function or associated item named `default` found for struct `parse::Parser` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5398:15\n     |\n233  | pub struct Parser {\n     | ----------------- function or associated item `default` not found for this struct\n...\n5398 |     ..Parser::default()\n     |               ^^^^^^^ function or associated item not found in `Parser`\n     |\nnote: if you're trying to build a new `parse::Parser`, consider using `parse::Parser::new` which returns `parse::Parser`\n    --> regex-syntax/src/ast/parse.rs:339:5\n     |\n339  |     pub fn new() -> Parser {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `rhs` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5402:20\n     |\n5402 |     assert!(result.rhs().is_equal(rhs_class_set));\n     |                    ^^^ method not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- method `rhs` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}