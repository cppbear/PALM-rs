{
  "name": "regex_syntax::hir::print::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post",
  "name_with_impl": "regex_syntax::hir::print::{impl#3}::visit_post",
  "mod_info": {
    "name": "hir::print",
    "loc": "regex-syntax/src/hir/mod.rs:28:1:28:15"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/print.rs:169:5:213:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Alternation(_) is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "HirKind::Alternation(Vec<Hir>), HirKind::Anchor(Anchor), HirKind::Empty, HirKind::Class(Class), HirKind::Literal(Literal), HirKind::Concat(Vec<Hir>), HirKind::WordBoundary(WordBoundary)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                "    writer.visit_post(&alt_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    assert_eq!(writer.visit_post(&alt_hir), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    writer.visit_post(&alt_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    assert_eq!(writer.visit_post(&alt_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    writer.visit_post(&alt_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:54\n    |\n374 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:88\n    |\n374 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:54\n    |\n379 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:88\n    |\n379 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:54\n    |\n374 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:88\n    |\n374 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:54\n    |\n379 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:88\n    |\n379 |     let alt_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let empty_hir = Hir::empty();",
                "    writer.visit_post(&empty_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&empty_hir), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&empty_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `writer` as mutable, as it is not declared as mutable\n   --> regex-syntax/src/hir/print.rs:375:5\n    |\n375 |     writer.visit_post(&empty_hir);\n    |     ^^^^^^ cannot borrow as mutable\n    |\nhelp: consider changing this to be mutable\n    |\n372 |     let mut writer = Writer { printer: &mut printer, wtr: &mut output };\n    |         +++\n\nerror[E0596]: cannot borrow `writer` as mutable, as it is not declared as mutable\n   --> regex-syntax/src/hir/print.rs:380:16\n    |\n380 |     assert_eq!(writer.visit_post(&empty_hir), Ok(()));\n    |                ^^^^^^ cannot borrow as mutable\n    |\nhelp: consider changing this to be mutable\n    |\n378 |     let mut writer = Writer { printer: &mut printer, wtr: &mut output };\n    |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `writer`\n   --> regex-syntax/src/hir/print.rs:378:9\n    |\n378 |     let writer = Writer { printer: &mut printer, wtr: &mut output };\n    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_writer`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `empty_hir`\n   --> regex-syntax/src/hir/print.rs:379:9\n    |\n379 |     let empty_hir = Hir::empty();\n    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_empty_hir`\n\nerror[E0596]: cannot borrow `writer` as mutable, as it is not declared as mutable\n   --> regex-syntax/src/hir/print.rs:375:5\n    |\n375 |     writer.visit_post(&empty_hir);\n    |     ^^^^^^ cannot borrow as mutable\n    |\nhelp: consider changing this to be mutable\n    |\n372 |     let mut writer = Writer { printer: &mut printer, wtr: &mut output };\n    |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 19 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let anchor_hir = Hir::anchor(Anchor::new());",
                "    writer.visit_post(&anchor_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    assert_eq!(writer.visit_post(&anchor_hir), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    assert!(output.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    assert_eq!(writer.visit_post(&anchor_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    assert!(output.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:34\n    |\n374 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:379:34\n    |\n379 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:34\n    |\n374 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:379:34\n    |\n379 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let class_hir = Hir::class(Class::new());",
                "    writer.visit_post(&class_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).expect(\"visit_post should return Ok(())\");",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    writer.visit_post(&concat_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).expect(\"visit_post should return Ok(())\");",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    writer.visit_post(&concat_hir).expect(\"visit_post should return Ok(())\");",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    writer.visit_post(&alternation_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).expect(\"visit_post should return Ok(())\");",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    writer.visit_post(&concat_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let class_hir = Hir::class(Class::new());",
                  "    writer.visit_post(&class_hir).expect(\"visit_post should return Ok(())\");",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).expect(\"visit_post should return Ok(())\");",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    writer.visit_post(&literal_hir).expect(\"visit_post should return Ok(())\");",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&anchor_hir).expect(\"visit_post should return Ok(())\");",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).expect(\"visit_post should return Ok(())\");",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    writer.visit_post(&concat_hir).expect(\"visit_post should return Ok(())\");",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    writer.visit_post(&alternation_hir).expect(\"visit_post should return Ok(())\");",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:36\n    |\n383 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:36\n    |\n383 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:385:34\n    |\n385 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:36\n    |\n383 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:385:34\n    |\n385 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:387:48\n    |\n387 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:36\n    |\n383 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:385:34\n    |\n385 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:387:48\n    |\n387 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:52\n    |\n389 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:85\n    |\n389 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:32\n    |\n374 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:36\n    |\n383 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:385:34\n    |\n385 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:387:48\n    |\n387 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:52\n    |\n389 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:85\n    |\n389 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:391:62\n    |\n391 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:391:95\n    |\n391 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let literal_hir = Hir::literal(Literal::from('c'));",
                "    writer.visit_post(&literal_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let literal_hir = Hir::literal(Literal::from('c'));",
                  "    writer.visit_post(&literal_hir).unwrap();",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let literal_hir = Hir::literal(Literal::from('c'));",
                  "    writer.visit_post(&literal_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let literal_hir = Hir::literal(Literal::from('c'));",
                  "    writer.visit_post(&literal_hir).unwrap();",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:36\n    |\n374 |     let literal_hir = Hir::literal(Literal::from('c'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:36\n    |\n379 |     let literal_hir = Hir::literal(Literal::from('c'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);",
                "    writer.visit_post(&concat_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);",
                  "    writer.visit_post(&concat_hir);",
                  "    assert_eq!(output, \"de\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);",
                  "    writer.visit_post(&concat_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);",
                  "    writer.visit_post(&concat_hir);",
                  "    assert_eq!(output, \"de\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:52\n    |\n374 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:86\n    |\n374 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:52\n    |\n379 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:379:86\n    |\n379 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('d')), Hir::literal(Literal::from('e'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                "    writer.visit_post(&word_boundary_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).unwrap();",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&word_boundary_hir).unwrap();",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:374:48\n    |\n374 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:379:48\n    |\n379 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Concat(_) is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "HirKind::Concat(Vec<Hir>), HirKind::Anchor(Anchor), HirKind::Alternation(Vec<Hir>), HirKind::Empty, HirKind::Class(Class), HirKind::Literal(Literal), HirKind::WordBoundary(WordBoundary)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                "    let hir = Hir::concat(exprs);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                  "    let hir = Hir::concat(exprs);",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                  "    let hir = Hir::concat(exprs);",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                  "    let hir = Hir::concat(exprs);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                  "    let hir = Hir::concat(exprs);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                  "    let hir = Hir::concat(exprs);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::class(Class)];",
                  "    let hir = Hir::concat(exprs);",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:372:56\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:35\n    |\n377 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:377:56\n    |\n377 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:372:56\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:35\n    |\n377 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:377:56\n    |\n377 |     let exprs = vec![Hir::literal(Literal), Hir::class(Class)];\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let anchor = Anchor;",
                "    let hir = Hir::anchor(anchor);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:372:18\n    |\n372 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:377:18\n    |\n377 |     let anchor = Anchor;\n    |                  ^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let anchor = anchor;\n    |                  ~~~~~~\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                "    let hir = Hir::alternation(exprs);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                  "    let hir = Hir::alternation(exprs);",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                  "    let hir = Hir::alternation(exprs);",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                  "    let hir = Hir::alternation(exprs);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                  "    let hir = Hir::alternation(exprs);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                  "    let hir = Hir::alternation(exprs);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];",
                  "    let hir = Hir::alternation(exprs);",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:64\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                                                ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:375:64\n    |\n375 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                                                ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:64\n    |\n372 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                                                ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:375:64\n    |\n375 |     let exprs = vec![Hir::literal(Literal), Hir::word_boundary(WordBoundary)];\n    |                                                                ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let hir = Hir::empty();",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:28\n    |\n378 |     let hir = Hir::literal(Literal::new('a'));\n    |                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:28\n    |\n378 |     let hir = Hir::literal(Literal::new('a'));\n    |                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:380:26\n    |\n380 |     let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:28\n    |\n378 |     let hir = Hir::literal(Literal::new('a'));\n    |                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:380:26\n    |\n380 |     let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:382:27\n    |\n382 |     let hir = Hir::anchor(Anchor::new());\n    |                           ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:28\n    |\n378 |     let hir = Hir::literal(Literal::new('a'));\n    |                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:380:26\n    |\n380 |     let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:382:27\n    |\n382 |     let hir = Hir::anchor(Anchor::new());\n    |                           ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:384:34\n    |\n384 |     let hir = Hir::word_boundary(WordBoundary::new());\n    |                                  ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:28\n    |\n378 |     let hir = Hir::literal(Literal::new('a'));\n    |                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:380:26\n    |\n380 |     let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:382:27\n    |\n382 |     let hir = Hir::anchor(Anchor::new());\n    |                           ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:384:34\n    |\n384 |     let hir = Hir::word_boundary(WordBoundary::new());\n    |                                  ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:45\n    |\n386 |     let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:78\n    |\n386 |     let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:28\n    |\n378 |     let hir = Hir::literal(Literal::new('a'));\n    |                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:380:26\n    |\n380 |     let hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:382:27\n    |\n382 |     let hir = Hir::anchor(Anchor::new());\n    |                           ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:384:34\n    |\n384 |     let hir = Hir::word_boundary(WordBoundary::new());\n    |                                  ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:45\n    |\n386 |     let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:78\n    |\n386 |     let hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:388:50\n    |\n388 |     let hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:388:83\n    |\n388 |     let hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class = Class;",
                "    let hir = Hir::class(class);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:377:17\n    |\n377 |     let class = Class;\n    |                 ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n377 |     let class = class;\n    |                 ~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let literal = Literal;",
                "    let hir = Hir::literal(literal);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \")\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"*\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"*?\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&bounded_repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"{1,3}\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&bounded_repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&at_least_repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"{2,}?\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&bounded_repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&at_least_repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exactly_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(4)), greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&exactly_repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"{4}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"*?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&bounded_repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"{1,3}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(literal)) });",
                  "    writer.visit_post(&bounded_repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(literal)) });",
                  "    writer.visit_post(&at_least_repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"{2,}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal;",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class;",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor;",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group_hir = Hir::group(Group);",
                  "    writer.visit_post(&group_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);",
                  "    writer.visit_post(&concat_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&repetition_non_greedy_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&bounded_repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(Literal)) });",
                  "    writer.visit_post(&at_least_repetition_hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let exactly_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(4)), greedy: true, hir: Box::new(Hir::literal(literal)) });",
                  "    writer.visit_post(&exactly_repetition_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"{4}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:405:52\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);\n    |                                                    ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(literal)]);\n    |                                                    ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:405:52\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);\n    |                                                    ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(literal)]);\n    |                                                    ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:42\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:409:61\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                                             ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:409:130\n    |\n409 | ...tionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                  ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:405:52\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);\n    |                                                    ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(literal)]);\n    |                                                    ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:42\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:409:61\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                                             ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:409:130\n    |\n409 | ...tionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                  ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:53\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:413:72\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                                        ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:413:142\n    |\n413 | ...ionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                              ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:42\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:409:61\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                                             ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:409:130\n    |\n409 | ...tionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                  ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:53\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:413:72\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                                        ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:50\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, ...\n    |                                                  ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:417:69\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, ...\n    |                                                                     ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:417:91\n    |\n417 | ...petition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                           ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:417:165\n    |\n417 | ...ange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                                                     ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:405:52\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);\n    |                                                    ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(literal)]);\n    |                                                    ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:42\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:409:61\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)...\n    |                                                             ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:53\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:413:72\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                                        ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:413:142\n    |\n413 | ...ionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                              ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:50\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, ...\n    |                                                  ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:417:69\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, ...\n    |                                                                     ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:417:91\n    |\n417 | ...petition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                           ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:421:51\n    |\n421 |     let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, h...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:421:70\n    |\n421 |     let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, h...\n    |                                                                      ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:421:92\n    |\n421 | ...petition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(literal)) });\n    |                                           ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:372:19\n    |\n372 |     let literal = Literal;\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:377:19\n    |\n377 |     let literal = Literal;\n    |                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let literal = literal;\n    |                   ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:386:17\n    |\n386 |     let class = Class;\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:391:18\n    |\n391 |     let anchor = Anchor;\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:396:25\n    |\n396 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:401:32\n    |\n401 |     let group_hir = Hir::group(Group);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:405:52\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal)]);\n    |                                                    ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n405 |     let concat_hir = Hir::concat(vec![Hir::literal(literal)]);\n    |                                                    ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:42\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:409:61\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)...\n    |                                                             ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:409:130\n    |\n409 | ...tionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n409 |     let repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                  ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:53\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:413:72\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::lite...\n    |                                                                        ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:413:142\n    |\n413 | ...ionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n413 |     let repetition_non_greedy_hir = Hir::repetition(Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                              ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:50\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, ...\n    |                                                  ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:417:69\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, ...\n    |                                                                     ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:417:91\n    |\n417 | ...petition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                           ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:417:165\n    |\n417 | ...ange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n417 |     let bounded_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 3)), greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                                                     ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:421:51\n    |\n421 |     let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, h...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:421:70\n    |\n421 |     let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, h...\n    |                                                                      ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:421:92\n    |\n421 | ...petition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(Literal)) });\n    |                                           ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:421:164\n    |\n421 | ...nRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(Literal)) });\n    |                                                                   ^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n421 |     let at_least_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::AtLeast(2)), greedy: false, hir: Box::new(Hir::literal(literal)) });\n    |                                                                                                                                                                    ~~~~~~~\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:425:50\n    |\n425 |     let exactly_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(4)), greedy: true, hir...\n    |                                                  ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:425:69\n    |\n425 |     let exactly_repetition_hir = Hir::repetition(Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(4)), greedy: true, hir...\n    |                                                                     ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:425:91\n    |\n425 | ...petition { kind: RepetitionKind::Range(RepetitionRange::Exactly(4)), greedy: true, hir: Box::new(Hir::literal(literal)) });\n    |                                           ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let word_boundary = WordBoundary;",
                "    let hir = Hir::word_boundary(word_boundary);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&empty_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    assert_eq!(writer.visit_post(&literal_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    assert_eq!(writer.visit_post(&class_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    assert_eq!(writer.visit_post(&anchor_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    assert_eq!(writer.visit_post(&alternation_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    assert_eq!(writer.visit_post(&concat_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    assert!(writer.wtr.is_empty());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    let word_boundary_hir = Hir::word_boundary(word_boundary);",
                  "    assert_eq!(writer.visit_post(&word_boundary_hir), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    let word_boundary_hir = Hir::word_boundary(word_boundary);",
                  "    assert!(writer.wtr.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&empty_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    assert_eq!(writer.visit_post(&literal_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    assert_eq!(writer.visit_post(&class_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    assert_eq!(writer.visit_post(&anchor_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    assert_eq!(writer.visit_post(&alternation_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    assert_eq!(writer.visit_post(&concat_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    let word_boundary_hir = Hir::word_boundary(word_boundary);",
                  "    assert_eq!(writer.visit_post(&word_boundary_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary;",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let empty_hir = Hir::empty();",
                  "    let literal_hir = Hir::literal(Literal);",
                  "    let class_hir = Hir::class(Class);",
                  "    let anchor_hir = Hir::anchor(Anchor);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
                  "    let concat_hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
                  "    let word_boundary_hir = Hir::word_boundary(word_boundary);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:372:25\n    |\n372 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:25\n    |\n377 |     let word_boundary = WordBoundary;\n    |                         ^^^^^^^^^^^^\n    |\nhelp: a local variable with a similar name exists\n    |\n377 |     let word_boundary = word_boundary;\n    |                         ~~~~~~~~~~~~~\nhelp: consider importing one of these items\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0425]: cannot find value `Literal` in this scope\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |     let literal_hir = Hir::literal(Literal);\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Literal;\n    |\n362 +    use ast::ClassSetItem::Literal;\n    |\n362 +    use hir::HirKind::Literal;\n    |\n\nerror[E0425]: cannot find value `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:381:32\n    |\n381 |     let class_hir = Hir::class(Class);\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0425]: cannot find value `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:382:34\n    |\n382 |     let anchor_hir = Hir::anchor(Anchor);\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Group(_) is true\n",
        "// constraint: self.wtr.write_str(\")\")? is Err/None\n"
      ],
      "input_infer": "0 <= hir.kind().group_member_count <= 10, self.wtr.capacity <= 1024\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buffer = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                "    writer.visit_post(&group_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                  "    let result = writer.visit_post(&group_hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                  "    let result = writer.visit_post(&group_hir);",
                  "    assert_eq!(buffer, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                  "    writer.visit_post(&group_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                  "    let result = writer.visit_post(&group_hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                  "    writer.visit_post(&group_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let group_hir = Hir::group(/* initialized with appropriate members */);",
                  "    let result = writer.visit_post(&group_hir);",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/hir/print.rs:373:21\n    |\n373 |     let group_hir = Hir::group(/* initialized with appropriate members */);\n    |                     ^^^^^^^^^^-------------------------------------------- argument #1 of type `hir::Group` is missing\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\nhelp: provide the argument\n    |\n373 |     let group_hir = Hir::group(/* hir::Group */);\n    |                               ~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/hir/print.rs:378:21\n    |\n378 |     let group_hir = Hir::group(/* initialized with appropriate members */);\n    |                     ^^^^^^^^^^-------------------------------------------- argument #1 of type `hir::Group` is missing\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\nhelp: provide the argument\n    |\n378 |     let group_hir = Hir::group(/* hir::Group */);\n    |                               ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/hir/print.rs:373:21\n    |\n373 |     let group_hir = Hir::group(/* initialized with appropriate members */);\n    |                     ^^^^^^^^^^-------------------------------------------- argument #1 of type `hir::Group` is missing\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\nhelp: provide the argument\n    |\n373 |     let group_hir = Hir::group(/* hir::Group */);\n    |                               ~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/hir/print.rs:378:21\n    |\n378 |     let group_hir = Hir::group(/* initialized with appropriate members */);\n    |                     ^^^^^^^^^^-------------------------------------------- argument #1 of type `hir::Group` is missing\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\nhelp: provide the argument\n    |\n378 |     let group_hir = Hir::group(/* hir::Group */);\n    |                               ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buffer = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                "    writer.visit_post(&single_member_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                  "    assert_eq!(writer.visit_post(&single_member_hir), Ok(()));"
                ],
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                  "    assert_eq!(buffer, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                  "    writer.visit_post(&single_member_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                  "    assert_eq!(writer.visit_post(&single_member_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                  "    writer.visit_post(&single_member_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:58\n    |\n370 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                                                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:58\n    |\n375 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                                                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:40\n    |\n370 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Vec<Hir>`\n    |                             |\n    |                             arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:40\n    |\n375 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Vec<Hir>`\n    |                             |\n    |                             arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:58\n    |\n370 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                                                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:58\n    |\n375 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                                                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:40\n    |\n370 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Vec<Hir>`\n    |                             |\n    |                             arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:40\n    |\n375 |     let single_member_hir = Hir::group(vec![Hir::literal(Literal::from('a'))]);\n    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Vec<Hir>`\n    |                             |\n    |                             arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buffer = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                "    let multi_member_hir = Hir::group(vec![",
                "        Hir::literal(Literal::from('a')),",
                "        Hir::literal(Literal::from('b')),",
                "        Hir::literal(Literal::from('c'))",
                "    ]);",
                "    writer.visit_post(&multi_member_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let multi_member_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    Hir::literal(Literal::from('c'))",
                  "    ]);",
                  "    let result = writer.visit_post(&multi_member_hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let multi_member_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    Hir::literal(Literal::from('c'))",
                  "    ]);",
                  "    let result = writer.visit_post(&multi_member_hir);",
                  "    assert_eq!(buffer, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let multi_member_hir = Hir::group(vec![",
                  "        Hir::literal(Literal::from('a')),",
                  "        Hir::literal(Literal::from('b')),",
                  "        Hir::literal(Literal::from('c'))",
                  "    ]);",
                  "    writer.visit_post(&multi_member_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let multi_member_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    Hir::literal(Literal::from('c'))",
                  "    ]);",
                  "    let result = writer.visit_post(&multi_member_hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let multi_member_hir = Hir::group(vec![",
                  "        Hir::literal(Literal::from('a')),",
                  "        Hir::literal(Literal::from('b')),",
                  "        Hir::literal(Literal::from('c'))",
                  "    ]);",
                  "    writer.visit_post(&multi_member_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let multi_member_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    Hir::literal(Literal::from('c'))",
                  "    ]);",
                  "    let result = writer.visit_post(&multi_member_hir);",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |         Hir::literal(Literal::from('a')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |         Hir::literal(Literal::from('b')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:22\n    |\n373 |         Hir::literal(Literal::from('c'))\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:380:18\n    |\n380 |     Hir::literal(Literal::from('a')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:18\n    |\n381 |     Hir::literal(Literal::from('b')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:18\n    |\n382 |     Hir::literal(Literal::from('c'))\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:39\n    |\n370 |       let multi_member_hir = Hir::group(vec![\n    |  ____________________________----------_^\n    | |                            |\n    | |                            arguments to this function are incorrect\n371 | |         Hir::literal(Literal::from('a')),\n372 | |         Hir::literal(Literal::from('b')),\n373 | |         Hir::literal(Literal::from('c'))\n374 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:379:39\n    |\n379 |       let multi_member_hir = Hir::group(vec![\n    |  ____________________________----------_^\n    | |                            |\n    | |                            arguments to this function are incorrect\n380 | |     Hir::literal(Literal::from('a')),\n381 | |     Hir::literal(Literal::from('b')),\n382 | |     Hir::literal(Literal::from('c'))\n383 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |         Hir::literal(Literal::from('a')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |         Hir::literal(Literal::from('b')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:22\n    |\n373 |         Hir::literal(Literal::from('c'))\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:380:18\n    |\n380 |     Hir::literal(Literal::from('a')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:18\n    |\n381 |     Hir::literal(Literal::from('b')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:18\n    |\n382 |     Hir::literal(Literal::from('c'))\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:39\n    |\n370 |       let multi_member_hir = Hir::group(vec![\n    |  ____________________________----------_^\n    | |                            |\n    | |                            arguments to this function are incorrect\n371 | |         Hir::literal(Literal::from('a')),\n372 | |         Hir::literal(Literal::from('b')),\n373 | |         Hir::literal(Literal::from('c'))\n374 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:379:39\n    |\n379 |       let multi_member_hir = Hir::group(vec![\n    |  ____________________________----------_^\n    | |                            |\n    | |                            arguments to this function are incorrect\n380 | |     Hir::literal(Literal::from('a')),\n381 | |     Hir::literal(Literal::from('b')),\n382 | |     Hir::literal(Literal::from('c'))\n383 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buffer = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                "    let edge_case_hir = Hir::group(vec![",
                "        Hir::literal(Literal::from('x')),",
                "        Hir::literal(Literal::from('y')),",
                "        Hir::literal(Literal::from('z')),",
                "        // ... more as needed to reach the upper limit",
                "    ]);",
                "    writer.visit_post(&edge_case_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");"
                ],
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");"
                ],
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");"
                ],
                [
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('A')),",
                  "    Hir::literal(Literal::from('B')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "        Hir::literal(Literal::from('x')),",
                  "        Hir::literal(Literal::from('y')),",
                  "        Hir::literal(Literal::from('z')),",
                  "        // ... more as needed to reach the upper limit",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "        Hir::literal(Literal::from('x')),",
                  "        Hir::literal(Literal::from('y')),",
                  "        Hir::literal(Literal::from('z')),",
                  "        // ... more as needed to reach the upper limit",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "        Hir::literal(Literal::from('x')),",
                  "        Hir::literal(Literal::from('y')),",
                  "        Hir::literal(Literal::from('z')),",
                  "        // ... more as needed to reach the upper limit",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "        Hir::literal(Literal::from('x')),",
                  "        Hir::literal(Literal::from('y')),",
                  "        Hir::literal(Literal::from('z')),",
                  "        // ... more as needed to reach the upper limit",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir);",
                  "    let mut buffer = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut buffer };",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('x')),",
                  "    Hir::literal(Literal::from('y')),",
                  "    Hir::literal(Literal::from('z')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('a')),",
                  "    Hir::literal(Literal::from('b')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    let edge_case_hir = Hir::group(vec![",
                  "    Hir::literal(Literal::from('A')),",
                  "    Hir::literal(Literal::from('B')),",
                  "    ]);",
                  "    writer.visit_post(&edge_case_hir).unwrap();",
                  "    assert_eq!(buffer, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |         Hir::literal(Literal::from('x')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |         Hir::literal(Literal::from('y')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:22\n    |\n373 |         Hir::literal(Literal::from('z')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:18\n    |\n381 |     Hir::literal(Literal::from('x')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:18\n    |\n382 |     Hir::literal(Literal::from('y')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:18\n    |\n383 |     Hir::literal(Literal::from('z')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:36\n    |\n370 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n371 | |         Hir::literal(Literal::from('x')),\n372 | |         Hir::literal(Literal::from('y')),\n373 | |         Hir::literal(Literal::from('z')),\n374 | |         // ... more as needed to reach the upper limit\n375 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n381 | |     Hir::literal(Literal::from('x')),\n382 | |     Hir::literal(Literal::from('y')),\n383 | |     Hir::literal(Literal::from('z')),\n384 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |         Hir::literal(Literal::from('x')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |         Hir::literal(Literal::from('y')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:22\n    |\n373 |         Hir::literal(Literal::from('z')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:18\n    |\n381 |     Hir::literal(Literal::from('x')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:18\n    |\n382 |     Hir::literal(Literal::from('y')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:18\n    |\n383 |     Hir::literal(Literal::from('z')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:36\n    |\n370 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n371 | |         Hir::literal(Literal::from('x')),\n372 | |         Hir::literal(Literal::from('y')),\n373 | |         Hir::literal(Literal::from('z')),\n374 | |         // ... more as needed to reach the upper limit\n375 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n381 | |     Hir::literal(Literal::from('x')),\n382 | |     Hir::literal(Literal::from('y')),\n383 | |     Hir::literal(Literal::from('z')),\n384 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:386:36\n    |\n386 |     let edge_case_hir = Hir::group(vec![]);\n    |                         ---------- ^^^^^^ expected `Group`, found `Vec<_>`\n    |                         |\n    |                         arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<_>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |         Hir::literal(Literal::from('x')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |         Hir::literal(Literal::from('y')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:22\n    |\n373 |         Hir::literal(Literal::from('z')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:18\n    |\n381 |     Hir::literal(Literal::from('x')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:18\n    |\n382 |     Hir::literal(Literal::from('y')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:18\n    |\n383 |     Hir::literal(Literal::from('z')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:18\n    |\n389 |     Hir::literal(Literal::from('a')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:18\n    |\n390 |     Hir::literal(Literal::from('b')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:36\n    |\n370 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n371 | |         Hir::literal(Literal::from('x')),\n372 | |         Hir::literal(Literal::from('y')),\n373 | |         Hir::literal(Literal::from('z')),\n374 | |         // ... more as needed to reach the upper limit\n375 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n381 | |     Hir::literal(Literal::from('x')),\n382 | |     Hir::literal(Literal::from('y')),\n383 | |     Hir::literal(Literal::from('z')),\n384 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:386:36\n    |\n386 |     let edge_case_hir = Hir::group(vec![]);\n    |                         ---------- ^^^^^^ expected `Group`, found `Vec<_>`\n    |                         |\n    |                         arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<_>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:388:36\n    |\n388 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n389 | |     Hir::literal(Literal::from('a')),\n390 | |     Hir::literal(Literal::from('b')),\n391 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |         Hir::literal(Literal::from('x')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |         Hir::literal(Literal::from('y')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:22\n    |\n373 |         Hir::literal(Literal::from('z')),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:18\n    |\n381 |     Hir::literal(Literal::from('x')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:18\n    |\n382 |     Hir::literal(Literal::from('y')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:18\n    |\n383 |     Hir::literal(Literal::from('z')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:18\n    |\n389 |     Hir::literal(Literal::from('a')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:18\n    |\n390 |     Hir::literal(Literal::from('b')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:394:18\n    |\n394 |     Hir::literal(Literal::from('A')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:18\n    |\n395 |     Hir::literal(Literal::from('B')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:36\n    |\n370 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n371 | |         Hir::literal(Literal::from('x')),\n372 | |         Hir::literal(Literal::from('y')),\n373 | |         Hir::literal(Literal::from('z')),\n374 | |         // ... more as needed to reach the upper limit\n375 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:380:36\n    |\n380 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n381 | |     Hir::literal(Literal::from('x')),\n382 | |     Hir::literal(Literal::from('y')),\n383 | |     Hir::literal(Literal::from('z')),\n384 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:386:36\n    |\n386 |     let edge_case_hir = Hir::group(vec![]);\n    |                         ---------- ^^^^^^ expected `Group`, found `Vec<_>`\n    |                         |\n    |                         arguments to this function are incorrect\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<_>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:388:36\n    |\n388 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n389 | |     Hir::literal(Literal::from('a')),\n390 | |     Hir::literal(Literal::from('b')),\n391 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:393:36\n    |\n393 |       let edge_case_hir = Hir::group(vec![\n    |  _________________________----------_^\n    | |                         |\n    | |                         arguments to this function are incorrect\n394 | |     Hir::literal(Literal::from('A')),\n395 | |     Hir::literal(Literal::from('B')),\n396 | |     ]);\n    | |_____^ expected `Group`, found `Vec<Hir>`\n    |\n    = note: expected struct `hir::Group`\n               found struct `Vec<hir::Hir>`\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Group(_) is true\n",
        "// constraint: self.wtr.write_str(\")\")? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "1 <= m <= n <= 100, m >= 0, n >= 0, greedy is true or false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "    ",
                "    let expr = Hir::group(Group::new()); // Assuming a valid group constructor.",
                "",
                "    let result = writer.visit_post(&expr);",
                "",
                "    // The output string should have \")\", since it is a group.",
                "    assert_eq!(output, \")\");",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let expr = Hir::group(Group::new());",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let expr = Hir::group(Group::new());",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "    ",
                  "    let expr = Hir::group(Group::new()); // Assuming a valid group constructor.",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should have \")\", since it is a group.",
                  "    assert_eq!(output, \")\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let expr = Hir::group(Group::new());",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "    ",
                  "    let expr = Hir::group(Group::new()); // Assuming a valid group constructor.",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should have \")\", since it is a group.",
                  "    assert_eq!(output, \")\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let expr = Hir::group(Group::new());",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/print.rs:374:27\n    |\n374 |     let expr = Hir::group(Group::new()); // Assuming a valid group constructor.\n    |                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n362 +    use ast::Group;\n    |\n362 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/print.rs:387:27\n    |\n387 |     let expr = Hir::group(Group::new());\n    |                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n362 +    use ast::Group;\n    |\n362 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/print.rs:374:27\n    |\n374 |     let expr = Hir::group(Group::new()); // Assuming a valid group constructor.\n    |                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n362 +    use ast::Group;\n    |\n362 +    use hir::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/hir/print.rs:387:27\n    |\n387 |     let expr = Hir::group(Group::new());\n    |                           ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n362 +    use ast::Group;\n    |\n362 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::OneOrMore,",
                "        greedy: true,",
                "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                "    };",
                "    let expr = Hir::repetition(repetition);",
                "",
                "    let result = writer.visit_post(&expr);",
                "",
                "    // The output string should be \"+\" since it is a greedy one or more.",
                "    assert_eq!(output, \"+\");",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"{2,5}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let expr = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let expr = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"{2,5}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let expr = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"+\" since it is a greedy one or more.",
                  "    assert_eq!(output, \"+\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer: &mut printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('a'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('b'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::literal(Literal::new('c'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::new('d'))),",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let expr = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:406:22\n    |\n406 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:407:11\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:407:42\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |                                          ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:409:32\n    |\n409 |     hir: Box::new(Hir::literal(Literal::new('c'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:406:22\n    |\n406 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:407:11\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:407:42\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |                                          ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:409:32\n    |\n409 |     hir: Box::new(Hir::literal(Literal::new('c'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:406:22\n    |\n406 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:407:11\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:407:42\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |                                          ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:409:32\n    |\n409 |     hir: Box::new(Hir::literal(Literal::new('c'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:22\n    |\n413 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:416:32\n    |\n416 |     hir: Box::new(Hir::literal(Literal::new('d'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:406:22\n    |\n406 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:407:11\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:407:42\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |                                          ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:409:32\n    |\n409 |     hir: Box::new(Hir::literal(Literal::new('c'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:22\n    |\n413 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:416:32\n    |\n416 |     hir: Box::new(Hir::literal(Literal::new('d'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:406:22\n    |\n406 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:407:11\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:407:42\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |                                          ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:409:32\n    |\n409 |     hir: Box::new(Hir::literal(Literal::new('c'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:22\n    |\n413 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:416:32\n    |\n416 |     hir: Box::new(Hir::literal(Literal::new('d'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:420:40\n    |\n420 |     let expr = Hir::group(Hir::literal(Literal::new('e')));\n    |                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:420:27\n    |\n420 |     let expr = Hir::group(Hir::literal(Literal::new('e')));\n    |                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Hir`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('a'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:393:11\n    |\n393 |     kind: RepetitionKind::ZeroOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:32\n    |\n395 |     hir: Box::new(Hir::literal(Literal::new('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:22\n    |\n399 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:400:11\n    |\n400 |     kind: RepetitionKind::ZeroOrOne,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:402:32\n    |\n402 |     hir: Box::new(Hir::literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:406:22\n    |\n406 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:407:11\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:407:42\n    |\n407 |     kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))),\n    |                                          ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:409:32\n    |\n409 |     hir: Box::new(Hir::literal(Literal::new('c'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:413:22\n    |\n413 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:416:32\n    |\n416 |     hir: Box::new(Hir::literal(Literal::new('d'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:420:40\n    |\n420 |     let expr = Hir::group(Hir::literal(Literal::new('e')));\n    |                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:420:27\n    |\n420 |     let expr = Hir::group(Hir::literal(Literal::new('e')));\n    |                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Hir`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::ZeroOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                "    };",
                "    let expr = Hir::repetition(repetition);",
                "",
                "    let result = writer.visit_post(&expr);",
                "",
                "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                "    assert_eq!(output, \"*?\");",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?+\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?+{{2,5}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?+{{2,5}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let group = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&group);",
                  "    assert_eq!(output, \"*?+{{2,5}}?)\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let group = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&group);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?+\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?+{{2,5}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"*?+{{2,5}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let group = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&group);",
                  "    assert_eq!(output, \"*?+{{2,5}}?)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"*\" followed by \"?\" since it is non-greedy.",
                  "    assert_eq!(output, \"*?\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    let group = Hir::group(Hir::literal(Literal::new('e')));",
                  "    let result = writer.visit_post(&group);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:22\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:395:41\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:395:72\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                                                        ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:148\n    |\n395 | ...))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:22\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:395:41\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:395:72\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                                                        ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:148\n    |\n395 | ...))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:22\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:395:41\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:395:72\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                                                        ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:148\n    |\n395 | ...))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:398:22\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:398:41\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:398:109\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:22\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:395:41\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:395:72\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                                                        ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:148\n    |\n395 | ...))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:398:22\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:398:41\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:398:109\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:22\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:395:41\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:395:72\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                                                        ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:148\n    |\n395 | ...))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:398:22\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:398:41\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:398:109\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:401:41\n    |\n401 |     let group = Hir::group(Hir::literal(Literal::new('e')));\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:401:28\n    |\n401 |     let group = Hir::group(Hir::literal(Literal::new('e')));\n    |                 ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Hir`\n    |                 |\n    |                 arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::ZeroOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('b'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:111\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::new('b'))) };\n    |                                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:22\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:392:41\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:392:109\n    |\n392 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::literal(Literal::new('a'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:22\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:395:41\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:395:72\n    |\n395 |     let repetition = Repetition { kind: RepetitionKind::Range(Box::new(RepetitionRange::Bounded(2, 5))), greedy: false, hir: Box::new(Hir...\n    |                                                                        ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:395:148\n    |\n395 | ...))), greedy: false, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:398:22\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:398:41\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:398:109\n    |\n398 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:401:41\n    |\n401 |     let group = Hir::group(Hir::literal(Literal::new('e')));\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:401:28\n    |\n401 |     let group = Hir::group(Hir::literal(Literal::new('e')));\n    |                 ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Group`, found `Hir`\n    |                 |\n    |                 arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:343:12\n    |\n343 |     pub fn group(group: Group) -> Hir {\n    |            ^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),",
                "        greedy: true,",
                "        hir: Box::new(Hir::literal(Literal::new('c'))), // Assuming a valid literal constructor",
                "    };",
                "    let expr = Hir::repetition(repetition);",
                "",
                "    let result = writer.visit_post(&expr);",
                "",
                "    // The output string should be \"{2,5}\" since it is a bounded repetition.",
                "    assert_eq!(output, \"{2,5}\");",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"{2,5}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('c'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"{2,5}\" since it is a bounded repetition.",
                  "    assert_eq!(output, \"{2,5}\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"{2,5}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('c'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"{2,5}\" since it is a bounded repetition.",
                  "    assert_eq!(output, \"{2,5}\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(Literal::new('c'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:375:37\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('c'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(L...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(L...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:389:63\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(L...\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:137\n    |\n389 | ... 5)), greedy: true, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:375:37\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('c'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(L...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(L...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:389:63\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 5)), greedy: true, hir: Box::new(Hir::literal(L...\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:137\n    |\n389 | ... 5)), greedy: true, hir: Box::new(Hir::literal(Literal::new('c'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),",
                "        greedy: true,",
                "        hir: Box::new(Hir::literal(Literal::new('d'))), // Assuming a valid literal constructor",
                "    };",
                "    let expr = Hir::repetition(repetition);",
                "",
                "    let result = writer.visit_post(&expr);",
                "",
                "    // The output string should be \"{3}\" since it is an exact repetition.",
                "    assert_eq!(output, \"{3}\");",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"{3}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('d'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"{3}\" since it is an exact repetition.",
                  "    assert_eq!(output, \"{3}\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert_eq!(output, \"{3}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::literal(Literal::new('d'))), // Assuming a valid literal constructor",
                  "    };",
                  "    let expr = Hir::repetition(repetition);",
                  "",
                  "    let result = writer.visit_post(&expr);",
                  "",
                  "    // The output string should be \"{3}\" since it is an exact repetition.",
                  "    assert_eq!(output, \"{3}\");",
                  "    assert!(result.is_ok());",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };",
                  "    let expr = Hir::repetition(repetition);",
                  "    let result = writer.visit_post(&expr);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:375:37\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('d'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Lite...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Lite...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:389:63\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Lite...\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:134\n    |\n389 | ...(3)), greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:374:22\n    |\n374 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:375:37\n    |\n375 |         kind: RepetitionKind::Range(RepetitionRange::Exactly(3)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:36\n    |\n377 |         hir: Box::new(Hir::literal(Literal::new('d'))), // Assuming a valid literal constructor\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:22\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Lite...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:389:41\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Lite...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:389:63\n    |\n389 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Exactly(3)), greedy: true, hir: Box::new(Hir::literal(Lite...\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:134\n    |\n389 | ...(3)), greedy: true, hir: Box::new(Hir::literal(Literal::new('d'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::Range(ref x) is true\n",
        "// constraint: *x matches hir::RepetitionRange::Bounded(m, n) is true\n",
        "// constraint: write!(self.wtr, \"{{{},{}}}\", m, n)? is Err/None\n"
      ],
      "input_infer": "m = 0 to 10, n = 0 to 10 where m <= n and m, n are both integers inclusive\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                "    ",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),",
                "        greedy: true,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                "    ",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:383:11\n    |\n383 |     kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:383:33\n    |\n383 |     kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 0)),\n    |                                 ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:66\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                "    ",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                "        greedy: true,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                "    ",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:383:11\n    |\n383 |     kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:383:33\n    |\n383 |     kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |                                 ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:66\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:383:11\n    |\n383 |     kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:383:33\n    |\n383 |     kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 1)),\n    |                                 ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:66\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                "    ",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)),",
                "        greedy: true,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                "    ",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)), greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{{2,3}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)), greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{{2,3}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:382:41\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:382:63\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(2, 3)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:66\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                "    ",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),",
                "        greedy: true,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                "    ",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{{0,5}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{{0,5}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:382:41\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:382:63\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:66\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:382:41\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:382:63\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(0, 5)), greedy: true, hir: Box::new(Hir::empty()), };\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:66\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                "    ",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                "    ",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{{1,2}}?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    ",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut wtr };",
                  "    let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(wtr, \"{{1,2}}?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty())...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:382:41\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty())...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:382:63\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty())...\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:66\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:371:22\n    |\n371 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:372:15\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:372:37\n    |\n372 |         kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)),\n    |                                     ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:376:66\n    |\n376 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:22\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty())...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:382:41\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty())...\n    |                                         ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n   --> regex-syntax/src/hir/print.rs:382:63\n    |\n382 |     let repetition = Repetition { kind: RepetitionKind::Range(RepetitionRange::Bounded(1, 2)), greedy: false, hir: Box::new(Hir::empty())...\n    |                                                               ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionRange;\n    |\n362 +    use hir::RepetitionRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:66\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::Range(ref x) is true\n",
        "// constraint: *x matches hir::RepetitionRange::Bounded(m, n) is true\n",
        "// constraint: write!(self.wtr, \"{{{},{}}}\", m, n)? is Ok/Some\n",
        "// constraint: x.greedy is false\n",
        "// constraint: self.wtr.write_str(\"?\")? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "m: 1..=100, n: 1..=100 where m  n, greedy: false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: Default::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    assert_eq!(output, \"{{1,5}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    assert_eq!(output, \"{{1,5}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: Default::default(),\n    |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: Default::default(),\n    |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: Default::default(),\n    |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: Default::default(),\n    |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(100, 100)),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: Default::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(100, 100)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{100,100}}?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(100, 100)),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(100, 100)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{100,100}}?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: Default::default(),\n    |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: Default::default(),\n    |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(10, 20)),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: Default::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(10, 20)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{10,20}}?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(10, 20)),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(10, 20)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: Default::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{10,20}}?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: Default::default(),\n    |               ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nerror[E0277]: the trait bound `HirInfo: Default` is not satisfied\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: Default::default(),\n    |           ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `HirInfo`\n    |\nhelp: consider annotating `HirInfo` with `#[derive(Default)]`\n   --> regex-syntax/src/hir/mod.rs:1296:1\n    |\n1296+ #[derive(Default)]\n1297| struct HirInfo {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::Range(ref x) is true\n",
        "// constraint: *x matches hir::RepetitionRange::AtLeast(m) is true\n",
        "// constraint: *x matches hir::RepetitionRange::AtLeast(m) is true\n",
        "// constraint: write!(self.wtr, \"{{{},}}\", m)? is Err/None\n"
      ],
      "input_infer": "m: 0 to 100 (inclusive)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "    let result = output.clone();",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "    let result2 = output.clone();",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "    let result3 = output.clone();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    assert_eq!(result, \"{{0,}}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "    assert_eq!(result2, \"{{1,}}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result3 = output.clone();",
                  "    assert_eq!(result3, \"{{100,}}?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result3 = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    assert_eq!(result, \"{{0,}}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result3 = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "    assert_eq!(result2, \"{{1,}}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result3 = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result2 = output.clone();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result3 = output.clone();",
                  "    assert_eq!(result3, \"{{100,}}?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:35\n    |\n387 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:15\n    |\n392 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:35\n    |\n399 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:404:15\n    |\n404 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:412:47\n    |\n412 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:412:191\n    |\n412 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(0))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:388:46\n     |\n388  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n388  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:400:46\n     |\n400  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n400  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:412:93\n     |\n412  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n412  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:35\n    |\n387 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:15\n    |\n392 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:35\n    |\n399 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:404:15\n    |\n404 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:412:47\n    |\n412 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:412:191\n    |\n412 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:415:47\n    |\n415 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:415:191\n    |\n415 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(0))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:388:46\n     |\n388  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n388  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:400:46\n     |\n400  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n400  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:412:93\n     |\n412  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n412  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:415:93\n     |\n415  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n415  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:35\n    |\n387 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:15\n    |\n392 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:399:35\n    |\n399 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:404:15\n    |\n404 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:412:47\n    |\n412 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:412:191\n    |\n412 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:415:47\n    |\n415 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:415:191\n    |\n415 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:418:47\n    |\n418 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100)))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:418:194\n    |\n418 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(0))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:388:46\n     |\n388  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n388  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:400:46\n     |\n400  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n400  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:412:93\n     |\n412  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n412  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(0))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:415:93\n     |\n415  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n415  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:418:93\n     |\n418  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: Hir...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n418  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "    let result = output.clone();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{10,}}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{1,}}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(2, 5))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{2,5}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{10,}}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{1,}}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "    printer,",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(2, 5))),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{2,5}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:31\n    |\n392 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:397:11\n    |\n397 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:393:38\n     |\n393  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n393  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(10))),\n     |                                      +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:31\n    |\n392 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:397:11\n    |\n397 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:393:38\n     |\n393  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n393  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(10))),\n     |                                      +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:31\n    |\n392 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:397:11\n    |\n397 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:401:31\n    |\n401 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:406:11\n    |\n406 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:393:38\n     |\n393  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n393  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(10))),\n     |                                      +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:402:38\n     |\n402  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n402  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                                      +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:392:31\n    |\n392 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:397:11\n    |\n397 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:401:31\n    |\n401 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:406:11\n    |\n406 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:410:31\n    |\n410 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:415:11\n    |\n415 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(0, 100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:393:38\n     |\n393  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(10))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n393  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(10))),\n     |                                      +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:402:38\n     |\n402  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(1))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n402  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(1))),\n     |                                      +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:411:38\n     |\n411  |     kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(2, 5))),\n     |           -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n411  |     kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(2, 5))),\n     |                                      +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(10, 5))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "    let result = output.clone();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{5,}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(10, 5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(10, 5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let result = output.clone();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{5,}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:388:47\n    |\n388 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:388:192\n    |\n388 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(10, 5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(10, 5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:388:93\n     |\n388  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n388  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:388:47\n    |\n388 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:388:192\n    |\n388 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(10, 5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(10, 5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:388:93\n     |\n388  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n388  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::Range(ref x) is true\n",
        "// constraint: *x matches hir::RepetitionRange::AtLeast(m) is true\n",
        "// constraint: *x matches hir::RepetitionRange::AtLeast(m) is true\n",
        "// constraint: write!(self.wtr, \"{{{},}}\", m)? is Ok/Some\n",
        "// constraint: x.greedy is false\n",
        "// constraint: self.wtr.write_str(\"?\")? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "m = 0 to 100, n = 0 to 100 where m <= n or m = 0, greedy = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::ZeroOrOne,",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(repetition),",
                "        info: HirInfo {},",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::ZeroOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(repetition),",
                "        info: HirInfo {},",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:22\n    |\n384 |     let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:22\n    |\n384 |     let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::OneOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(repetition),",
                "        info: HirInfo {},",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"+\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.ends_with(\"?\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"+\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.ends_with(\"?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(repetition),",
                "        info: HirInfo {},",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{3,}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"?\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"{{3,}}\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{3,}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::empty()) };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"{{3,}}\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:22\n    |\n384 |     let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::e...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:22\n    |\n384 |     let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::e...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `is_ok` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:387:24\n    |\n387 |     assert!(writer.wtr.is_ok());\n    |                        ^^^^^ method not found in `&mut String`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:22\n    |\n384 |     let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::e...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:22\n    |\n384 |     let repetition = Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)), greedy: false, hir: Box::new(Hir::e...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(repetition),",
                "        info: HirInfo {},",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{3,}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{1,4}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{2}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{0,}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{3,}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{1,4}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{2}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(3)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 4)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(repetition),",
                  "    info: HirInfo {},",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{{0,}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:407:22\n    |\n407 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:407:22\n    |\n407 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:22\n    |\n417 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:424:11\n    |\n424 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:407:22\n    |\n407 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:22\n    |\n417 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:424:11\n    |\n424 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:427:22\n    |\n427 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:434:11\n    |\n434 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:407:22\n    |\n407 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:22\n    |\n417 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:424:11\n    |\n424 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:427:22\n    |\n427 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:434:11\n    |\n434 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:437:22\n    |\n437 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:444:11\n    |\n444 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:407:22\n    |\n407 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:22\n    |\n417 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:424:11\n    |\n424 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:427:22\n    |\n427 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:434:11\n    |\n434 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:437:22\n    |\n437 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:444:11\n    |\n444 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:447:22\n    |\n447 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:454:11\n    |\n454 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:22\n    |\n372 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:15\n    |\n379 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:22\n    |\n387 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:394:11\n    |\n394 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:397:22\n    |\n397 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:404:11\n    |\n404 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:407:22\n    |\n407 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:417:22\n    |\n417 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:424:11\n    |\n424 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:427:22\n    |\n427 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:434:11\n    |\n434 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:437:22\n    |\n437 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:444:11\n    |\n444 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:447:22\n    |\n447 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:454:11\n    |\n454 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:457:22\n    |\n457 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:464:11\n    |\n464 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::Range(ref x) is true\n",
        "// constraint: *x matches hir::RepetitionRange::Exactly(m) is true\n",
        "// constraint: *x matches hir::RepetitionRange::Exactly(m) is true\n",
        "// constraint: write!(self.wtr, \"{{{}}}\", m)? is Err/None\n"
      ],
      "input_infer": "m: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..., MAX_INT (where MAX_INT is the maximum value of u32)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{0}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{0}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(1)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(1)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{1}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(1)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(1)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{1}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{2}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(2)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{2}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(u32::MAX)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(u32::MAX)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    assert_eq!(output, \"{{4294967295}}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(u32::MAX)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(u32::MAX)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    assert_eq!(output, \"{{4294967295}}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{0}}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(printer.wtr.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{0}}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(0)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(printer.wtr.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:35\n    |\n370 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:375:15\n    |\n375 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0609]: no field `wtr` on type `hir::print::Printer`\n   --> regex-syntax/src/hir/print.rs:391:21\n    |\n391 |     assert!(printer.wtr.is_empty());\n    |                     ^^^ unknown field\n    |\n    = note: available field is: `_priv`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 16,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::Range(ref x) is true\n",
        "// constraint: *x matches hir::RepetitionRange::Exactly(m) is true\n",
        "// constraint: *x matches hir::RepetitionRange::Exactly(m) is true\n",
        "// constraint: write!(self.wtr, \"{{{}}}\", m)? is Ok/Some\n",
        "// constraint: x.greedy is false\n",
        "// constraint: self.wtr.write_str(\"?\")? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "m: 0 to 100, x.greedy: false, *x matches hir::RepetitionRange::Exactly(m) is true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "    ",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo {},",
                "    };",
                "",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{0}}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "    ",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{0}}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "    ",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(0))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(0))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(0))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo {},",
                "    };",
                "",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{1}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.finish().is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{1}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.finish().is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(1))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(1))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(1))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo {},",
                "    };",
                "",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{5}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.wtr, &mut String::new()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.printer, &mut Printer { _priv: () }));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(output.contains(\"{{5}}\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(output.ends_with(\"?\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.printer._priv.is_some());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.wtr.is_utf8());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{5}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.wtr, &mut String::new()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.printer, &mut Printer { _priv: () }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(output.contains(\"{{5}}\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(output.ends_with(\"?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.printer._priv.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.wtr.is_utf8());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nerror[E0164]: expected tuple struct or tuple variant, found associated function `String::new`\n   --> regex-syntax/src/hir/print.rs:389:39\n    |\n389 |     assert!(matches!(writer.wtr, &mut String::new()));\n    |                                       ^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n    |\n    = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0164, E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0164`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nerror[E0599]: no method named `is_some` found for unit type `()` in the current scope\n   --> regex-syntax/src/hir/print.rs:389:34\n    |\n389 |     assert!(writer.printer._priv.is_some());\n    |                                  ^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:192\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(5))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nerror[E0599]: no method named `is_utf8` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:389:24\n    |\n389 |     assert!(writer.wtr.is_utf8());\n    |                        ^^^^^^^ method not found in `&mut String`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo {},",
                "    };",
                "",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{99}}?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.finish(), Ok(())));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{{99}}?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.finish(), Ok(())));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:193\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(99))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:193\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(99))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirI...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(99))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut output,",
                "    };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo {},",
                "    };",
                "",
                "    let _ = writer.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{100}?\", \"Output does not match expected format\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.finish(), Ok(())), \"Expected finish to return Ok(())\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.wtr.is_empty(), \"Writer should not have further output\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.printer._priv.is_empty(), \"Printer should have private data intact\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{100}?\", \"Output does not match expected format\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(matches!(writer.finish(), Ok(())), \"Expected finish to return Ok(())\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.wtr.is_empty(), \"Writer should not have further output\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer {",
                  "        printer: &mut printer,",
                  "        wtr: &mut output,",
                  "    };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo {},",
                  "    };",
                  "",
                  "    let _ = writer.visit_post(&hir);",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };",
                  "    let _ = writer.visit_post(&hir);",
                  "    assert!(writer.printer._priv.is_empty(), \"Printer should have private data intact\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100)))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:194\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: Hir...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100)))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:194\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: Hir...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100)))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:194\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: Hir...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:35\n    |\n375 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:15\n    |\n380 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100)))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:387:194\n    |\n387 | ...edy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:376:46\n     |\n376  |             kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))),\n     |                   -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n376  |             kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))),\n     |                                              +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...d: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: Hir...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(100))), greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo {}, };\n     |                                                                                             +\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n   --> regex-syntax/src/hir/print.rs:389:34\n    |\n389 |     assert!(writer.printer._priv.is_empty(), \"Printer should have private data intact\");\n    |                                  ^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 17,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::OneOrMore is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::OneOrMore is true\n",
        "// constraint: self.wtr.write_str(\"+\")? is Err/None\n"
      ],
      "input_infer": "1 <= m <= 1, m == n (for Bounded case), x.greedy == true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::OneOrMore,",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:47\n    |\n384 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:384:151\n    |\n384 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::OneOrMore,",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"+?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::ZeroOrMore,",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"+\");"
                ],
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*?\");"
                ],
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"{3}\");"
                ],
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"{2,}\");"
                ],
                [
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 4)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"{2,4}\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"+\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"{3}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"{2,}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    output.clear();",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 4)),",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"{2,4}\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:31\n    |\n391 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:396:11\n    |\n396 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:31\n    |\n391 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:396:11\n    |\n396 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:31\n    |\n400 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:405:11\n    |\n405 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:31\n    |\n391 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:396:11\n    |\n396 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:31\n    |\n400 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:405:11\n    |\n405 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:31\n    |\n409 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:31\n    |\n391 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:396:11\n    |\n396 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:31\n    |\n400 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:405:11\n    |\n405 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:31\n    |\n409 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:418:31\n    |\n418 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:423:11\n    |\n423 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:31\n    |\n391 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:396:11\n    |\n396 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:31\n    |\n400 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:405:11\n    |\n405 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:31\n    |\n409 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:418:31\n    |\n418 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:423:11\n    |\n423 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:427:31\n    |\n427 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:432:11\n    |\n432 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:382:31\n    |\n382 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:11\n    |\n387 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:31\n    |\n391 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:396:11\n    |\n396 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:31\n    |\n400 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:405:11\n    |\n405 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:409:31\n    |\n409 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:414:11\n    |\n414 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:418:31\n    |\n418 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:423:11\n    |\n423 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:427:31\n    |\n427 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:432:11\n    |\n432 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:436:31\n    |\n436 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:441:11\n    |\n441 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::ZeroOrMore,",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 1)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 1)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 20,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::OneOrMore is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::OneOrMore is true\n",
        "// constraint: self.wtr.write_str(\"+\")? is Ok/Some\n",
        "// constraint: x.greedy is false\n",
        "// constraint: self.wtr.write_str(\"?\")? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= m <= 1000, 0 <= n <= 1000, m < n, m > 0, x.greedy = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::OneOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir::repetition(repetition);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"+\").is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"?\").is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"+\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"?\").is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:387:24\n    |\n387 |     assert!(writer.wtr.write_str(\"+\").is_ok());\n    |                        ^^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n362 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n387 |     assert!(writer.wtr.write_char(\"+\").is_ok());\n    |                        ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:387:24\n    |\n387 |     assert!(writer.wtr.write_str(\"?\").is_ok());\n    |                        ^^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n362 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n387 |     assert!(writer.wtr.write_char(\"?\").is_ok());\n    |                        ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::OneOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                "    };",
                "    let hir = Hir::repetition(repetition);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(matches!(writer.wtr, &mut String::from(\"+?\")));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(matches!(writer.wtr, &mut String::from(\"+?\")));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.wtr.len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:32\n    |\n383 |     hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:32\n    |\n383 |     hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0164]: expected tuple struct or tuple variant, found associated function `String::from`\n   --> regex-syntax/src/hir/print.rs:387:39\n    |\n387 |     assert!(matches!(writer.wtr, &mut String::from(\"+?\")));\n    |                                       ^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n    |\n    = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0164, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0164`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:32\n    |\n383 |     hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::OneOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                "    };",
                "    let hir = Hir::repetition(repetition);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.finish().is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"+\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"?\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(writer.finish().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"+\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),",
                  "    };",
                  "    let hir = Hir::repetition(repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"?\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |         hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:383:30\n    |\n383 |     hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                              ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |         hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:383:30\n    |\n383 |     hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                              ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |         hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:383:30\n    |\n383 |     hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                              ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:22\n    |\n370 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |         hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:381:11\n    |\n381 |     kind: RepetitionKind::OneOrMore,\n    |           ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:383:30\n    |\n383 |     hir: Box::new(Hir::class(Class::new(vec!['a', 'b', 'c']))),\n    |                              ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                "    let inner_repetition = Repetition {",
                "        kind: RepetitionKind::OneOrMore,",
                "        greedy: false,",
                "        hir: Box::new(Hir::literal(Literal::from('b'))),",
                "    };",
                "    let outer_repetition = Repetition {",
                "        kind: RepetitionKind::Repetition(inner_repetition),",
                "        greedy: false,",
                "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                "    };",
                "    let hir = Hir::repetition(outer_repetition);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"+\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"?\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.finish(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('b'))),",
                  "    };",
                  "    let outer_repetition = Repetition {",
                  "        kind: RepetitionKind::Repetition(inner_repetition),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('b'))),",
                  "    };",
                  "    let outer_repetition = Repetition {",
                  "        kind: RepetitionKind::Repetition(inner_repetition),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"+\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('b'))),",
                  "    };",
                  "    let outer_repetition = Repetition {",
                  "        kind: RepetitionKind::Repetition(inner_repetition),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(output.contains(\"?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('b'))),",
                  "    };",
                  "    let outer_repetition = Repetition {",
                  "        kind: RepetitionKind::Repetition(inner_repetition),",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::literal(Literal::from('a'))),",
                  "    };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
                  "    let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };",
                  "    let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };",
                  "    let hir = Hir::repetition(outer_repetition);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.finish(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:28\n    |\n370 |     let inner_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('b'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:28\n    |\n375 |     let outer_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:376:15\n    |\n376 |         kind: RepetitionKind::Repetition(inner_repetition),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:36\n    |\n378 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:28\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:116\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:386:28\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:386:47\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:135\n    |\n386 | ...on), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:28\n    |\n370 |     let inner_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('b'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:28\n    |\n375 |     let outer_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:376:15\n    |\n376 |         kind: RepetitionKind::Repetition(inner_repetition),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:36\n    |\n378 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:28\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:116\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:386:28\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:386:47\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:135\n    |\n386 | ...on), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:28\n    |\n370 |     let inner_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('b'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:28\n    |\n375 |     let outer_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:376:15\n    |\n376 |         kind: RepetitionKind::Repetition(inner_repetition),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:36\n    |\n378 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:28\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:116\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:386:28\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:386:47\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:135\n    |\n386 | ...on), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:370:28\n    |\n370 |     let inner_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         kind: RepetitionKind::OneOrMore,\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |         hir: Box::new(Hir::literal(Literal::from('b'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:375:28\n    |\n375 |     let outer_repetition = Repetition {\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:376:15\n    |\n376 |         kind: RepetitionKind::Repetition(inner_repetition),\n    |               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:36\n    |\n378 |         hir: Box::new(Hir::literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:28\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:116\n    |\n385 |     let inner_repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('b'))) };\n    |                                                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:386:28\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                            ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionKind`\n   --> regex-syntax/src/hir/print.rs:386:47\n    |\n386 |     let outer_repetition = Repetition { kind: RepetitionKind::Repetition(inner_repetition), greedy: false, hir: Box::new(Hir::literal(Lit...\n    |                                               ^^^^^^^^^^^^^^ use of undeclared type `RepetitionKind`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::RepetitionKind;\n    |\n362 +    use hir::RepetitionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:386:135\n    |\n386 | ...on), greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 21,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrMore is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrMore is true\n",
        "// constraint: self.wtr.write_str(\"*\")? is Err/None\n"
      ],
      "input_infer": "0 <= m <= n <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::ZeroOrMore,",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::ZeroOrMore,",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    assert_eq!(output, \"*?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:153\n    |\n383 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::OneOrMore,",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{3}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{2,}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{1,5}\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{3}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{2,}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"{1,5}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:385:151\n    |\n385 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:385:151\n    |\n385 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:191\n    |\n387 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:385:151\n    |\n385 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:191\n    |\n387 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:47\n    |\n389 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:389:191\n    |\n389 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:389:93\n     |\n389  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n389  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:385:151\n    |\n385 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:191\n    |\n387 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:47\n    |\n389 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:389:191\n    |\n389 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:47\n    |\n391 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:391:194\n    |\n391 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:389:93\n     |\n389  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n389  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:391:93\n     |\n391  | ...ition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::e...\n     |                             -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                             |\n     |                             arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n391  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:385:151\n    |\n385 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:191\n    |\n387 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:47\n    |\n389 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:389:191\n    |\n389 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:47\n    |\n391 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:391:194\n    |\n391 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:393:47\n    |\n393 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:393:153\n    |\n393 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:389:93\n     |\n389  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n389  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:391:93\n     |\n391  | ...ition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::e...\n     |                             -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                             |\n     |                             arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n391  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:383:47\n    |\n383 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:383:152\n    |\n383 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:47\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:385:151\n    |\n385 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:47\n    |\n387 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:387:191\n    |\n387 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:389:47\n    |\n389 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), ...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:389:191\n    |\n389 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:47\n    |\n391 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:391:194\n    |\n391 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:393:47\n    |\n393 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::empty...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:393:153\n    |\n393 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:395:47\n    |\n395 |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir::empty(...\n    |                                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:395:152\n    |\n395 | ... false, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:387:93\n     |\n387  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n387  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Exactly(3))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:389:93\n     |\n389  | ...nd: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirIn...\n     |        -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |        |\n     |        arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n389  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::AtLeast(2))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/print.rs:391:93\n     |\n391  | ...ition(Repetition { kind: hir::RepetitionKind::Range(Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::e...\n     |                             -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `RepetitionRange`, found `Box<RepetitionRange>`\n     |                             |\n     |                             arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::RepetitionRange`\n              found struct `Box<hir::RepetitionRange>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:1234:5\n     |\n1234 |     Range(RepetitionRange),\n     |     ^^^^^\nhelp: consider unboxing the value\n     |\n391  |     let hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::Range(*Box::new(hir::RepetitionRange::Bounded(1, 5))), greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n     |                                                                                             +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(5)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert!(output.is_empty());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert!(writer.wtr.write_str(\"*\").is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert!(output.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert!(writer.wtr.write_str(\"*\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:394:24\n    |\n394 |     assert!(writer.wtr.write_str(\"*\").is_ok());\n    |                        ^^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n362 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n394 |     assert!(writer.wtr.write_char(\"*\").is_ok());\n    |                        ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer {",
                "        printer: &mut Printer { _priv: () },",
                "        wtr: &mut output,",
                "    };",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"+?\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{2,5}?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"+?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "        printer: &mut Printer { _priv: () },",
                  "        wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer {",
                  "    printer: &mut Printer { _priv: () },",
                  "    wtr: &mut output,",
                  "    };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    let hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(output, \"{2,5}?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:396:31\n    |\n396 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:401:11\n    |\n401 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:396:31\n    |\n396 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:401:11\n    |\n401 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:396:31\n    |\n396 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:401:11\n    |\n401 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:405:31\n    |\n405 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:410:11\n    |\n410 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:35\n    |\n373 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:378:15\n    |\n378 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:387:31\n    |\n387 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:392:11\n    |\n392 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:396:31\n    |\n396 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:401:11\n    |\n401 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:405:31\n    |\n405 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:410:11\n    |\n410 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 22,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrMore is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrMore is true\n",
        "// constraint: self.wtr.write_str(\"*\")? is Ok/Some\n",
        "// constraint: x.greedy is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= m <= 10, 0 <= n <= 10, m <= n\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::ZeroOrMore,",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.is_empty() == false);"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.contains('*'));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.finish().is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"*\").is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.contains('*'));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.finish().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"*\").is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:393:24\n    |\n393 |     assert!(writer.wtr.write_str(\"*\").is_ok());\n    |                        ^^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n362 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n393 |     assert!(writer.wtr.write_char(\"*\").is_ok());\n    |                        ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::ZeroOrMore,",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.visit_post(&repetition_hir).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::ZeroOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.visit_post(&repetition_hir).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::OneOrMore,",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"+\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.len() > 0);"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.contains(\"+\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"+\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output.contains(\"+\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:58\n    |\n384 |     let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(H...\n    |                                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:384:162\n    |\n384 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:58\n    |\n384 |     let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(H...\n    |                                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:384:162\n    |\n384 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:384:58\n    |\n384 |     let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(H...\n    |                                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:384:162\n    |\n384 | ...: true, hir: Box::new(Hir::empty()), }), info: HirInfo::default(), };\n    |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::OneOrMore,",
                "            greedy: false,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::OneOrMore,",
                  "            greedy: false,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output == \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"*\").is_ok());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"?\").is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(output == \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"*\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Exactly(3)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert!(writer.wtr.write_str(\"?\").is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:393:24\n    |\n393 |     assert!(writer.wtr.write_str(\"*\").is_ok());\n    |                        ^^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n362 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n393 |     assert!(writer.wtr.write_char(\"*\").is_ok());\n    |                        ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for mutable reference `&mut String` in the current scope\n   --> regex-syntax/src/hir/print.rs:393:24\n    |\n393 |     assert!(writer.wtr.write_str(\"?\").is_err());\n    |                        ^^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n362 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n393 |     assert!(writer.wtr.write_char(\"?\").is_err());\n    |                        ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(writer.visit_post(&repetition_hir).unwrap(), ());"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(writer.visit_post(&repetition_hir).unwrap(), ());",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::AtLeast(2)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let mut writer = Writer { printer, wtr: &mut output };",
                "    ",
                "    let repetition_hir = Hir {",
                "        kind: HirKind::Repetition(Repetition {",
                "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                "            greedy: true,",
                "            hir: Box::new(Hir::empty()),",
                "        }),",
                "        info: HirInfo::default(),",
                "    };",
                "    ",
                "    writer.visit_post(&repetition_hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let repetition_hir_greedy_false = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir_greedy_false).unwrap();",
                  "    assert_eq!(output, \"*?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    ",
                  "    let repetition_hir = Hir {",
                  "        kind: HirKind::Repetition(Repetition {",
                  "            kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(2, 5)),",
                  "            greedy: true,",
                  "            hir: Box::new(Hir::empty()),",
                  "        }),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    ",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let mut output = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let mut writer = Writer { printer, wtr: &mut output };",
                  "    let repetition_hir = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir).unwrap();",
                  "    let repetition_hir_greedy_false = Hir {",
                  "    kind: HirKind::Repetition(Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrMore,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    writer.visit_post(&repetition_hir_greedy_false).unwrap();",
                  "    assert_eq!(output, \"*?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:372:35\n    |\n372 |         kind: HirKind::Repetition(Repetition {\n    |                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:377:15\n    |\n377 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:385:31\n    |\n385 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:390:11\n    |\n390 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:394:31\n    |\n394 |     kind: HirKind::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:399:11\n    |\n399 |     info: HirInfo::default(),\n    |           ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 25,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrOne is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrOne is true\n",
        "// constraint: self.wtr.write_str(\"?\")? is Err/None\n"
      ],
      "input_infer": "HirKind::Repetition with RepetitionKind::ZeroOrOne and self.wtr.write_str(\"?\") returning Err\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestWriter {",
                "        should_fail: bool,",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for TestWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            if self.should_fail {",
                "                Err(fmt::Error)",
                "            } else {",
                "                self.output.push_str(s);",
                "                Ok(())",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                "    ",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::ZeroOrOne,",
                "        greedy: true,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    ",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(repetition),",
                "        info: HirInfo::default(),",
                "    };",
                "",
                "    let _ = visitor.visit_post(&hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default(), };",
                  "    let result = visitor.visit_post(&hir);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default(), };",
                  "    let result = visitor.visit_post(&hir);",
                  "    assert_eq!(result.unwrap_err(), fmt::Error);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestWriter {",
                  "        should_fail: bool,",
                  "        output: String,",
                  "    }",
                  "",
                  "    impl fmt::Write for TestWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            if self.should_fail {",
                  "                Err(fmt::Error)",
                  "            } else {",
                  "                self.output.push_str(s);",
                  "                Ok(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    ",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    let _ = visitor.visit_post(&hir);",
                  "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default(), };",
                  "    let result = visitor.visit_post(&hir);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestWriter {",
                  "        should_fail: bool,",
                  "        output: String,",
                  "    }",
                  "",
                  "    impl fmt::Write for TestWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            if self.should_fail {",
                  "                Err(fmt::Error)",
                  "            } else {",
                  "                self.output.push_str(s);",
                  "                Ok(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    ",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: true,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    ",
                  "    let hir = Hir {",
                  "        kind: HirKind::Repetition(repetition),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "",
                  "    let _ = visitor.visit_post(&hir);",
                  "    let mut writer = TestWriter { should_fail: true, output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default(), };",
                  "    let result = visitor.visit_post(&hir);",
                  "    assert_eq!(result.unwrap_err(), fmt::Error);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:386:22\n    |\n386 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:394:15\n    |\n394 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:22\n    |\n400 |     let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:401:66\n    |\n401 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default(), };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:386:22\n    |\n386 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:394:15\n    |\n394 |         info: HirInfo::default(),\n    |               ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:400:22\n    |\n400 |     let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n   --> regex-syntax/src/hir/print.rs:401:66\n    |\n401 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default(), };\n    |                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 27,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: *hir.kind() matches HirKind::Repetition(ref x) is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrOne is true\n",
        "// constraint: x.kind matches hir::RepetitionKind::ZeroOrOne is true\n",
        "// constraint: self.wtr.write_str(\"?\")? is Ok/Some\n",
        "// constraint: x.greedy is false\n",
        "// constraint: self.wtr.write_str(\"?\")? is Err/None\n"
      ],
      "input_infer": "0 <= m <= 10, 0 <= n <= 10, m <= n, greedy = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut writer = MockWriter { output: String::new() };",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::ZeroOrOne,",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                "",
                "    visitor.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    visitor.visit_post(&hir).unwrap();",
                  "    assert_eq!(visitor.wtr.output, \"?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockWriter {",
                  "        output: String,",
                  "    }",
                  "",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                  "            self.output.push_str(s);",
                  "            Ok(())",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "",
                  "    visitor.visit_post(&hir).unwrap();",
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition {",
                  "    kind: hir::RepetitionKind::ZeroOrOne,",
                  "    greedy: false,",
                  "    hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    visitor.visit_post(&hir).unwrap();",
                  "    assert_eq!(visitor.wtr.output, \"?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:380:22\n    |\n380 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:66\n    |\n385 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:390:22\n    |\n390 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:395:66\n    |\n395 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct MockWriter {",
                "        // This implementation simulates a failure on write.",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                "            Err(fmt::Error)",
                "        }",
                "    }",
                "",
                "    let mut writer = MockWriter { output: String::new() };",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                "    let repetition = Repetition {",
                "        kind: hir::RepetitionKind::ZeroOrOne,",
                "        greedy: false,",
                "        hir: Box::new(Hir::empty()),",
                "    };",
                "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                "",
                "    visitor.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    assert_eq!(visitor.visit_post(&hir).is_err(), true);"
                ],
                [
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    assert_eq!(writer.output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockWriter {",
                  "        // This implementation simulates a failure on write.",
                  "        output: String,",
                  "    }",
                  "",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                  "            Err(fmt::Error)",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "",
                  "    visitor.visit_post(&hir).unwrap();",
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    assert_eq!(visitor.visit_post(&hir).is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockWriter {",
                  "        // This implementation simulates a failure on write.",
                  "        output: String,",
                  "    }",
                  "",
                  "    impl fmt::Write for MockWriter {",
                  "        fn write_str(&mut self, _s: &str) -> fmt::Result {",
                  "            Err(fmt::Error)",
                  "        }",
                  "    }",
                  "",
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition {",
                  "        kind: hir::RepetitionKind::ZeroOrOne,",
                  "        greedy: false,",
                  "        hir: Box::new(Hir::empty()),",
                  "    };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "",
                  "    visitor.visit_post(&hir).unwrap();",
                  "    let mut writer = MockWriter { output: String::new() };",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: writer };",
                  "    let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Hir::empty()), };",
                  "    let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };",
                  "    assert_eq!(writer.output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:381:22\n    |\n381 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:386:66\n    |\n386 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:22\n    |\n391 |     let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:392:66\n    |\n392 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:381:22\n    |\n381 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:386:66\n    |\n386 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:391:22\n    |\n391 |     let repetition = Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: false, hir: Box::new(Hir::empty()), };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:392:66\n    |\n392 |     let hir = Hir { kind: HirKind::Repetition(repetition), info: HirInfo {} };\n    |                                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 29,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::WordBoundary(_) is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "HirKind::WordBoundary(_), HirKind::Anchor(_), HirKind::Alternation(vec![HirKind::Empty]), HirKind::Class(_), HirKind::Literal(Literal::new('a')), HirKind::Concat(vec![HirKind::Literal(Literal::new('a')), HirKind::Class(Class::new(vec!['b', 'c']))])\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = Vec::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::WordBoundary(WordBoundary {}),",
                "        info: HirInfo {},",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.visit_post(&hir).is_ok(), true);"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(wtr.len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::WordBoundary(WordBoundary {}),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.visit_post(&hir).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::WordBoundary(WordBoundary {}),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(wtr.len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:370:37\n    |\n370 |         kind: HirKind::WordBoundary(WordBoundary {}),\n    |                                     ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:49\n    |\n377 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:377:73\n    |\n377 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:379:23\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n379 |     assert_eq!(writer.visit_post(&hir).is_ok(), true);\n    |                       ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:370:37\n    |\n370 |         kind: HirKind::WordBoundary(WordBoundary {}),\n    |                                     ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:377:49\n    |\n377 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:377:73\n    |\n377 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {}, };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = Vec::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Anchor(Anchor {}),",
                "        info: HirInfo {},",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Anchor(Anchor {}),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:370:31\n    |\n370 |         kind: HirKind::Anchor(Anchor {}),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:377:43\n    |\n377 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:377:61\n    |\n377 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:379:25\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n379 |     let result = writer.visit_post(&hir);\n    |                         ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = Vec::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Alternation(vec![Hir::empty()]),",
                "        info: HirInfo {},",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::empty()]), info: HirInfo {}, };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.visit_post(&hir).unwrap(), ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Alternation(vec![Hir::empty()]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::empty()]), info: HirInfo {}, };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.visit_post(&hir).unwrap(), ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:377:75\n    |\n377 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::empty()]), info: HirInfo {}, };\n    |                                                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:379:23\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n379 |     assert_eq!(writer.visit_post(&hir).unwrap(), ());\n    |                       ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = Vec::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                "        info: HirInfo {},",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                  "    info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.wtr, b\"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                  "    info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, b\"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                  "    info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.wtr, b\"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "    kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
                  "    info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, b\"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:370:30\n    |\n370 |         kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),\n    |                              ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:378:26\n    |\n378 |     kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:11\n    |\n379 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:370:30\n    |\n370 |         kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),\n    |                              ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:378:26\n    |\n378 |     kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:379:11\n    |\n379 |     info: HirInfo {},\n    |           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = Vec::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Literal(Literal::new('a')),",
                "        info: HirInfo {},",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Literal(Literal::new('a')), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.visit_post(&hir).unwrap(), ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Literal(Literal::new('a')),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Literal(Literal::new('a')), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    assert_eq!(writer.visit_post(&hir).unwrap(), ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:32\n    |\n370 |         kind: HirKind::Literal(Literal::new('a')),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:371:15\n    |\n371 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:377:44\n    |\n377 |     let hir = Hir { kind: HirKind::Literal(Literal::new('a')), info: HirInfo {} };\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:377:70\n    |\n377 |     let hir = Hir { kind: HirKind::Literal(Literal::new('a')), info: HirInfo {} };\n    |                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:374:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n374 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:379:23\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n379 |     assert_eq!(writer.visit_post(&hir).unwrap(), ());\n    |                       ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = Vec::new();",
                "    let mut printer = Printer { _priv: () };",
                "    let hir = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir::literal(Literal::new('a')),",
                "            Hir::class(Class::new(vec!['b', 'c'])),",
                "        ]),",
                "        info: HirInfo {},",
                "    };",
                "    let mut writer = Writer { printer: &mut printer, wtr };",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ],
                [
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Concat(vec![Hir::literal(Literal::new('g'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir::literal(Literal::new('a')),",
                  "            Hir::class(Class::new(vec!['b', 'c'])),",
                  "        ]),",
                  "        info: HirInfo {},",
                  "    };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut wtr = Vec::new();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let hir = Hir { kind: HirKind::Concat(vec![Hir::literal(Literal::new('g'))]), info: HirInfo {} };",
                  "    let mut writer = Writer { printer: &mut printer, wtr };",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(String::from_utf8(wtr).unwrap(), \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:385:43\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:61\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:387:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n387 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:385:43\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:61\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:66\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:390:94\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:387:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n387 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:392:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n392 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:385:43\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:61\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:66\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:390:94\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:395:49\n    |\n395 |     let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };\n    |                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:387:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n387 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:392:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n392 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:397:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n397 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:385:43\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:61\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:66\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:390:94\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:395:49\n    |\n395 |     let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };\n    |                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:400:42\n    |\n400 |     let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:400:77\n    |\n400 |     let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };\n    |                                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:387:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n387 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:392:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n392 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:397:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n397 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:402:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n402 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:385:43\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:61\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:66\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:390:94\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:395:49\n    |\n395 |     let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };\n    |                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:400:42\n    |\n400 |     let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:400:77\n    |\n400 |     let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };\n    |                                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:405:44\n    |\n405 |     let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:405:70\n    |\n405 |     let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };\n    |                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:387:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n387 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:392:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n392 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:397:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n397 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:402:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n402 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:407:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n407 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:371:26\n    |\n371 |             Hir::literal(Literal::new('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:24\n    |\n372 |             Hir::class(Class::new(vec!['b', 'c'])),\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:374:15\n    |\n374 |         info: HirInfo {},\n    |               ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:380:49\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:380:73\n    |\n380 |     let hir = Hir { kind: HirKind::WordBoundary(WordBoundary {}), info: HirInfo {} };\n    |                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:385:43\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:385:61\n    |\n385 |     let hir = Hir { kind: HirKind::Anchor(Anchor {}), info: HirInfo {} };\n    |                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:390:66\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:390:94\n    |\n390 |     let hir = Hir { kind: HirKind::Alternation(vec![Hir::literal(Literal::new('a'))]), info: HirInfo {} };\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:395:49\n    |\n395 |     let hir = Hir { kind: HirKind::Empty, info: HirInfo {} };\n    |                                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:400:42\n    |\n400 |     let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:400:77\n    |\n400 |     let hir = Hir { kind: HirKind::Class(Class::new(vec!['d', 'e'])), info: HirInfo {} };\n    |                                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:405:44\n    |\n405 |     let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:405:70\n    |\n405 |     let hir = Hir { kind: HirKind::Literal(Literal::new('f')), info: HirInfo {} };\n    |                                                                      ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:410:61\n    |\n410 |     let hir = Hir { kind: HirKind::Concat(vec![Hir::literal(Literal::new('g'))]), info: HirInfo {} };\n    |                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n   --> regex-syntax/src/hir/print.rs:410:89\n    |\n410 |     let hir = Hir { kind: HirKind::Concat(vec![Hir::literal(Literal::new('g'))]), info: HirInfo {} };\n    |                                                                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n362 +    use hir::HirInfo;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:377:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n377 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:382:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n382 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:387:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n387 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:392:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n392 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:397:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n397 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:402:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n402 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:407:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n407 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: the method `visit_post` exists for struct `Writer<'_, Vec<_>>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/hir/print.rs:412:12\n    |\n77  | struct Writer<'p, W> {\n    | -------------------- method `visit_post` not found for this struct because it doesn't satisfy `_: Visitor`\n...\n412 |     writer.visit_post(&hir).unwrap();\n    |            ^^^^^^^^^^ method cannot be called on `Writer<'_, Vec<_>>` due to unsatisfied trait bounds\n    |\nnote: trait bound `Vec<_>: std::fmt::Write` was not satisfied\n   --> regex-syntax/src/hir/print.rs:82:13\n    |\n82  | impl<'p, W: fmt::Write> Visitor for Writer<'p, W> {\n    |             ^^^^^^^^^^  -------     -------------\n    |             |\n    |             unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n            candidate #1: `ast::visitor::Visitor`\n            candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 30,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Anchor(_) is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Hir with kind Anchor, Hir with kind Alternation, Hir with kind Empty, Hir with kind Class, Hir with kind Literal, Hir with kind Concat, Hir with kind WordBoundary\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let hir = Hir::empty();",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let literal = Literal::new('a');",
                "    let hir = Hir::literal(literal);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal::new('a');",
                  "    let hir = Hir::literal(literal);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal::new('a');",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal::new('a');",
                  "    let hir = Hir::literal(literal);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:19\n    |\n369 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:19\n    |\n374 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class = Class::new(vec!['a', 'b', 'c']);",
                "    let hir = Hir::class(class);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output is empty since HirKind::Class(_) is handled during visit_pre."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    assert!(writer.visit_post(&hir).is_ok());  // Assert that visit_post returns Ok for HirKind::Class(_)."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output is still empty for HirKind::Anchor(_)."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output is still empty for HirKind::Alternation(_)."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::Empty."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let literal = Literal::new('a');  // Assuming a constructor for Literal",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::Literal(_)."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let literal = Literal::new('a');  // Assuming a constructor for Literal",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let word_boundary = WordBoundary::new();  // Assuming a constructor for WordBoundary",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::WordBoundary(_)."
                ],
                [
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let literal = Literal::new('a');  // Assuming a constructor for Literal",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let word_boundary = WordBoundary::new();  // Assuming a constructor for WordBoundary",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let concat = Concat::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Concat",
                  "    let hir = Hir::concat(concat);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::Concat(_)."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output is empty since HirKind::Class(_) is handled during visit_pre.",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    assert!(writer.visit_post(&hir).is_ok());  // Assert that visit_post returns Ok for HirKind::Class(_).",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output is still empty for HirKind::Anchor(_).",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output is still empty for HirKind::Alternation(_).",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::Empty.",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let literal = Literal::new('a');  // Assuming a constructor for Literal",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::Literal(_).",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let literal = Literal::new('a');  // Assuming a constructor for Literal",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let word_boundary = WordBoundary::new();  // Assuming a constructor for WordBoundary",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::WordBoundary(_).",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let class = Class::new(vec!['a', 'b', 'c']);",
                  "    let hir = Hir::class(class);",
                  "    let anchor = Anchor::new();  // Assuming a constructor for Anchor",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation",
                  "    let hir = Hir::alternation(alternation);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let empty_hir = Hir::empty();",
                  "    writer.visit_post(&empty_hir).unwrap();",
                  "    let literal = Literal::new('a');  // Assuming a constructor for Literal",
                  "    let hir = Hir::literal(literal);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let word_boundary = WordBoundary::new();  // Assuming a constructor for WordBoundary",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let concat = Concat::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Concat",
                  "    let hir = Hir::concat(concat);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");  // Assert that the writer output remains unchanged for HirKind::Concat(_).",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();  // Assuming a constructor for Anchor\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();  // Assuming a constructor for Anchor\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Alternation`\n   --> regex-syntax/src/hir/print.rs:377:23\n    |\n377 |     let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation\n    |                       ^^^^^^^^^^^ use of undeclared type `Alternation`\n    |\nhelp: consider importing this struct\n    |\n362 +    use ast::Alternation;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();  // Assuming a constructor for Anchor\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Alternation`\n   --> regex-syntax/src/hir/print.rs:377:23\n    |\n377 |     let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation\n    |                       ^^^^^^^^^^^ use of undeclared type `Alternation`\n    |\nhelp: consider importing this struct\n    |\n362 +    use ast::Alternation;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();  // Assuming a constructor for Anchor\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Alternation`\n   --> regex-syntax/src/hir/print.rs:377:23\n    |\n377 |     let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation\n    |                       ^^^^^^^^^^^ use of undeclared type `Alternation`\n    |\nhelp: consider importing this struct\n    |\n362 +    use ast::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:19\n    |\n382 |     let literal = Literal::new('a');  // Assuming a constructor for Literal\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();  // Assuming a constructor for Anchor\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Alternation`\n   --> regex-syntax/src/hir/print.rs:377:23\n    |\n377 |     let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation\n    |                       ^^^^^^^^^^^ use of undeclared type `Alternation`\n    |\nhelp: consider importing this struct\n    |\n362 +    use ast::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:19\n    |\n382 |     let literal = Literal::new('a');  // Assuming a constructor for Literal\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:385:25\n    |\n385 |     let word_boundary = WordBoundary::new();  // Assuming a constructor for WordBoundary\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:372:17\n    |\n372 |     let class = Class::new(vec!['a', 'b', 'c']);\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();  // Assuming a constructor for Anchor\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Alternation`\n   --> regex-syntax/src/hir/print.rs:377:23\n    |\n377 |     let alternation = Alternation::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Alternation\n    |                       ^^^^^^^^^^^ use of undeclared type `Alternation`\n    |\nhelp: consider importing this struct\n    |\n362 +    use ast::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:382:19\n    |\n382 |     let literal = Literal::new('a');  // Assuming a constructor for Literal\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:385:25\n    |\n385 |     let word_boundary = WordBoundary::new();  // Assuming a constructor for WordBoundary\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Concat`\n   --> regex-syntax/src/hir/print.rs:388:18\n    |\n388 |     let concat = Concat::new(vec![hir.clone(), hir.clone()]);  // Assuming a constructor for Concat\n    |                  ^^^^^^ use of undeclared type `Concat`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use std::slice::Concat;\n    |\n362 +    use ast::Concat;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let anchor = Anchor::new();",
                "    let hir = Hir::anchor(anchor);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(matches!(writer.finish(), Ok(())));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert!(matches!(writer.finish(), Ok(())));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:18\n    |\n369 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:18\n    |\n369 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:18\n    |\n369 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let word_boundary = WordBoundary::new();",
                "    let hir = Hir::word_boundary(word_boundary);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    let result = writer.visit_post(&hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:25\n    |\n369 |     let word_boundary = WordBoundary::new();\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:374:25\n    |\n374 |     let word_boundary = WordBoundary::new();\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                "    let hir = Hir::concat(concats);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::concat(concats);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:37\n    |\n369 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:70\n    |\n369 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:37\n    |\n374 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:70\n    |\n374 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:37\n    |\n369 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:70\n    |\n369 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:37\n    |\n374 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:70\n    |\n374 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:37\n    |\n369 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:70\n    |\n369 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:37\n    |\n374 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:70\n    |\n374 |     let concats = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                "    let hir = Hir::alternation(alternatives);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::alternation(alternatives);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::alternation(alternatives);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];",
                  "    let hir = Hir::alternation(alternatives);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:75\n    |\n369 |     let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:42\n    |\n374 |     let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:374:75\n    |\n374 |     let alternatives = vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))];\n    |                                                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 31,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Class(_) is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Class: (1, 1), Literal: (1, 1), Empty: (0, 0), Anchor: (0, 0), WordBoundary: (0, 0), Alternation: (2, 10), Concat: (2, 10)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                "    let _ = writer.visit_post(&class_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    assert_eq!(wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                  "    let _ = writer.visit_post(&class_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                  "    let _ = writer.visit_post(&class_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    assert_eq!(wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:370:32\n    |\n370 |     let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:375:32\n    |\n375 |     let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:370:32\n    |\n370 |     let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:375:32\n    |\n375 |     let class_hir = Hir::class(Class::new(vec!['a', 'b'], false));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let literal_hir = Hir::literal(Literal::new('a'));",
                "    let _ = writer.visit_post(&literal_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    assert_eq!(wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let _ = writer.visit_post(&literal_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let _ = writer.visit_post(&literal_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    assert_eq!(wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:36\n    |\n370 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:36\n    |\n370 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let empty_hir = Hir::empty();",
                "    let _ = writer.visit_post(&empty_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `writer` as mutable, as it is not declared as mutable\n   --> regex-syntax/src/hir/print.rs:371:13\n    |\n371 |     let _ = writer.visit_post(&empty_hir);\n    |             ^^^^^^ cannot borrow as mutable\n    |\nhelp: consider changing this to be mutable\n    |\n369 |     let mut writer = Writer { printer, wtr: &mut wtr };\n    |         +++\n\nerror[E0596]: cannot borrow `writer` as mutable, as it is not declared as mutable\n   --> regex-syntax/src/hir/print.rs:376:18\n    |\n376 |     let result = writer.visit_post(&empty_hir);\n    |                  ^^^^^^ cannot borrow as mutable\n    |\nhelp: consider changing this to be mutable\n    |\n374 |     let mut writer = Writer { printer, wtr: &mut wtr };\n    |         +++\n\nSome errors have detailed explanations: E0432, E0596.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let anchor_hir = Hir::anchor(Anchor::new());",
                "    let _ = writer.visit_post(&anchor_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let _ = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let _ = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let _ = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let _ = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let _ = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = writer.visit_post(&anchor_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = writer.visit_post(&empty_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = writer.visit_post(&literal_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = writer.visit_post(&class_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:370:34\n    |\n370 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:370:34\n    |\n370 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:370:34\n    |\n370 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:36\n    |\n385 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:370:34\n    |\n370 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:36\n    |\n385 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:390:32\n    |\n390 |     let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:370:34\n    |\n370 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:36\n    |\n385 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:390:32\n    |\n390 |     let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:395:48\n    |\n395 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                "    let _ = writer.visit_post(&word_boundary_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let _ = writer.visit_post(&word_boundary_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = writer.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:370:48\n    |\n370 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:375:48\n    |\n375 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                "    let _ = writer.visit_post(&concat_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&concat_hir);",
                  "    assert_eq!(wtr, \"ab\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let _ = writer.visit_post(&concat_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let _ = writer.visit_post(&concat_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&concat_hir);",
                  "    assert_eq!(wtr, \"ab\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:52\n    |\n370 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:85\n    |\n370 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:52\n    |\n375 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:85\n    |\n375 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:52\n    |\n370 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:85\n    |\n370 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:52\n    |\n375 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:85\n    |\n375 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut wtr = String::new();",
                "    let printer = &mut Printer { _priv: () };",
                "    let writer = Writer { printer, wtr: &mut wtr };",
                "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                "    let _ = writer.visit_post(&alternation_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let _ = writer.visit_post(&alternation_hir);",
                  "    let mut wtr = String::new();",
                  "    let printer = &mut Printer { _priv: () };",
                  "    let writer = Writer { printer, wtr: &mut wtr };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = writer.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:62\n    |\n370 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:370:95\n    |\n370 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:62\n    |\n375 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:95\n    |\n375 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 32,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Literal(_) is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "test input ranges: HirKind::Literal(_), HirKind::Empty, HirKind::Class(_), HirKind::Anchor(_), HirKind::WordBoundary(_), HirKind::Concat(_), HirKind::Alternation(_, _), HirKind::Repetition(hir::Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty())}), HirKind::Repetition(hir::Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a')))}), HirKind::Repetition(hir::Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c'])))}), HirKind::Repetition(hir::Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start))})\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let literal_hir = Hir::literal(Literal::from('a'));",
                "    let _ = visitor.visit_post(&literal_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    assert_eq!(visitor.visit_post(&literal_hir), Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(visitor.visit_post(&empty_hir), Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    assert_eq!(visitor.visit_post(&anchor_hir), Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    assert_eq!(visitor.visit_post(&class_hir), Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());",
                  "    assert_eq!(visitor.visit_post(&word_boundary_hir), Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());",
                  "    let concat_hir = Hir::concat(vec![literal_hir.clone(), literal_hir.clone()]);",
                  "    assert_eq!(visitor.visit_post(&concat_hir), Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());",
                  "    let concat_hir = Hir::concat(vec![literal_hir.clone(), literal_hir.clone()]);",
                  "    let alternation_hir = Hir::alternation(vec![literal_hir.clone(), literal_hir.clone()]);",
                  "    assert_eq!(visitor.visit_post(&alternation_hir), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    assert_eq!(visitor.visit_post(&literal_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    assert_eq!(visitor.visit_post(&empty_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    assert_eq!(visitor.visit_post(&anchor_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    assert_eq!(visitor.visit_post(&class_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());",
                  "    assert_eq!(visitor.visit_post(&word_boundary_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());",
                  "    let concat_hir = Hir::concat(vec![literal_hir.clone(), literal_hir.clone()]);",
                  "    assert_eq!(visitor.visit_post(&concat_hir), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let empty_hir = Hir::empty();",
                  "    let anchor_hir = Hir::anchor(Anchor::some_anchor());",
                  "    let class_hir = Hir::class(Class::some_class());",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());",
                  "    let concat_hir = Hir::concat(vec![literal_hir.clone(), literal_hir.clone()]);",
                  "    let alternation_hir = Hir::alternation(vec![literal_hir.clone(), literal_hir.clone()]);",
                  "    assert_eq!(visitor.visit_post(&alternation_hir), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::some_anchor());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::some_anchor());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:376:32\n    |\n376 |     let class_hir = Hir::class(Class::some_class());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::some_anchor());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:376:32\n    |\n376 |     let class_hir = Hir::class(Class::some_class());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:377:48\n    |\n377 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::some_anchor());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:376:32\n    |\n376 |     let class_hir = Hir::class(Class::some_class());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:377:48\n    |\n377 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:36\n    |\n369 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:34\n    |\n375 |     let anchor_hir = Hir::anchor(Anchor::some_anchor());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:376:32\n    |\n376 |     let class_hir = Hir::class(Class::some_class());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:377:48\n    |\n377 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::some_boundary());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let empty_hir = Hir::empty();",
                "    let _ = visitor.visit_post(&empty_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let anchor_hir = Hir::anchor(Anchor::new());",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let class_hir = Hir::class(Class::new());",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::new());",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:377:34\n    |\n377 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:377:34\n    |\n377 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:377:34\n    |\n377 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:381:48\n    |\n381 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:377:34\n    |\n377 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:381:48\n    |\n381 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:52\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:86\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:377:34\n    |\n377 |     let anchor_hir = Hir::anchor(Anchor::new());\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new());\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:381:48\n    |\n381 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::new());\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:52\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:86\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:62\n    |\n385 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:96\n    |\n385 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let class_hir = Hir::class(Class::from(vec!['a', 'b', 'c']));",
                "    let _ = visitor.visit_post(&class_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let class_hir = Hir::class(Class::from(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let class_hir = Hir::class(Class::from(vec!['a', 'b', 'c']));",
                  "    let _ = visitor.visit_post(&class_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let class_hir = Hir::class(Class::from(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:32\n    |\n369 |     let class_hir = Hir::class(Class::from(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:373:32\n    |\n373 |     let class_hir = Hir::class(Class::from(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let anchor_hir = Hir::anchor(Anchor::Start);",
                "    let _ = visitor.visit_post(&anchor_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from_char('c')), Hir::literal(Literal::from_char('d'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let anchor_hir = Hir::anchor(Anchor::Start);",
                  "    let result = visitor.visit_post(&anchor_hir);",
                  "    let literal_hir = Hir::literal(Literal::from_char('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));",
                  "    let result = visitor.visit_post(&class_hir);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from_char('c')), Hir::literal(Literal::from_char('d'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from_char('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from_char('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from_char('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from_char('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:381:48\n    |\n381 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from_char('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:381:48\n    |\n381 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:52\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:91\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);\n    |                                                                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:34\n    |\n369 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:34\n    |\n373 |     let anchor_hir = Hir::anchor(Anchor::Start);\n    |                                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:36\n    |\n375 |     let literal_hir = Hir::literal(Literal::from_char('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:32\n    |\n379 |     let class_hir = Hir::class(Class::new(vec!['a', 'b', 'c']));\n    |                                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:381:48\n    |\n381 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Any);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:52\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:383:91\n    |\n383 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from_char('a')), Hir::literal(Literal::from_char('b'))]);\n    |                                                                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:62\n    |\n385 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from_char('c')), Hir::literal(Literal::from_char('d'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:101\n    |\n385 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from_char('c')), Hir::literal(Literal::from_char('d'))]);\n    |                                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                "    let _ = visitor.visit_post(&word_boundary_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);",
                  "    let result = visitor.visit_post(&word_boundary_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let empty_hir = Hir::empty();",
                  "    let result = visitor.visit_post(&empty_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::new('a'));",
                  "    let result = visitor.visit_post(&literal_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = visitor.visit_post(&concat_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:48\n    |\n369 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:373:48\n    |\n373 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:48\n    |\n369 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:373:48\n    |\n373 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:48\n    |\n369 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:373:48\n    |\n373 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:36\n    |\n381 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:48\n    |\n369 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:373:48\n    |\n373 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:36\n    |\n381 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:52\n    |\n385 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:85\n    |\n385 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:48\n    |\n369 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:373:48\n    |\n373 |     let word_boundary_hir = Hir::word_boundary(WordBoundary::Word);\n    |                                                ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:381:36\n    |\n381 |     let literal_hir = Hir::literal(Literal::new('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:52\n    |\n385 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:385:85\n    |\n385 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:62\n    |\n389 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:389:95\n    |\n389 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::new('a')), Hir::literal(Literal::new('b'))]);\n    |                                                                                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                "    let _ = visitor.visit_post(&concat_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let anchor_hir = Hir::anchor(Anchor {});",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let empty_hir = Hir::empty();",
                  "    let class_hir = Hir::class(Class {});",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary {});",
                  "    let group_hir = Hir::group(Group {});",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let _ = visitor.visit_post(&alternation_hir);",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let _ = visitor.visit_post(&class_hir);",
                  "    let _ = visitor.visit_post(&concat_hir);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let _ = visitor.visit_post(&group_hir);",
                  "    assert_eq!(visitor.wtr, \"\");"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let anchor_hir = Hir::anchor(Anchor {});",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let empty_hir = Hir::empty();",
                  "    let class_hir = Hir::class(Class {});",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary {});",
                  "    let group_hir = Hir::group(Group {});",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let _ = visitor.visit_post(&alternation_hir);",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let _ = visitor.visit_post(&class_hir);",
                  "    let _ = visitor.visit_post(&concat_hir);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let _ = visitor.visit_post(&group_hir);",
                  "    assert!(visitor.wtr.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let _ = visitor.visit_post(&concat_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let anchor_hir = Hir::anchor(Anchor {});",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let empty_hir = Hir::empty();",
                  "    let class_hir = Hir::class(Class {});",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary {});",
                  "    let group_hir = Hir::group(Group {});",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let _ = visitor.visit_post(&alternation_hir);",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let _ = visitor.visit_post(&class_hir);",
                  "    let _ = visitor.visit_post(&concat_hir);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let _ = visitor.visit_post(&group_hir);",
                  "    assert_eq!(visitor.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let _ = visitor.visit_post(&concat_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let literal_hir = Hir::literal(Literal::from('a'));",
                  "    let anchor_hir = Hir::anchor(Anchor {});",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let empty_hir = Hir::empty();",
                  "    let class_hir = Hir::class(Class {});",
                  "    let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let word_boundary_hir = Hir::word_boundary(WordBoundary {});",
                  "    let group_hir = Hir::group(Group {});",
                  "    let _ = visitor.visit_post(&literal_hir);",
                  "    let _ = visitor.visit_post(&anchor_hir);",
                  "    let _ = visitor.visit_post(&alternation_hir);",
                  "    let _ = visitor.visit_post(&empty_hir);",
                  "    let _ = visitor.visit_post(&class_hir);",
                  "    let _ = visitor.visit_post(&concat_hir);",
                  "    let _ = visitor.visit_post(&word_boundary_hir);",
                  "    let _ = visitor.visit_post(&group_hir);",
                  "    assert!(visitor.wtr.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:52\n    |\n369 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:86\n    |\n369 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:374:34\n    |\n374 |     let anchor_hir = Hir::anchor(Anchor {});\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:62\n    |\n375 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:96\n    |\n375 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:377:32\n    |\n377 |     let class_hir = Hir::class(Class {});\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:52\n    |\n378 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:86\n    |\n378 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:379:48\n    |\n379 |     let word_boundary_hir = Hir::word_boundary(WordBoundary {});\n    |                                                ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:380:32\n    |\n380 |     let group_hir = Hir::group(Group {});\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use ast::Group;\n    |\n362 +    use hir::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:52\n    |\n369 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:86\n    |\n369 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:36\n    |\n373 |     let literal_hir = Hir::literal(Literal::from('a'));\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Anchor` in this scope\n   --> regex-syntax/src/hir/print.rs:374:34\n    |\n374 |     let anchor_hir = Hir::anchor(Anchor {});\n    |                                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing this variant\n    |\n362 +    use hir::HirKind::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:62\n    |\n375 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:375:96\n    |\n375 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Class` in this scope\n   --> regex-syntax/src/hir/print.rs:377:32\n    |\n377 |     let class_hir = Hir::class(Class {});\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::Ast::Class;\n    |\n362 +    use hir::HirKind::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:52\n    |\n378 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:378:86\n    |\n378 |     let concat_hir = Hir::concat(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `WordBoundary` in this scope\n   --> regex-syntax/src/hir/print.rs:379:48\n    |\n379 |     let word_boundary_hir = Hir::word_boundary(WordBoundary {});\n    |                                                ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these variants\n    |\n362 +    use ast::AssertionKind::WordBoundary;\n    |\n362 +    use hir::HirKind::WordBoundary;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/hir/print.rs:380:32\n    |\n380 |     let group_hir = Hir::group(Group {});\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Group;\n    |\n362 +    use ast::Group;\n    |\n362 +    use hir::Group;\n    |\n362 +    use hir::HirKind::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                "    let _ = visitor.visit_post(&alternation_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let _ = visitor.visit_post(&alternation_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);",
                  "    let result = visitor.visit_post(&alternation_hir);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:62\n    |\n369 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:96\n    |\n369 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:62\n    |\n373 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:96\n    |\n373 |     let alternation_hir = Hir::alternation(vec![Hir::literal(Literal::from('a')), Hir::literal(Literal::from('b'))]);\n    |                                                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()) });",
                "    let _ = visitor.visit_post(&repetition_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()) });",
                  "    let result = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()) });",
                  "    let result = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()) });\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:42\n    |\n373 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrOne, greedy: true, hir: Box::new(Hir::empty()) });\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                "    let _ = visitor.visit_post(&repetition_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                  "    let result = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                  "    let result = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(visitor.wtr, \"*?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                  "    let result = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });",
                  "    let result = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(visitor.wtr, \"*?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Li...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:136\n    |\n369 | ...ore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:42\n    |\n373 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Li...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:136\n    |\n373 | ...ore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Li...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:369:136\n    |\n369 | ...ore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:42\n    |\n373 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::ZeroOrMore, greedy: false, hir: Box::new(Hir::literal(Li...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/hir/print.rs:373:136\n    |\n373 | ...ore, greedy: false, hir: Box::new(Hir::literal(Literal::from('a'))) });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Literal;\n    |\n362 +    use hir::Literal;\n    |\n362 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c']))) });",
                "    let _ = visitor.visit_post(&repetition_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c']))) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(visitor.wtr, \"+\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c']))) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c']))) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    assert_eq!(visitor.wtr, \"+\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class:...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:132\n    |\n369 | ...neOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c']))) });\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:42\n    |\n373 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::OneOrMore, greedy: true, hir: Box::new(Hir::class(Class:...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:373:132\n    |\n373 | ...neOrMore, greedy: true, hir: Box::new(Hir::class(Class::from(vec!['a', 'b', 'c']))) });\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = Printer { _priv: () };",
                "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                "    let _ = visitor.visit_post(&repetition_hir);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.contains(\"?\"));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.contains(\"{1,5}\"));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.len() > 0);"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.ends_with(\"?\"));"
                ],
                [
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.starts_with(\"{1,5}\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.contains(\"?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.contains(\"{1,5}\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.ends_with(\"?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let _ = visitor.visit_post(&repetition_hir);",
                  "    let mut writer = Printer { _priv: () };",
                  "    let mut visitor = Writer { printer: &mut writer, wtr: String::new() };",
                  "    let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });",
                  "    let result = visitor.visit_post(&repetitions_hir_bounded);",
                  "    assert!(visitor.wtr.starts_with(\"{1,5}\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: fals...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:167\n    |\n369 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:51\n    |\n373 |     let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), gre...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:176\n    |\n373 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: fals...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:167\n    |\n369 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:51\n    |\n373 |     let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), gre...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:176\n    |\n373 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: fals...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:167\n    |\n369 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:51\n    |\n373 |     let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), gre...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:176\n    |\n373 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: fals...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:167\n    |\n369 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:51\n    |\n373 |     let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), gre...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:176\n    |\n373 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: fals...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:167\n    |\n369 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:51\n    |\n373 |     let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), gre...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:176\n    |\n373 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:369:42\n    |\n369 |     let repetition_hir = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), greedy: fals...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:167\n    |\n369 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/hir/print.rs:373:51\n    |\n373 |     let repetitions_hir_bounded = Hir::repetition(Repetition { kind: hir::RepetitionKind::Range(hir::RepetitionRange::Bounded(1, 5)), gre...\n    |                                                   ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n362 +    use ast::Ast::Repetition;\n    |\n362 +    use ast::Repetition;\n    |\n362 +    use hir::HirKind::Repetition;\n    |\n362 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:373:176\n    |\n373 | ..., 5)), greedy: false, hir: Box::new(Hir::anchor(Anchor::Start)) });\n    |                                                    ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 33,
      "prompt_conds": [
        "// constraint: *hir.kind() matches HirKind::Empty is true\n",
        "// constraint: *hir.kind() matches HirKind::Anchor(_) or HirKind::Alternation(_) or HirKind::Empty or HirKind::Class(_) or HirKind::Literal(_) or HirKind::Concat(_) or HirKind::WordBoundary(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "test input ranges: (HirKind::Empty, HirKind::Literal('a'), HirKind::Class(Class::new(...)), HirKind::Anchor(Anchor::new(...)), HirKind::WordBoundary(WordBoundary::new(...)), HirKind::Concat(vec![Hir::literal('a'), Hir::literal('b')]), HirKind::Alternation(vec![Hir::literal('c'), Hir::literal('d')]))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let hir = Hir::empty();",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    assert_eq!(writer.visit_post(&hir), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let hir = Hir::literal('a');",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::class(Class::new());",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal('b')]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::literal('b');",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::literal('a');",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir = Hir::empty();",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::anchor(Anchor::new());",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::class(Class::new());",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal('b')]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::word_boundary(WordBoundary::new());",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let hir = Hir::literal('b');",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:375:27\n    |\n375 |     let hir = Hir::anchor(Anchor::new());\n    |                           ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:379:26\n    |\n379 |     let hir = Hir::class(Class::new());\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:383:34\n    |\n383 |     let hir = Hir::word_boundary(WordBoundary::new());\n    |                                  ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:369:28\n    |\n369 |     let hir = Hir::literal('a');\n    |               ------------ ^^^ expected `Literal`, found `char`\n    |               |\n    |               arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n369 |     let hir = Hir::literal(hir::Literal::Unicode('a'));\n    |                            ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:377:50\n    |\n377 |     let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);\n    |                                     ------------ ^^^ expected `Literal`, found `char`\n    |                                     |\n    |                                     arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n377 |     let hir = Hir::alternation(vec![Hir::literal(hir::Literal::Unicode('a')), Hir::literal('b')]);\n    |                                                  ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:377:69\n    |\n377 |     let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal('b')]);\n    |                                                        ------------ ^^^ expected `Literal`, found `char`\n    |                                                        |\n    |                                                        arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n377 |     let hir = Hir::alternation(vec![Hir::literal('a'), Hir::literal(hir::Literal::Unicode('b'))]);\n    |                                                                     ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:381:45\n    |\n381 |     let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal('b')]);\n    |                                ------------ ^^^ expected `Literal`, found `char`\n    |                                |\n    |                                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n381 |     let hir = Hir::concat(vec![Hir::literal(hir::Literal::Unicode('a')), Hir::literal('b')]);\n    |                                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:381:64\n    |\n381 |     let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal('b')]);\n    |                                                   ------------ ^^^ expected `Literal`, found `char`\n    |                                                   |\n    |                                                   arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n381 |     let hir = Hir::concat(vec![Hir::literal('a'), Hir::literal(hir::Literal::Unicode('b'))]);\n    |                                                                ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:385:28\n    |\n385 |     let hir = Hir::literal('b');\n    |               ------------ ^^^ expected `Literal`, found `char`\n    |               |\n    |               arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n385 |     let hir = Hir::literal(hir::Literal::Unicode('b'));\n    |                            ++++++++++++++++++++++   +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class = Class::new();  // Assuming Class has a new() method available",
                "    let hir = Hir::class(class);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new();",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new();  // Assuming Class has a new() method available",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class = Class::new();",
                  "    let hir = Hir::class(class);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:369:17\n    |\n369 |     let class = Class::new();  // Assuming Class has a new() method available\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/hir/print.rs:374:17\n    |\n374 |     let class = Class::new();\n    |                 ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n362 +    use ast::Class;\n    |\n362 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let anchor = Anchor::new();  // Assuming Anchor has a new() method available",
                "    let hir = Hir::anchor(anchor);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();  // Assuming Anchor has a new() method available",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let anchor = Anchor::new();",
                  "    let hir = Hir::anchor(anchor);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:369:18\n    |\n369 |     let anchor = Anchor::new();  // Assuming Anchor has a new() method available\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Anchor`\n   --> regex-syntax/src/hir/print.rs:374:18\n    |\n374 |     let anchor = Anchor::new();\n    |                  ^^^^^^ use of undeclared type `Anchor`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::Anchor;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let word_boundary = WordBoundary::new();  // Assuming WordBoundary has a new() method available",
                "    let hir = Hir::word_boundary(word_boundary);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert_eq!(writer.visit_post(&hir).unwrap(), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert!(writer.wtr.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();  // Assuming WordBoundary has a new() method available",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert_eq!(writer.visit_post(&hir).unwrap(), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();  // Assuming WordBoundary has a new() method available",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let word_boundary = WordBoundary::new();",
                  "    let hir = Hir::word_boundary(word_boundary);",
                  "    assert!(writer.wtr.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:25\n    |\n369 |     let word_boundary = WordBoundary::new();  // Assuming WordBoundary has a new() method available\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:374:25\n    |\n374 |     let word_boundary = WordBoundary::new();\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:376:50\n    |\n376 |     assert_eq!(writer.visit_post(&hir).unwrap(), Ok(()));\n    |                                                  ^^^^^^ expected `()`, found `Result<(), _>`\n    |\n    = note: expected unit type `()`\n                    found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:369:25\n    |\n369 |     let word_boundary = WordBoundary::new();  // Assuming WordBoundary has a new() method available\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `WordBoundary`\n   --> regex-syntax/src/hir/print.rs:374:25\n    |\n374 |     let word_boundary = WordBoundary::new();\n    |                         ^^^^^^^^^^^^ use of undeclared type `WordBoundary`\n    |\nhelp: consider importing this enum\n    |\n362 +    use hir::WordBoundary;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let hir1 = Hir::literal('a');",
                "    let hir2 = Hir::literal('b');",
                "    let hir = Hir::concat(vec![hir1, hir2]);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('a');",
                  "    let hir2 = Hir::literal('b');",
                  "    let hir = Hir::concat(vec![hir1, hir2]);",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('a');",
                  "    let hir2 = Hir::literal('b');",
                  "    let hir = Hir::concat(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('a');",
                  "    let hir2 = Hir::literal('b');",
                  "    let hir = Hir::concat(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('a');",
                  "    let hir2 = Hir::literal('b');",
                  "    let hir = Hir::concat(vec![hir1, hir2]);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('a');",
                  "    let hir2 = Hir::literal('b');",
                  "    let hir = Hir::concat(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('a');",
                  "    let hir2 = Hir::literal('b');",
                  "    let hir = Hir::concat(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:369:29\n    |\n369 |     let hir1 = Hir::literal('a');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n369 |     let hir1 = Hir::literal(hir::Literal::Unicode('a'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:29\n    |\n370 |     let hir2 = Hir::literal('b');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n370 |     let hir2 = Hir::literal(hir::Literal::Unicode('b'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:29\n    |\n375 |     let hir1 = Hir::literal('a');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n375 |     let hir1 = Hir::literal(hir::Literal::Unicode('a'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:376:29\n    |\n376 |     let hir2 = Hir::literal('b');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n376 |     let hir2 = Hir::literal(hir::Literal::Unicode('b'));\n    |                             ++++++++++++++++++++++   +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:369:29\n    |\n369 |     let hir1 = Hir::literal('a');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n369 |     let hir1 = Hir::literal(hir::Literal::Unicode('a'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:29\n    |\n370 |     let hir2 = Hir::literal('b');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n370 |     let hir2 = Hir::literal(hir::Literal::Unicode('b'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:29\n    |\n375 |     let hir1 = Hir::literal('a');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n375 |     let hir1 = Hir::literal(hir::Literal::Unicode('a'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:376:29\n    |\n376 |     let hir2 = Hir::literal('b');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n376 |     let hir2 = Hir::literal(hir::Literal::Unicode('b'));\n    |                             ++++++++++++++++++++++   +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let hir1 = Hir::literal('c');",
                "    let hir2 = Hir::literal('d');",
                "    let hir = Hir::alternation(vec![hir1, hir2]);",
                "    writer.visit_post(&hir).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    assert!(writer.visit_post(&hir).is_ok());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    assert!(writer.visit_post(&hir).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    writer.visit_post(&hir).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let hir1 = Hir::literal('c');",
                  "    let hir2 = Hir::literal('d');",
                  "    let hir = Hir::alternation(vec![hir1, hir2]);",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:369:29\n    |\n369 |     let hir1 = Hir::literal('c');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n369 |     let hir1 = Hir::literal(hir::Literal::Unicode('c'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:29\n    |\n370 |     let hir2 = Hir::literal('d');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n370 |     let hir2 = Hir::literal(hir::Literal::Unicode('d'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:29\n    |\n375 |     let hir1 = Hir::literal('c');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n375 |     let hir1 = Hir::literal(hir::Literal::Unicode('c'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:376:29\n    |\n376 |     let hir2 = Hir::literal('d');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n376 |     let hir2 = Hir::literal(hir::Literal::Unicode('d'));\n    |                             ++++++++++++++++++++++   +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:369:29\n    |\n369 |     let hir1 = Hir::literal('c');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n369 |     let hir1 = Hir::literal(hir::Literal::Unicode('c'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:29\n    |\n370 |     let hir2 = Hir::literal('d');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n370 |     let hir2 = Hir::literal(hir::Literal::Unicode('d'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:29\n    |\n375 |     let hir1 = Hir::literal('c');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n375 |     let hir1 = Hir::literal(hir::Literal::Unicode('c'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:376:29\n    |\n376 |     let hir2 = Hir::literal('d');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n376 |     let hir2 = Hir::literal(hir::Literal::Unicode('d'));\n    |                             ++++++++++++++++++++++   +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/print.rs:363:8\n    |\n363 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:369:29\n    |\n369 |     let hir1 = Hir::literal('c');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n369 |     let hir1 = Hir::literal(hir::Literal::Unicode('c'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:370:29\n    |\n370 |     let hir2 = Hir::literal('d');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n370 |     let hir2 = Hir::literal(hir::Literal::Unicode('d'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:375:29\n    |\n375 |     let hir1 = Hir::literal('c');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n375 |     let hir1 = Hir::literal(hir::Literal::Unicode('c'));\n    |                             ++++++++++++++++++++++   +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/print.rs:376:29\n    |\n376 |     let hir2 = Hir::literal('d');\n    |                ------------ ^^^ expected `Literal`, found `char`\n    |                |\n    |                arguments to this function are incorrect\n    |\nnote: associated function defined here\n   --> regex-syntax/src/hir/mod.rs:239:12\n    |\n239 |     pub fn literal(lit: Literal) -> Hir {\n    |            ^^^^^^^ ------------\nhelp: try wrapping the expression in `hir::Literal::Unicode`\n    |\n376 |     let hir2 = Hir::literal(hir::Literal::Unicode('d'));\n    |                             ++++++++++++++++++++++   +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}