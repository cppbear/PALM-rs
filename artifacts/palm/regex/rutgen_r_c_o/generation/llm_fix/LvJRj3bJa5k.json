{
  "name": "regex_syntax::hir::literal::hir::literal::Literals::trim_suffix",
  "name_with_impl": "regex_syntax::hir::literal::{impl#0}::trim_suffix",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal/mod.rs:215:5:229:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.min_len().map(|len| len <= num_bytes).unwrap_or(true) is true\n",
        "// expected return value/type: None\n"
      ],
      "input_infer": "0 <= num_bytes <= self.min_len() and self.min_len() > 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.add(Literal::Byte(1));",
                "    literals.add(Literal::Byte(2));",
                "    literals.add(Literal::Byte(3));",
                "    let result = literals.trim_suffix(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    literals.add(Literal::Byte(3));",
                  "    let result = literals.trim_suffix(0);",
                  "    assert!(result.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    literals.add(Literal::Byte(3));",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    literals.add(Literal::Byte(3));",
                  "    let result = literals.trim_suffix(0);",
                  "    assert!(result.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1565 |     literals.add(Literal::Byte(2));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1566 |     literals.add(Literal::Byte(3));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1569 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1570 |     literals.add(Literal::Byte(2));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1571 |     literals.add(Literal::Byte(3));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.add(Literal::Byte(1));",
                "    literals.add(Literal::Byte(2));",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1565 |     literals.add(Literal::Byte(2));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1568 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1569 |     literals.add(Literal::Byte(2));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.add(Literal::Byte(1));",
                "    literals.add(Literal::Byte(2));",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    literals.add(Literal::Byte(2));",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1565 |     literals.add(Literal::Byte(2));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1568 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1569 |     literals.add(Literal::Byte(2));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.add(Literal::Byte(3));",
                "    literals.add(Literal::Byte(4));",
                "    let result = literals.trim_suffix(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(3));",
                  "    literals.add(Literal::Byte(4));",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(3));",
                  "    literals.add(Literal::Byte(4));",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(3));",
                  "    literals.add(Literal::Byte(4));",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     literals.add(Literal::Byte(3));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1565 |     literals.add(Literal::Byte(4));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1568 |     literals.add(Literal::Byte(3));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1569 |     literals.add(Literal::Byte(4));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.add(Literal::Byte(1));",
                "    let result = literals.trim_suffix(5);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    let result = literals.trim_suffix(5);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    let result = literals.trim_suffix(5);",
                  "    let mut literals = Literals::empty();",
                  "    literals.add(Literal::Byte(1));",
                  "    let result = literals.trim_suffix(5);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:27\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1567 |     literals.add(Literal::Byte(1));\n     |                           ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.min_len().map(|len| len <= num_bytes).unwrap_or(true) is false\n",
        "// constraint: mut lit in self.lits.iter().cloned() is true\n",
        "// constraint: mut lit in self.lits.iter().cloned() is false\n",
        "// expected return value/type: Some(new)\n"
      ],
      "input_infer": "0 < num_bytes < min_len && lits.len() > 0 && min_len > num_bytes\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![1, 2, 3, 4]),",
                "            Literal::new(vec![2, 3, 4, 5]),",
                "            Literal::new(vec![5, 6, 7, 8]),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits.len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[0].len(), 2);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[1].len(), 2);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[2].len(), 2);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[0].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[1].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[2].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[0] != new_literals.lits[1]);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[1] != new_literals.lits[2]);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[0] != new_literals.lits[2]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[0].len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[1].len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[2].len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[1].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[2].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[0] != new_literals.lits[1]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[1] != new_literals.lits[2]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3, 4]),",
                  "            Literal::new(vec![2, 3, 4, 5]),",
                  "            Literal::new(vec![5, 6, 7, 8]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![1, 2, 3, 4]), Literal::new(vec![2, 3, 4, 5]), Literal::new(vec![5, 6, 7, 8])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    let new_literals = result.unwrap();",
                  "    assert!(new_literals.lits[0] != new_literals.lits[2]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![1, 2, 3]),",
                "            Literal::new(vec![2, 3, 4]),",
                "            Literal::new(vec![3, 4, 5]),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(3);",
                "}"
              ],
              "oracles": [
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits.len(), 3);"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits[0].len(), 0);"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits[1].len(), 0);"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits[2].len(), 0);"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert!(trimmed_literals.lits[0].is_cut());"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert!(trimmed_literals.lits[1].is_cut());"
                ],
                [
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert!(trimmed_literals.lits[2].is_cut());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits[0].len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits[1].len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert_eq!(trimmed_literals.lits[2].len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert!(trimmed_literals.lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert!(trimmed_literals.lits[1].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![1, 2, 3]),",
                  "            Literal::new(vec![2, 3, 4]),",
                  "            Literal::new(vec![3, 4, 5]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals { lits: vec![Literal::new(vec![1, 2, 3]), Literal::new(vec![2, 3, 4]), Literal::new(vec![3, 4, 5])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(3);",
                  "    let trimmed_literals = result.unwrap();",
                  "    assert!(trimmed_literals.lits[2].is_cut());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![10, 20, 30, 40]),",
                "            Literal::new(vec![50, 60, 70, 80]),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals().len(), 2);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[0].len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[1].len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().literals()[0].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().literals()[1].is_cut());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10, 20, 30, 40]),",
                  "            Literal::new(vec![50, 60, 70, 80]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10, 20, 30, 40]),",
                  "            Literal::new(vec![50, 60, 70, 80]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10, 20, 30, 40]),",
                  "            Literal::new(vec![50, 60, 70, 80]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[0].len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10, 20, 30, 40]),",
                  "            Literal::new(vec![50, 60, 70, 80]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[1].len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10, 20, 30, 40]),",
                  "            Literal::new(vec![50, 60, 70, 80]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().literals()[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![10, 20, 30, 40]),",
                  "            Literal::new(vec![50, 60, 70, 80]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![10, 20, 30, 40]), Literal::new(vec![50, 60, 70, 80])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().literals()[1].is_cut());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![100, 200, 300]),",
                "            Literal::new(vec![100, 200]),",
                "            Literal::new(vec![300, 400]),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits.len(), 3);"
                ],
                [
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[0], Literal::new(vec![100, 200]));"
                ],
                [
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[1], Literal::new(vec![100]));"
                ],
                [
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[2], Literal::new(vec![300]));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![100, 200, 300]),",
                  "            Literal::new(vec![100, 200]),",
                  "            Literal::new(vec![300, 400]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let _result = literals.trim_suffix(1);",
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![100, 200, 300]),",
                  "            Literal::new(vec![100, 200]),",
                  "            Literal::new(vec![300, 400]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let _result = literals.trim_suffix(1);  ",
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![100, 200, 300]),",
                  "            Literal::new(vec![100, 200]),",
                  "            Literal::new(vec![300, 400]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[0], Literal::new(vec![100, 200]));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![100, 200, 300]),",
                  "            Literal::new(vec![100, 200]),",
                  "            Literal::new(vec![300, 400]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[1], Literal::new(vec![100]));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![100, 200, 300]),",
                  "            Literal::new(vec![100, 200]),",
                  "            Literal::new(vec![300, 400]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![100, 200, 300]),",
                  "    Literal::new(vec![100, 200]),",
                  "    Literal::new(vec![300, 400]),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[2], Literal::new(vec![300]));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1563:9\n     |\n1563 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:41\n     |\n1565 |             Literal::new(vec![100, 200, 300]),\n     |                                         ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:31\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                               ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:36\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                                    ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:33\n     |\n1575 |     Literal::new(vec![100, 200, 300]),\n     |                                 ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                       ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:28\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                            ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 94 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 94 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1563:9\n     |\n1563 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:41\n     |\n1565 |             Literal::new(vec![100, 200, 300]),\n     |                                         ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:31\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                               ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:36\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                                    ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:33\n     |\n1575 |     Literal::new(vec![100, 200, 300]),\n     |                                 ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                       ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:28\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                            ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 94 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 94 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:9\n     |\n1572 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1563:9\n     |\n1563 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:41\n     |\n1565 |             Literal::new(vec![100, 200, 300]),\n     |                                         ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:31\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                               ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:36\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                                    ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:33\n     |\n1575 |     Literal::new(vec![100, 200, 300]),\n     |                                 ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                       ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:28\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                            ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 95 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 95 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:9\n     |\n1572 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1563:9\n     |\n1563 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:41\n     |\n1565 |             Literal::new(vec![100, 200, 300]),\n     |                                         ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:31\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                               ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:36\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                                    ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:33\n     |\n1575 |     Literal::new(vec![100, 200, 300]),\n     |                                 ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                       ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:28\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                            ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 95 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 95 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1572:9\n     |\n1572 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1563:9\n     |\n1563 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:41\n     |\n1565 |             Literal::new(vec![100, 200, 300]),\n     |                                         ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:31\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                               ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:36\n     |\n1567 |             Literal::new(vec![300, 400]),\n     |                                    ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:33\n     |\n1575 |     Literal::new(vec![100, 200, 300]),\n     |                                 ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:23\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                       ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:28\n     |\n1577 |     Literal::new(vec![300, 400]),\n     |                            ^^^\n     |\n     = note: the literal `400` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/literal/mod.rs:1584:56\n     |\n1584 |     assert_eq!(new_literals.lits[2], Literal::new(vec![300]));\n     |                                                        ^^^\n     |\n     = note: the literal `300` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 95 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 95 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![5, 10, 15]),",
                "            Literal::new(vec![1, 2]),",
                "            Literal::new(vec![10, 20, 30, 40, 50]),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits.len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits[0].len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits[1].len(), 0);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits[2].len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.unwrap().lits[1].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.unwrap().lits[0].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.unwrap().lits[2].is_cut());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits[0].len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits[1].len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert_eq!(result.unwrap().lits[2].len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.unwrap().lits[1].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.unwrap().lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![5, 10, 15]),",
                  "            Literal::new(vec![1, 2]),",
                  "            Literal::new(vec![10, 20, 30, 40, 50]),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![5, 10, 15]), Literal::new(vec![1, 2]), Literal::new(vec![10, 20, 30, 40, 50])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(2);",
                  "    assert!(result.unwrap().lits[2].is_cut());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.min_len().map(|len| len <= num_bytes).unwrap_or(true) is false\n",
        "// constraint: mut lit in self.lits.iter().cloned() is false\n",
        "// expected return value/type: Some(new)\n"
      ],
      "input_infer": "num_bytes: 0 to (min_len - 1) where min_len > 0; self.lits: non-empty; lit.len(): 1 to max_possible_length;\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![b'a']),",
                "            Literal::new(vec![b'b', b'c']),",
                "            Literal::new(vec![b'x', b'y', b'z']),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals().len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().limit_size(), 10);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().limit_class(), 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'c']),",
                  "            Literal::new(vec![b'x', b'y', b'z']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'c']),",
                  "            Literal::new(vec![b'x', b'y', b'z']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'c']),",
                  "            Literal::new(vec![b'x', b'y', b'z']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().limit_size(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'c']),",
                  "            Literal::new(vec![b'x', b'y', b'z']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'c']), Literal::new(vec![b'x', b'y', b'z'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().limit_class(), 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![b'a']),",
                "            Literal::new(vec![b'b']),",
                "            Literal::new(vec![b'c']),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().limit_size(), 10);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().limit_class(), 5);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals().len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals()[0].v, vec![b'a']);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals()[1].v, vec![b'b']);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals()[2].v, vec![b'c']);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().limit_size(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().limit_class(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals()[0].v, vec![b'a']);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals()[1].v, vec![b'b']);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b']),",
                  "            Literal::new(vec![b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(0);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b']), Literal::new(vec![b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(0);",
                  "    assert_eq!(result.unwrap().literals()[2].v, vec![b'c']);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![b'a', b'a']),",
                "            Literal::new(vec![b'b', b'b', b'b']),",
                "            Literal::new(vec![b'c', b'c']),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits.len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits[0].len(), 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits[1].len(), 2);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits[2].len(), 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits[0].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits[2].is_cut());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits.contains(&Literal::new(vec![b'b', b'b'])));"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits.iter().all(|lit| lit.len() > 0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits[0].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits[1].len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().lits[2].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits[2].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits.contains(&Literal::new(vec![b'b', b'b'])));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'c', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a', b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'c', b'c'])], limit_size: 10, limit_class: 5 };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.unwrap().lits.iter().all(|lit| lit.len() > 0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![b'a']),",
                "            Literal::new(vec![b'b', b'b', b'b']),",
                "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.is_some(), true);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals().len(), 3);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals()[0].len(), 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals()[1].len(), 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals()[2].len(), 2);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert!(result.unwrap().literals().iter().all(|lit| lit.len() > 0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals()[0].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals()[1].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert_eq!(result.unwrap().literals()[2].len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a']),",
                  "            Literal::new(vec![b'b', b'b', b'b']),",
                  "            Literal::new(vec![b'x', b'y', b'z', b'x']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(2);",
                  "    let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y', b'z', b'x'])], limit_size: 10, limit_class: 5 };",
                  "    assert!(result.unwrap().literals().iter().all(|lit| lit.len() > 0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `literals`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:13\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_literals`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1569:9\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `literals`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:13\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_literals`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1569:9\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `literals`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:13\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_literals`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1569:9\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `literals`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:13\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_literals`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1569:9\n     |\n1569 |     let mut literals = Literals { lits: vec![Literal::new(vec![b'a']), Literal::new(vec![b'b', b'b', b'b']), Literal::new(vec![b'x', b'y'...\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![b'a', b'b', b'c']),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(3);",
                "}"
              ],
              "oracles": [
                [
                  "    let literals = Literals {",
                  "    lits: vec![Literal::new(vec![b'a', b'b', b'c'])],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let literals = Literals {",
                  "    lits: vec![Literal::new(vec![b'a', b'b', b'c'])],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits.len(), 1);"
                ],
                [
                  "    let literals = Literals {",
                  "    lits: vec![Literal::new(vec![b'a', b'b', b'c'])],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[0].v, vec![b'a']);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals {",
                  "    lits: vec![Literal::new(vec![b'a', b'b', b'c'])],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals {",
                  "    lits: vec![Literal::new(vec![b'a', b'b', b'c'])],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b', b'c']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let literals = Literals {",
                  "    lits: vec![Literal::new(vec![b'a', b'b', b'c'])],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(3);",
                  "    let new_literals = result.unwrap();",
                  "    assert_eq!(new_literals.lits[0].v, vec![b'a']);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:9\n     |\n1566 |     let result = literals.trim_suffix(3);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:9\n     |\n1566 |     let result = literals.trim_suffix(3);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:9\n     |\n1566 |     let result = literals.trim_suffix(3);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 19 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![",
                "            Literal::new(vec![b'a', b'b']),",
                "            Literal::new(vec![b'c', b'd', b'e', b'f']),",
                "        ],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let result = literals.trim_suffix(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals().len(), 2);"
                ],
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[0].len(), 1);"
                ],
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[1].len(), 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b']),",
                  "            Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b']),",
                  "            Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b']),",
                  "            Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[0].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![",
                  "            Literal::new(vec![b'a', b'b']),",
                  "            Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "        ],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    let mut literals = Literals {",
                  "    lits: vec![",
                  "    Literal::new(vec![b'a', b'b']),",
                  "    Literal::new(vec![b'c', b'd', b'e', b'f']),",
                  "    ],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let result = literals.trim_suffix(1);",
                  "    assert_eq!(result.unwrap().literals()[1].len(), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:9\n     |\n1567 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1568:9\n     |\n1568 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:9\n     |\n1567 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1568:9\n     |\n1568 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:9\n     |\n1567 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1568:9\n     |\n1568 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: unused variable: `result`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:9\n     |\n1567 |     let result = literals.trim_suffix(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1559:9\n     |\n1559 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n    --> regex-syntax/src/hir/literal/mod.rs:1568:9\n     |\n1568 |     let mut literals = Literals {\n     |         ----^^^^^^^^\n     |         |\n     |         help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 20 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}